Ext.define("Sch.locale.Locale", {
    l10n: null,
    legacyMode: true,
    localeName: null,
    namespaceId: null,
    constructor: function() {
        if (!Sch.locale.Active) {
            Sch.locale.Active = {};
            this.bindRequire()
        }
        var b = this.self.getName().split(".");
        var a = this.localeName = b.pop();
        this.namespaceId = b.join(".");
        var c = Sch.locale.Active[this.namespaceId];
        if (! (a == "En" && c && c.localeName != "En")) {
            this.apply()
        }
    },
    bindRequire: function() {
        var a = Ext.ClassManager.triggerCreated;
        Ext.ClassManager.triggerCreated = function(d) {
            a.apply(this, arguments);
            var c = Ext.ClassManager.get(d);
            for (var b in Sch.locale.Active) {
                Sch.locale.Active[b].apply(c)
            }
        }
    },
    apply: function(a) {
        if (this.l10n) {
            var h = this,
            f, e;
            var g = this.self.getName();
            var d = function(l, k) {
                k = k || Ext.ClassManager.get(l);
                if (k && (k.activeLocaleId !== g)) {
                    var i = h.l10n[l];
                    if (typeof i === "function") {
                        i(l)
                    } else {
                        if (k.singleton) {
                            k.l10n = Ext.apply({},
                            i, k.prototype && k.prototype.l10n)
                        } else {
                            Ext.override(k, {
                                l10n: i
                            })
                        }
                    }
                    if (h.legacyMode) {
                        var n;
                        if (k.prototype) {
                            n = k.prototype
                        } else {
                            if (k.singleton) {
                                n = k
                            }
                        }
                        if (n && n.legacyMode) {
                            if (n.legacyHolderProp) {
                                if (!n[n.legacyHolderProp]) {
                                    n[n.legacyHolderProp] = {}
                                }
                                n = n[n.legacyHolderProp]
                            }
                            for (var m in i) {
                                if (typeof n[m] !== "function") {
                                    n[m] = i[m]
                                }
                            }
                        }
                    }
                    k.activeLocaleId = g;
                    if (k.onLocalized) {
                        k.onLocalized()
                    }
                }
            };
            if (a) {
                if (!Ext.isArray(a)) {
                    a = [a]
                }
                var b, j;
                for (f = 0, e = a.length; f < e; f++) {
                    if (Ext.isObject(a[f])) {
                        if (a[f].singleton) {
                            j = a[f];
                            b = Ext.getClassName(Ext.getClass(j))
                        } else {
                            j = Ext.getClass(a[f]);
                            b = Ext.getClassName(j)
                        }
                    } else {
                        j = null;
                        b = "string" === typeof a[f] ? a[f] : Ext.getClassName(a[f])
                    }
                    if (b && b in this.l10n) {
                        d(b, j)
                    }
                }
            } else {
                Sch.locale.Active[this.namespaceId] = this;
                for (var c in this.l10n) {
                    d(c)
                }
            }
        }
    }
});
Ext.define("Sch.locale.En", {
    extend: "Sch.locale.Locale",
    singleton: true,
    constructor: function(a) {
        Ext.apply(this, {
            l10n: {
                "Sch.util.Date": {
                    unitNames: {
                        YEAR: {
                            single: "year",
                            plural: "years",
                            abbrev: "yr"
                        },
                        QUARTER: {
                            single: "quarter",
                            plural: "quarters",
                            abbrev: "q"
                        },
                        MONTH: {
                            single: "month",
                            plural: "months",
                            abbrev: "mon"
                        },
                        WEEK: {
                            single: "week",
                            plural: "weeks",
                            abbrev: "w"
                        },
                        DAY: {
                            single: "day",
                            plural: "days",
                            abbrev: "d"
                        },
                        HOUR: {
                            single: "hour",
                            plural: "hours",
                            abbrev: "h"
                        },
                        MINUTE: {
                            single: "minute",
                            plural: "minutes",
                            abbrev: "min"
                        },
                        SECOND: {
                            single: "second",
                            plural: "seconds",
                            abbrev: "s"
                        },
                        MILLI: {
                            single: "ms",
                            plural: "ms",
                            abbrev: "ms"
                        }
                    }
                },
                "Sch.panel.TimelineGridPanel": {
                    loadingText: "Loading, please wait...",
                    savingText: "Saving changes, please wait..."
                },
                "Sch.panel.TimelineTreePanel": {
                    loadingText: "Loading, please wait...",
                    savingText: "Saving changes, please wait..."
                },
                "Sch.mixin.SchedulerView": {
                    loadingText: "Loading events..."
                },
                "Sch.plugin.CurrentTimeLine": {
                    tooltipText: "Current time"
                },
                "Sch.plugin.EventEditor": {
                    saveText: "Save",
                    deleteText: "Delete",
                    cancelText: "Cancel"
                },
                "Sch.plugin.SimpleEditor": {
                    newEventText: "New booking..."
                },
                "Sch.widget.ExportDialog": {
                    generalError: "An error occured, try again.",
                    title: "Export Settings",
                    formatFieldLabel: "Paper format",
                    orientationFieldLabel: "Orientation",
                    rangeFieldLabel: "Export range",
                    showHeaderLabel: "Add page number",
                    orientationPortraitText: "Portrait",
                    orientationLandscapeText: "Landscape",
                    completeViewText: "Complete schedule",
                    currentViewText: "Current view",
                    dateRangeText: "Date range",
                    dateRangeFromText: "Export from",
                    pickerText: "Resize column/rows to desired value",
                    dateRangeToText: "Export to",
                    exportButtonText: "Export",
                    cancelButtonText: "Cancel",
                    progressBarText: "Exporting...",
                    exportersFieldLabel: "Export mode",
                    adjustCols: "Adjust column width",
                    adjustColsAndRows: "Adjust column width and row height",
                    specifyDateRange: "Specify date range"
                },
                "Sch.plugin.Export": {
                    fetchingRows: "Fetching row {0} of {1}",
                    builtPage: "Built page {0} of {1}",
                    requestingPrintServer: "Please wait..."
                },
                "Sch.plugin.exporter.AbstractExporter": {
                    name: "Exporter"
                },
                "Sch.plugin.exporter.SinglePage": {
                    name: "Single page"
                },
                "Sch.plugin.exporter.MultiPageVertical": {
                    name: "Multiple pages (vertically)"
                },
                "Sch.plugin.exporter.MultiPage": {
                    name: "Multiple pages"
                },
                "Sch.preset.Manager": {
                    hourAndDay: {
                        displayDateFormat: "G:i",
                        middleDateFormat: "G:i",
                        topDateFormat: "D d/m"
                    },
                    secondAndMinute: {
                        displayDateFormat: "g:i:s",
                        topDateFormat: "D, d g:iA"
                    },
                    dayAndWeek: {
                        displayDateFormat: "m/d h:i A",
                        middleDateFormat: "D d M"
                    },
                    weekAndDay: {
                        displayDateFormat: "m/d",
                        bottomDateFormat: "d M",
                        middleDateFormat: "Y F d"
                    },
                    weekAndMonth: {
                        displayDateFormat: "m/d/Y",
                        middleDateFormat: "m/d",
                        topDateFormat: "m/d/Y"
                    },
                    weekAndDayLetter: {
                        displayDateFormat: "m/d/Y",
                        middleDateFormat: "D d M Y"
                    },
                    weekDateAndMonth: {
                        displayDateFormat: "m/d/Y",
                        middleDateFormat: "d",
                        topDateFormat: "Y F"
                    },
                    monthAndYear: {
                        displayDateFormat: "m/d/Y",
                        middleDateFormat: "M Y",
                        topDateFormat: "Y"
                    },
                    year: {
                        displayDateFormat: "m/d/Y",
                        middleDateFormat: "Y"
                    },
                    manyYears: {
                        displayDateFormat: "m/d/Y",
                        middleDateFormat: "Y"
                    }
                }
            }
        });
        this.callParent(arguments)
    }
});
Ext.define("Sch.util.Patch", {
    target: null,
    minVersion: null,
    maxVersion: null,
    reportUrl: null,
    description: null,
    applyFn: null,
    ieOnly: false,
    overrides: null,
    onClassExtended: function(a, b) {
        if (Sch.disableOverrides) {
            return
        }
        if (b.ieOnly && !Ext.isIE) {
            return
        }
        if ((!b.minVersion || Ext.versions.extjs.equals(b.minVersion) || Ext.versions.extjs.isGreaterThan(b.minVersion)) && (!b.maxVersion || Ext.versions.extjs.equals(b.maxVersion) || Ext.versions.extjs.isLessThan(b.maxVersion))) {
            if (b.applyFn) {
                b.applyFn()
            } else {
                Ext.ClassManager.get(b.target).override(b.overrides)
            }
        }
    }
});
if (!Ext.ClassManager.get("Sch.patches.BufferedRenderer")) {
    Ext.define("Sch.patches.BufferedRenderer", {
        extend: "Sch.util.Patch",
        requires: ["Ext.grid.plugin.BufferedRenderer"],
        target: "Ext.grid.plugin.BufferedRenderer",
        overrides: {
            onRangeFetched: function() {
                this.tableTopBorderWidth = this.tableTopBorderWidth || 0;
                return this.callParent(arguments)
            },
            refreshSize: function(d, b) {
                var c = this,
                a = c.view;
                if (a.body.dom) {
                    this.callParent(arguments)
                }
            }
        }
    })
}
if (!Ext.ClassManager.get("Sch.patches.NodeStore")) {
    Ext.define("Sch.patches.NodeStore", {
        extend: "Sch.util.Patch",
        requires: ["Ext.data.NodeStore"],
        target: "Ext.data.NodeStore",
        ieOnly: true,
        maxVersion: "5.1.1",
        overrides: {
            afterEdit: function(a, b) {
                if (this.getNode() && b) {
                    if (Ext.Array.indexOf(b, "loaded") !== -1) {
                        return this.add(this.retrieveChildNodes(a))
                    }
                    if (Ext.Array.indexOf(b, "expanded") !== -1) {
                        return this.filter()
                    }
                    if (Ext.Array.indexOf(b, "sorted") !== -1) {
                        return this.sort()
                    }
                }
                Ext.data.Store.prototype.afterEdit.apply(this, arguments)
            }
        }
    })
}
if (!Ext.ClassManager.get("Sch.patches.NodeCache")) {
    Ext.define("Sch.patches.NodeCache", {
        extend: "Sch.util.Patch",
        requires: ["Ext.view.NodeCache"],
        target: "Ext.view.NodeCache",
        minVersion: "5.1.0",
        overrides: {
            scroll: function(d, c, b) {
                var a;
                if (d.length === 0) {
                    a = []
                } else {
                    a = this.callParent(arguments)
                }
                return a
            }
        }
    })
}
Ext.define("Sch.patches.ColumnResizeTree", {
    override: "Sch.panel.TimelineTreePanel",
    afterRender: function() {
        this.callParent(arguments);
        var a = this.lockedGrid.headerCt.findPlugin("gridheaderresizer");
        if (a) {
            a.getConstrainRegion = function() {
                var d = this,
                b = d.dragHd.el,
                c;
                if (d.headerCt.forceFit) {
                    c = d.dragHd.nextNode("gridcolumn:not([hidden]):not([isGroupHeader])");
                    if (!d.headerInSameGrid(c)) {
                        c = null
                    }
                }
                return d.adjustConstrainRegion(Ext.util.Region.getRegion(b), 0, d.headerCt.forceFit ? (c ? c.getWidth() - d.minColWidth: 0) : d.maxColWidth - b.getWidth(), 0, d.minColWidth)
            }
        }
    }
});
if (!Ext.ClassManager.get("Sch.patches.RowSynchronizer")) {
    if (Ext.versions.extjs.isGreaterThan("5.1.0")) {
        Ext.define("Sch.patches.RowSynchronizer", {
            extend: "Sch.util.Patch",
            requires: ["Ext.grid.locking.RowSynchronizer"],
            target: "Ext.grid.locking.RowSynchronizer",
            minVersion: "5.1.0",
            overrides: {
                finish: function(a) {
                    if (!a) {
                        return
                    }
                    return this.callParent(arguments)
                }
            }
        })
    } else {
        Ext.define("Sch.patches.RowSynchronizer", {})
    }
}
Ext.define("Sch.patches.TouchScroll", {
    extend: "Sch.util.Patch",
    requires: ["Ext.scroll.TouchScroller"],
    target: "Ext.scroll.TouchScroller",
    minVersion: "5.1.0",
    overrides: {
        privates: {
            onEvent: function(b) {
                var a = this;
                if (!a[a.listenerMap[b.type]]) {
                    return
                }
                return this.callParent(arguments)
            }
        }
    }
});
Ext.define("Sch.patches.View", {
    extend: "Sch.util.Patch",
    requires: ["Ext.view.View"],
    target: "Ext.view.View",
    minVersion: "5.1.0",
    overrides: {
        handleEvent: function(d) {
            var c = this,
            b = c.keyEventRe.test(d.type),
            a = c.getNavigationModel();
            d.view = c;
            if (b) {
                d.item = a.getItem();
                d.record = a.getRecord()
            }
            if (!d.item) {
                d.item = d.getTarget(c.itemSelector)
            }
            if (d.item && !d.record) {
                d.record = c.getRecord(d.item)
            }
            if (c.processUIEvent(d) !== false) {
                c.processSpecialEvent(d)
            }
            if (b && !Ext.fly(d.target).isInputField()) {
                if (d.getKey() === d.SPACE || d.isNavKeyPress(true)) {
                    d.preventDefault()
                }
            }
        }
    }
});
Ext.define("Sch.patches.Collection", {
    extend: "Sch.util.Patch",
    requires: ["Ext.util.Collection"],
    target: "Ext.util.Collection",
    minVersion: "5.1.0",
    overrides: {
        updateKey: function(b, e) {
            var a = this,
            d = a.map,
            g = a.indices,
            c = a.getSource(),
            f;
            if (c && !c.updating) {
                c.updateKey(b, e)
            } else {
                if (d[e] && (f = a.getKey(b)) !== e) {
                    if (e in d || d[f] !== b) {
                        if (e in d) {
                            delete d[e]
                        }
                        a.updating++;
                        a.generation++;
                        d[f] = b;
                        if (g) {
                            g[f] = g[e];
                            delete g[e]
                        }
                        a.notify("updatekey", [{
                            item: b,
                            newKey: f,
                            oldKey: e
                        }]);
                        a.updating--
                    }
                }
            }
        }
    }
});
Ext.define("Sch.mixin.Localizable", {
    requires: ["Sch.locale.En"],
    legacyMode: true,
    activeLocaleId: "",
    l10n: null,
    isLocaleApplied: function() {
        var b = (this.singleton && this.activeLocaleId) || this.self.activeLocaleId;
        if (!b) {
            return false
        }
        for (var a in Sch.locale.Active) {
            if (b === Sch.locale.Active[a].self.getName()) {
                return true
            }
        }
        return false
    },
    applyLocale: function() {
        for (var a in Sch.locale.Active) {
            Sch.locale.Active[a].apply(this.singleton ? this: this.self.getName())
        }
    },
    L: function() {
        return this.localize.apply(this, arguments)
    },
    localize: function(b, d, g) {
        if (!this.isLocaleApplied() && !g) {
            this.applyLocale()
        }
        if (this.hasOwnProperty("l10n") && this.l10n.hasOwnProperty(b) && "function" != typeof this.l10n[b]) {
            return this.l10n[b]
        }
        var c = this.self && this.self.prototype;
        if (this.legacyMode) {
            var a = d || this.legacyHolderProp;
            var h = a ? this[a] : this;
            if (h && h.hasOwnProperty(b) && "function" != typeof h[b]) {
                return h[b]
            }
            if (c) {
                var e = a ? c[a] : c;
                if (e && e.hasOwnProperty(b) && "function" != typeof e[b]) {
                    return e[b]
                }
            }
        }
        var i = c.l10n && c.l10n[b];
        if (i === null || i === undefined) {
            var f = c && c.superclass;
            if (f && f.localize) {
                i = f.localize(b, d, g)
            }
            if (i === null || i === undefined) {
                throw "Cannot find locale: " + b + " [" + this.self.getName() + "]"
            }
        }
        return i
    }
});
Ext.define("Sch.crud.AbstractManager", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    revision: null,
    stores: null,
    storesIndex: null,
    activeRequests: null,
    delayedSyncs: null,
    transport: null,
    phantomIdField: "$PhantomId",
    autoLoad: false,
    autoSyncTimeout: 100,
    autoSync: false,
    resetIdsBeforeSync: true,
    syncApplySequence: null,
    ignoreUpdates: 0,
    createMissingRecords: false,
    autoSyncTimerId: null,
    constructor: function(a) {
        a = a || {};
        this.mixins.observable.constructor.call(this, a);
        this.activeRequests = {};
        this.delayedSyncs = [];
        this.transport = this.transport || {};
        delete this.stores;
        this.stores = [];
        this.addStore(a.stores);
        if (a.syncApplySequence) {
            this.syncApplySequence = null;
            this.addStoreToApplySequence(a.syncApplySequence)
        }
        if (this.autoLoad) {
            this.load()
        }
    },
    updateStoreIndex: function() {
        var b = {};
        var c;
        for (var d = 0,
        a = this.stores.length; d < a; d++) {
            c = this.stores[d];
            if (c.storeId) {
                b[c.storeId] = this.stores[d]
            }
        }
        this.storesIndex = b
    },
    getStore: function(b) {
        if (!b) {
            return
        }
        if (b instanceof Ext.data.AbstractStore) {
            for (var c = 0,
            a = this.stores.length; c < a; c++) {
                if (this.stores[c].store === b) {
                    return this.stores[c]
                }
            }
        }
        return this.storesIndex[b]
    },
    addStore: function(m, h, a) {
        if (!m) {
            return
        }
        if (!Ext.isArray(m)) {
            m = [m]
        }
        var o, e = [],
        g;
        for (var f = 0,
        c = m.length; f < c; f++) {
            o = m[f];
            if (o instanceof Ext.data.AbstractStore) {
                g = o.getModel && o.getModel() || o.model;
                g = g && g.prototype;
                o = {
                    store: o,
                    storeId: o.storeId,
                    phantomIdField: g && g.phantomIdField
                }
            } else {
                o.storeId = o.storeId || o.store.storeId;
                g = o.store.getModel && o.store.getModel() || o.store.model;
                g = g && g.prototype;
                if (o.stores) {
                    if (!Ext.isArray(o.stores)) {
                        o.stores = [o.stores]
                    }
                    for (var d = 0,
                    b = o.stores.length; d < b; d++) {
                        if ("string" === typeof o.stores[d]) {
                            o.stores[d] = {
                                storeId: o.stores[d]
                            }
                        }
                    }
                }
            }
            if (!o.idProperty) {
                o.idProperty = g && g.idProperty
            }
            e.push(o);
            o.store.crudManager = this;
            this.mon(o.store, {
                add: this.onStoreChange,
                append: this.onStoreChange,
                insert: this.onStoreChange,
                update: this.onStoreChange,
                remove: this.onStoreChange,
                clear: this.onStoreChange,
                scope: this
            })
        }
        if (typeof h === "undefined") {
            this.stores.push.apply(this.stores, e)
        } else {
            var k = h;
            if (a) {
                k += Ext.Array.indexOf(this.stores, a)
            }
            this.stores.splice.apply(this.stores, [].concat([k, 0], e))
        }
        this.updateStoreIndex()
    },
    removeStore: function(b) {
        for (var c = 0,
        a = this.stores.length; c < a; c++) {
            var d = this.stores[c];
            if (d === b || d.store === b || d.storeId === b) {
                this.mun(d.store, {
                    add: this.onStoreChange,
                    append: this.onStoreChange,
                    insert: this.onStoreChange,
                    update: this.onStoreChange,
                    remove: this.onStoreChange,
                    clear: this.onStoreChange,
                    scope: this
                });
                delete this.storesIndex[d.storeId];
                this.stores.splice(c, 1);
                if (this.syncApplySequence) {
                    this.removeStoreFromApplySequence(b)
                }
                break
            }
        }
    },
    addStoreToApplySequence: function(g, e, a) {
        if (!g) {
            return
        }
        if (!Ext.isArray(g)) {
            g = [g]
        }
        var c = [];
        for (var d = 0,
        b = g.length; d < b; d++) {
            var h = g[d];
            if ("object" == typeof h) {
                h = h.storeId || h.store.storeId
            }
            var j = this.getStore(h);
            if (j) {
                c.push(j)
            }
        }
        if (!this.syncApplySequence) {
            this.syncApplySequence = []
        }
        if (typeof e === "undefined") {
            this.syncApplySequence.push.apply(this.syncApplySequence, c)
        } else {
            var f = e;
            if (a) {
                f += Ext.Array.indexOf(this.syncApplySequence, a)
            }
            this.syncApplySequence.splice.apply(this.syncApplySequence, [].concat([f, 0], c))
        }
    },
    removeStoreFromApplySequence: function(b) {
        for (var c = 0,
        a = this.syncApplySequence.length; c < a; c++) {
            var d = this.syncApplySequence[c];
            if (d === b || d.store === b || d.storeId === b) {
                this.syncApplySequence.splice(c, 1);
                break
            }
        }
    },
    onStoreChange: function() {
        if (this.ignoreUpdates) {
            return
        }
        var a = this;
        this.fireEvent("haschanges", this);
        if (this.autoSync) {
            if (!this.autoSyncTimerId) {
                this.autoSyncTimerId = setTimeout(function() {
                    a.autoSyncTimerId = null;
                    a.sync()
                },
                this.autoSyncTimeout)
            }
        }
    },
    hasChanges: function(b) {
        var c;
        if (b) {
            c = this.getStore(b);
            if (!c) {
                return
            }
            return Boolean(c.store.getModifiedRecords() || c.store.getRemovedRecords())
        }
        for (var d = 0,
        a = this.stores.length; d < a; d++) {
            c = this.stores[d].store;
            if (c.getModifiedRecords() || c.getRemovedRecords()) {
                return true
            }
        }
        return false
    },
    getLoadPackage: function(k) {
        var g = {
            type: "load",
            requestId: this.getRequestId(),
            stores: []
        };
        var j = this.stores,
        b = g.stores;
        for (var e = 0,
        c = j.length; e < c; e++) {
            var h = j[e],
            a = k && k[h.storeId],
            f = h.pageSize || h.store.pageSize;
            if (a || f) {
                var d = Ext.apply({
                    storeId: h.storeId,
                    page: 1,
                    pageSize: f
                },
                a);
                j[e].currentPage = d.page;
                b.push(d)
            } else {
                b.push(h.storeId)
            }
        }
        return g
    },
    prepareAdded: function(h, m, k) {
        var o = [];
        for (var c = 0,
        a = h.length; c < a; c++) {
            var d = h[c],
            b = {},
            e = d.getFields();
            if (!b.hasOwnProperty(m)) {
                b[m] = d.getId()
            }
            for (var g = 0,
            n = e.length; g < n; g++) {
                var j = e[g];
                if (j) {
                    if (j.persist && d.data.hasOwnProperty(j.name)) {
                        if (j.serialize) {
                            b[j.name] = j.serialize(d.data[j.name], d)
                        } else {
                            b[j.name] = d.data[j.name]
                        }
                    }
                }
            }
            if (this.resetIdsBeforeSync) {
                delete b[d.idProperty]
            }
            if (k) {
                this.processSubStores(d, b, k)
            }
            o.push(b)
        }
        return o
    },
    prepareUpdated: function(h, k) {
        var n = [],
        b,
        d;
        for (var c = 0,
        a = h.length; c < a; c++) {
            d = h[c];
            b = d.getChanges();
            b[d.idProperty] = d.getId();
            var g = d.getField("parentId");
            if (g && g.persist && !b.hasOwnProperty("parentId")) {
                b.parentId = d.data.parentId
            }
            var m = d.getField("index");
            if (m && m.persist && !b.hasOwnProperty("index")) {
                b.index = d.data.index
            }
            for (var e in b) {
                var j = d.getField(e);
                if (!j || !j.persist) {
                    delete b[e]
                } else {
                    if (j.serialize) {
                        b[e] = j.serialize(b[e], d)
                    }
                }
            }
            if (k) {
                this.processSubStores(d, b, k)
            }
            n.push(b)
        }
        return n
    },
    prepareRemoved: function(e) {
        var a = [],
        d;
        for (var c = 0,
        b = e.length; c < b; c++) {
            d = {};
            d[e[c].idProperty] = e[c].getId();
            a.push(d)
        }
        return a
    },
    processSubStores: function(b, f, a) {
        for (var d = 0,
        h = a.length; d < h; d++) {
            var g = a[d].storeId,
            c = b.get(g);
            if (c) {
                var e = this.getStoreChanges(Ext.apply({
                    store: c
                },
                a[d]));
                if (e) {
                    f[g] = Ext.apply(e, {
                        $store: true
                    })
                } else {
                    delete f[g]
                }
            } else {
                delete f[g]
            }
        }
    },
    getStoreChanges: function(d, g) {
        g = g || d.phantomIdField || this.phantomIdField;
        var f = d.store,
        e = f.getNewRecords(),
        c = f.getUpdatedRecords(),
        h = f.getRemovedRecords(),
        b = d.stores;
        var a;
        if (e.length) {
            e = this.prepareAdded(e, g, b)
        }
        if (c.length) {
            c = this.prepareUpdated(c, b)
        }
        if (h.length) {
            h = this.prepareRemoved(h)
        }
        if (e.length || c.length || h.length) {
            a = {};
            if (e.length) {
                a.added = e
            }
            if (c.length) {
                a.updated = c
            }
            if (h.length) {
                a.removed = h
            }
        }
        return a
    },
    getChangeSetPackage: function() {
        var d = {
            type: "sync",
            requestId: this.getRequestId(),
            revision: this.revision
        };
        var f = this.stores,
        j = 0;
        for (var b = 0,
        a = f.length; b < a; b++) {
            var e = f[b],
            g = e.phantomIdField || this.phantomIdField,
            h = e.storeId;
            var c = this.getStoreChanges(e, g);
            if (c) {
                j++;
                d[h] = c
            }
        }
        return j ? d: null
    },
    getSubStoresData: function(h, f, g, e) {
        if (!h) {
            return
        }
        var j = [];
        var a = function(n, o) {
            for (var l = 0,
            i = o.length; l < i; l++) {
                var k = o[l].storeId;
                if (n[k]) {
                    j.push({
                        id: n[g],
                        storeDesc: o[l],
                        data: n[k]
                    });
                    delete n[k]
                }
            }
        };
        var d = 0,
        c = h.length;
        if (e) {
            for (; d < c; d++) {
                a(h[d], f);
                var b = this.getSubStoresData(h[d].children, f, g, true);
                if (b) {
                    j = j.concat(b)
                }
            }
        } else {
            for (; d < c; d++) {
                a(h[d], f)
            }
        }
        return j
    },
    loadDataToStore: function(a, d) {
        var h = a.store,
        j = a.stores,
        k = a.idProperty || "id",
        f = h instanceof Ext.data.TreeStore,
        g;
        var m = d && d.rows;
        h.metaData = d && d.metaData;
        if (m) {
            if (j) {
                g = this.getSubStoresData(m, j, k, f)
            }
            h.__loading = true;
            if (f) {
                h.proxy.data = m;
                h.load()
            } else {
                h.totalCount = d.total;
                h.currentPage = a.currentPage;
                h.loadData(m);
                h.fireEvent("load", h, h.getRange(), true)
            }
            if (g) {
                for (var c = 0,
                b = g.length; c < b; c++) {
                    var e = g[c];
                    this.loadDataToStore(Ext.apply({
                        store: h[f ? "getNodeById": "getById"](e.id).get(e.storeDesc.storeId)
                    },
                    e.storeDesc), e.data)
                }
            }
            h.__loading = false
        }
    },
    loadData: function(b) {
        for (var c = 0,
        a = this.stores.length; c < a; c++) {
            var e = this.stores[c],
            d = b[e.storeId];
            if (d) {
                this.loadDataToStore(e, d)
            }
        }
    },
    applyChangesToRecord: function(g, i, m) {
        var h = g.fields,
        f = g.data,
        e = {},
        c = false,
        a;
        if (m) {
            for (var d = 0,
            b = m.length; d < b; d++) {
                a = m[d].storeId;
                if (i.hasOwnProperty(a)) {
                    e[a] = true;
                    var l = g.get(a);
                    if (l) {
                        this.applyChangesToStore(Ext.apply({
                            store: l
                        },
                        m[d]), i[a])
                    } else {
                        Ext.log("Can't find store for the response sub-package")
                    }
                }
            }
        }
        for (a in i) {
            if (i.hasOwnProperty(a) && !e[a]) {
                var k = i[a];
                if (!g.isEqual(f[a], k)) {
                    if (!c) {
                        c = true;
                        g.beginEdit()
                    }
                    if (a === g.idProperty) {
                        g.setId(k)
                    } else {
                        g.set(a, k)
                    }
                }
            }
        }
        this.ignoreUpdates++;
        if (c) {
            g.endEdit()
        }
        this.ignoreUpdates--;
        g.commit()
    },
    applyRemovals: function(o, m, d) {
        var p = d.idProperty,
        n = o.getRemovedRecords(),
        q = d.findByIdFn,
        a = d.removeRecordFn,
        h = 0;
        for (var g = 0,
        e = m.length; g < e; g++) {
            var f = false;
            var c = m[g][p];
            for (var l = 0,
            b = n.length; l < b; l++) {
                if (n[l].getId() == c) {
                    n.splice(l, 1);
                    f = true;
                    h++;
                    break
                }
            }
            if (!f) {
                var i = q(c);
                if (i) {
                    this.ignoreUpdates++;
                    a(i);
                    Ext.Array.remove(n, i);
                    h++;
                    this.ignoreUpdates--
                } else {
                    Ext.log("Can't find record to remove from the response package")
                }
            }
        }
        return h
    },
    applyChangesToStore: function(h, x) {
        var t, r, p;
        var b = h.phantomIdField || this.phantomIdField,
        i = h.idProperty,
        o = h.store;
        if (!i) {
            var e = o.getModel && o.getModel() || o.model;
            e = e && e.prototype;
            i = e && e.idProperty || "id"
        }
        var q = function(j) {
            return o.data.getByKey(j)
        },
        w = function(j) {
            return o.getById(j)
        },
        g = function(j) {
            return o.getNodeById(j)
        },
        a,
        v;
        var n, m;
        if (o instanceof Ext.data.TreeStore) {
            n = m = g;
            a = function(k) {
                var j = (k.parentId && o.getNodeById(k.parentId)) || o.getRootNode();
                return j.appendChild(k)
            };
            v = function(j) {
                return j.parentNode.removeChild(j)
            }
        } else {
            n = q;
            m = w;
            a = function(j) {
                return o.add(j)[0]
            };
            v = function(j) {
                return o.remove(j)
            }
        }
        var l = x.rows,
        u = x.removed,
        c;
        if (l) {
            var y, d, f = h.stores;
            for (t = 0, r = l.length; t < r; t++) {
                y = l[t];
                d = y[b];
                p = y[i];
                c = null;
                if (d != null) {
                    c = n(d)
                } else {
                    if (i) {
                        c = m(p)
                    }
                }
                if (c) {
                    this.applyChangesToRecord(c, y, f)
                } else {
                    this.ignoreUpdates++;
                    c = a(y);
                    this.ignoreUpdates--;
                    c.commit()
                }
            }
        }
        if (u && this.applyRemovals(o, u, {
            idProperty: i,
            findByIdFn: m,
            removeRecordFn: v
        })) {
            o.fireEvent("datachanged", o)
        }
    },
    applyChangeSetResponse: function(c) {
        var b = this.syncApplySequence || this.stores;
        for (var d = 0,
        a = b.length; d < a; d++) {
            var e = c[b[d].storeId];
            if (e) {
                this.applyChangesToStore(b[d], e)
            }
        }
    },
    getRequestId: function() {
        return Ext.Date.now()
    },
    onLoad: function(b, c) {
        var a = this.decode(b);
        if (!a || !a.success) {
            this.fireEvent("loadfail", this, a, c);
            this.warn("CrudManager: Load failed, please inspect the server response", b);
            return a
        }
        this.revision = a.revision;
        this.activeRequests.load = null;
        if (this.fireEvent("beforeloadapply", this, a) !== false) {
            this.loadData(a);
            this.fireEvent("load", this, a, c);
            this.fireEvent("nochanges", this)
        }
        return a
    },
    onSync: function(b, c) {
        var a = this.decode(b);
        if (!a || !a.success) {
            this.fireEvent("syncfail", this, a, c);
            this.warn("CrudManager: Sync failed, please inspect the server response", b);
            return a
        }
        this.revision = a.revision;
        if (this.fireEvent("beforesyncapply", this, a) !== false) {
            this.applyChangeSetResponse(a);
            this.fireEvent("sync", this, a, c);
            if (!this.hasChanges()) {
                this.fireEvent("nochanges", this)
            }
        }
        return a
    },
    load: function(e, a, d) {
        var b;
        if (typeof e === "object") {
            b = e;
            e = a;
            a = d;
            d = arguments[3]
        }
        var c = this.getLoadPackage(b);
        if (this.fireEvent("beforeload", this, c) !== false) {
            d = d || this;
            if (this.activeRequests.load) {
                this.cancelRequest(this.activeRequests.load.desc);
                this.fireEvent("loadcanceled", this, c)
            }
            this.activeRequests.load = {
                id: c.requestId
            };
            this.activeRequests.load.desc = this.sendRequest({
                data: this.encode(c),
                type: "load",
                success: function(g, h) {
                    var f = this.onLoad(g, h);
                    if (a && (!f || !f.success)) {
                        a.call(d, f, g)
                    } else {
                        if (e) {
                            e.call(d, f, g)
                        }
                    }
                },
                failure: function(f, g) {
                    this.onLoad(f, g);
                    if (a) {
                        a.apply(d, arguments)
                    }
                    this.activeRequests.load = null
                },
                scope: this
            })
        } else {
            this.fireEvent("loadcanceled", this, c)
        }
    },
    sync: function(d, a, c) {
        if (this.activeRequests.sync) {
            this.delayedSyncs.push(arguments);
            this.fireEvent("syncdelayed", this, arguments);
            return
        }
        var b = this.getChangeSetPackage();
        c = c || this;
        if (!b) {
            if (d) {
                d.call(c, null, null)
            }
            return
        }
        if (this.fireEvent("beforesync", this, b) === false) {
            this.fireEvent("synccanceled", this, b);
            return
        }
        this.activeRequests.sync = {
            id: b.requestId
        };
        this.activeRequests.sync.desc = this.sendRequest({
            data: this.encode(b),
            type: "sync",
            success: function(h, f) {
                var e = this.onSync(h, f);
                var g = this.activeRequests.sync;
                this.activeRequests.sync = null;
                if (a && (!e || !e.success)) {
                    a.call(c, e, h, g)
                } else {
                    if (d) {
                        d.call(c, e, h, g)
                    }
                }
                this.runDelayedSync()
            },
            failure: function(f, e) {
                this.onSync(f, e);
                if (a) {
                    a.apply(c, arguments)
                }
                this.activeRequests.sync = null;
                this.runDelayedSync()
            },
            scope: this
        })
    },
    runDelayedSync: function() {
        var a = this.delayedSyncs.shift();
        if (!a) {
            return
        }
        this.sync.apply(this, a)
    },
    commit: function() {
        for (var b = 0,
        a = this.stores.length; b < a; b++) {
            this.stores[b].store.commitChanges()
        }
    },
    reject: function() {
        for (var b = 0,
        a = this.stores.length; b < a; b++) {
            this.stores[b].store.rejectChanges()
        }
    },
    warn: function() {
        if ("console" in window) {
            var a = console;
            a.log && a.log.apply && a.log.apply(a, arguments)
        }
    },
    isLoading: function() {
        return !! this.activeRequests.load
    }
});
Ext.define("Sch.crud.transport.Ajax", {
    defaultMethod: {
        load: "GET",
        sync: "POST"
    },
    cancelRequest: function(a) {
        Ext.Ajax.abort(a)
    },
    sendRequest: function(b) {
        var c = b.data,
        d = this.transport[b.type],
        e = d.paramName,
        f = Ext.apply({},
        d && d.params),
        g = d.method || this.defaultMethod[b.type];
        var a = Ext.apply({
            url: d.url,
            method: g,
            params: f,
            failure: b.failure,
            success: function(h, i) {
                if (b.success) {
                    b.success.call(b.scope || this, h.responseXml || h.responseText)
                }
            },
            scope: b.scope
        },
        d.requestConfig);
        if (!e) {
            if (this.format === "xml") {
                Ext.apply(a, {
                    xmlData: c
                })
            } else {
                Ext.apply(a, {
                    jsonData: c
                })
            }
        } else {
            a.params = a.params || {};
            a.params[e] = c
        }
        this.fireEvent("beforesend", this, f, b.type, a);
        return Ext.Ajax.request(a)
    }
});
Ext.define("Sch.crud.encoder.Json", {
    format: "json",
    encode: function(a) {
        return Ext.JSON.encode(a)
    },
    decode: function(a) {
        if (typeof a == "object") {
            return a
        }
        return Ext.JSON.decode(a, true)
    }
});
Ext.define("Sch.crud.encoder.Xml", {
    requires: ["Ext.XTemplate"],
    format: "xml",
    stringReplaces: [[/&/g, "&amp;"], [/</g, "&lt;"], [/>/g, "&gt;"], [/"/g, "&quot;"]],
    encodeString: function(e) {
        if (!e) {
            return e
        }
        var a = e.toString(),
        c = this.stringReplaces;
        for (var d = 0,
        b = c.length; d < b; d++) {
            a = a.replace(c[d][0], c[d][1])
        }
        return a
    },
    encodeRecords: function(c) {
        var a = "";
        for (var d = 0,
        b = c.length; d < b; d++) {
            a += this.encodeRecord(c[d])
        }
        return a
    },
    encodeRecord: function(b) {
        var a = "<record>";
        for (var c in b) {
            var d = b[c];
            a += '<field id="' + this.encodeString(c) + '">' + (d && d.$store ? this.encodeStoreChanges({
                storeId: c
            },
            d) : this.encodeString(d)) + "</field>"
        }
        a += "</record>";
        return a
    },
    encodeStoreChanges: function(b, c) {
        var a = '<store id="' + this.encodeString(b.storeId) + '">';
        if (c.added) {
            a += "<added>" + this.encodeRecords(c.added) + "</added>"
        }
        if (c.updated) {
            a += "<updated>" + this.encodeRecords(c.updated) + "</updated>"
        }
        if (c.removed) {
            a += "<removed>" + this.encodeRecords(c.removed) + "</removed>"
        }
        a += "</store>";
        return a
    },
    encode: function(e) {
        var a, d, b, c;
        switch (e.type) {
        case "load":
            a = '<load requestId="' + this.encodeString(e.requestId) + '">';
            for (d = 0, b = e.stores.length; d < b; d++) {
                c = e.stores[d];
                if (typeof c === "string") {
                    a += '<store id="' + this.encodeString(c) + '"/>'
                } else {
                    a += '<store id="' + this.encodeString(c.storeId) + '" page="' + this.encodeString(c.page) + '" pageSize="' + this.encodeString(c.pageSize) + '"/>'
                }
            }
            a += "</load>";
            return a;
        case "sync":
            a = '<sync requestId="' + this.encodeString(e.requestId) + '" revision="' + this.encodeString(e.revision) + '">';
            for (d in e) {
                if (e.hasOwnProperty(d)) {
                    c = this.getStore(d);
                    if (c) {
                        a += this.encodeStoreChanges(c, e[d])
                    }
                }
            }
            a += "</sync>";
            break
        }
        return a
    },
    stringToXML: function(b) {
        if (!b) {
            return
        }
        var a;
        if (window.DOMParser) {
            a = (new DOMParser()).parseFromString(b, "text/xml")
        } else {
            if (window.ActiveXObject) {
                a = new ActiveXObject("Microsoft.XMLDOM");
                a.async = false;
                a.loadXML(b)
            }
        }
        return a
    },
    decodeRecords: function(d) {
        var b = [];
        for (var c = 0,
        a = d.length; c < a; c++) {
            b.push(this.decodeRecord(d[c]))
        }
        return b
    },
    decodeRecord: function(f) {
        var b = f.childNodes,
        a = {},
        g;
        for (var e = 0,
        c = b.length; e < c; e++) {
            var h = b[e];
            if (h.nodeName == "field") {
                g = "";
                if (h.firstChild) {
                    var d = this.getElementByTagName(h, "store");
                    g = d ? this.decodeStore(d) : h.firstChild.nodeValue
                }
                a[h.getAttribute("id")] = g
            }
        }
        return a
    },
    getElementsByTagName: function(f, c) {
        var e = f.childNodes,
        b = [];
        for (var d = 0,
        a = e.length; d < a; d++) {
            if (e[d].nodeName == c) {
                b.push(e[d])
            }
        }
        return b
    },
    getElementByTagName: function(e, b) {
        var d = e.childNodes;
        for (var c = 0,
        a = d.length; c < a; c++) {
            if (d[c].nodeName == b) {
                return d[c]
            }
        }
    },
    decodeStore: function(a) {
        var d = {},
        c = this.getElementsByTagName(a, "rows");
        if (c.length) {
            d.rows = this.decodeRecords(this.getElementsByTagName(c[0], "record"));
            var b = parseInt(c[0].getAttribute("total"), 10);
            if (isNaN(b) || b < d.rows.length) {
                b = d.rows.length
            }
            d.total = b
        }
        var e = this.getElementByTagName(a, "removed");
        if (e) {
            d.removed = this.decodeRecords(this.getElementsByTagName(e, "record"))
        }
        return d
    },
    decode: function(a) {
        var d = typeof a == "string" ? this.stringToXML(a) : a;
        if (!d) {
            return
        }
        var k = {},
        e = d.documentElement,
        g = e.getElementsByTagName("store"),
        f,
        h;
        k.requestId = e.getAttribute("requestId");
        k.revision = e.getAttribute("revision");
        k.success = e.getAttribute("success") || "false";
        k.success = k.success.toLowerCase() == "true";
        if (!k.success) {
            k.code = e.getAttribute("code");
            var j = e.getElementsByTagName("message")[0];
            k.message = j && j.firstChild && j.firstChild.nodeValue
        }
        for (var c = 0,
        b = g.length; c < b; c++) {
            f = g[c];
            h = f.getAttribute("id");
            if (this.getStore(h)) {
                k[h] = this.decodeStore(f)
            }
        }
        return k
    }
});
Ext.define("Sch.data.CrudManager", {
    extend: "Sch.crud.AbstractManager",
    mixins: ["Sch.crud.encoder.Json", "Sch.crud.transport.Ajax"],
    resourceStore: null,
    eventStore: null,
    constructor: function(b) {
        b = b || {};
        var d = b.resourceStore,
        c = b.eventStore,
        a = [];
        if (d) {
            if (d instanceof Ext.data.AbstractStore) {
                d = {
                    store: d,
                    storeId: d.storeId
                }
            }
            delete b.resourceStore;
            this.resourceStore = d;
            a.push(d)
        }
        if (c) {
            if (c instanceof Ext.data.AbstractStore) {
                c = {
                    store: c,
                    storeId: c.storeId
                }
            }
            delete b.eventStore;
            this.eventStore = c;
            a.push(c)
        }
        if (a.length) {
            b.stores = (b.stores || []).concat(a)
        }
        this.callParent([b])
    },
    getResourceStore: function() {
        return this.resourceStore && this.resourceStore.store
    },
    getEventStore: function() {
        return this.eventStore && this.eventStore.store
    }
});
Ext.define("Sch.util.Date", {
    requires: "Ext.Date",
    mixins: ["Sch.mixin.Localizable"],
    singleton: true,
    stripEscapeRe: /(\\.)/g,
    hourInfoRe: /([gGhHisucUOPZ]|MS)/,
    unitHash: null,
    unitsByName: {},
    constructor: function() {
        var a = Ext.Date;
        var c = this.unitHash = {
            MILLI: a.MILLI,
            SECOND: a.SECOND,
            MINUTE: a.MINUTE,
            HOUR: a.HOUR,
            DAY: a.DAY,
            WEEK: "w",
            MONTH: a.MONTH,
            QUARTER: "q",
            YEAR: a.YEAR
        };
        Ext.apply(this, c);
        var b = this;
        this.units = [b.MILLI, b.SECOND, b.MINUTE, b.HOUR, b.DAY, b.WEEK, b.MONTH, b.QUARTER, b.YEAR]
    },
    onLocalized: function() {
        this.setUnitNames(this.L("unitNames"))
    },
    setUnitNames: function(f, b) {
        var e = this.unitsByName = {};
        this.l10n.unitNames = f;
        this._unitNames = Ext.apply({},
        f);
        var c = this.unitHash;
        for (var a in c) {
            if (c.hasOwnProperty(a)) {
                var d = c[a];
                this._unitNames[d] = this._unitNames[a];
                e[a] = d;
                e[d] = d
            }
        }
    },
    betweenLesser: function(b, d, a) {
        var c = b.getTime();
        return d.getTime() <= c && c < a.getTime()
    },
    constrain: function(b, c, a) {
        return this.min(this.max(b, c), a)
    },
    compareUnits: function(c, b) {
        var a = Ext.Array.indexOf(this.units, c),
        d = Ext.Array.indexOf(this.units, b);
        return a > d ? 1 : (a < d ? -1 : 0)
    },
    isUnitGreater: function(b, a) {
        return this.compareUnits(b, a) > 0
    },
    copyTimeValues: function(b, a) {
        b.setHours(a.getHours());
        b.setMinutes(a.getMinutes());
        b.setSeconds(a.getSeconds());
        b.setMilliseconds(a.getMilliseconds())
    },
    add: function(b, c, e) {
        var f = Ext.Date.clone(b);
        if (!c || e === 0) {
            return f
        }
        switch (c.toLowerCase()) {
        case this.MILLI:
            f = new Date(b.getTime() + e);
            break;
        case this.SECOND:
            f = new Date(b.getTime() + (e * 1000));
            break;
        case this.MINUTE:
            f = new Date(b.getTime() + (e * 60000));
            break;
        case this.HOUR:
            f = new Date(b.getTime() + (e * 3600000));
            break;
        case this.DAY:
            f.setDate(b.getDate() + e);
            if (f.getHours() === 23 && b.getHours() === 0) {
                f = Ext.Date.add(f, Ext.Date.HOUR, 1)
            }
            break;
        case this.WEEK:
            f.setDate(b.getDate() + e * 7);
            break;
        case this.MONTH:
            var a = b.getDate();
            if (a > 28) {
                a = Math.min(a, Ext.Date.getLastDateOfMonth(this.add(Ext.Date.getFirstDateOfMonth(b), this.MONTH, e)).getDate())
            }
            f.setDate(a);
            f.setMonth(f.getMonth() + e);
            break;
        case this.QUARTER:
            f = this.add(b, this.MONTH, e * 3);
            break;
        case this.YEAR:
            f.setFullYear(b.getFullYear() + e);
            break
        }
        return f
    },
    getUnitDurationInMs: function(a) {
        return this.add(new Date(1, 0, 1), a, 1) - new Date(1, 0, 1)
    },
    getMeasuringUnit: function(a) {
        if (a === this.WEEK) {
            return this.DAY
        }
        return a
    },
    getDurationInUnit: function(e, a, c, d) {
        var b;
        switch (c) {
        case this.YEAR:
            b = this.getDurationInYears(e, a);
            break;
        case this.QUARTER:
            b = this.getDurationInMonths(e, a) / 3;
            break;
        case this.MONTH:
            b = this.getDurationInMonths(e, a);
            break;
        case this.WEEK:
            b = this.getDurationInDays(e, a) / 7;
            break;
        case this.DAY:
            b = this.getDurationInDays(e, a);
            break;
        case this.HOUR:
            b = this.getDurationInHours(e, a);
            break;
        case this.MINUTE:
            b = this.getDurationInMinutes(e, a);
            break;
        case this.SECOND:
            b = this.getDurationInSeconds(e, a);
            break;
        case this.MILLI:
            b = this.getDurationInMilliseconds(e, a);
            break
        }
        return d ? b: Math.round(b)
    },
    getUnitToBaseUnitRatio: function(b, a) {
        if (b === a) {
            return 1
        }
        switch (b) {
        case this.YEAR:
            switch (a) {
            case this.QUARTER:
                return 1 / 4;
            case this.MONTH:
                return 1 / 12
            }
            break;
        case this.QUARTER:
            switch (a) {
            case this.YEAR:
                return 4;
            case this.MONTH:
                return 1 / 3
            }
            break;
        case this.MONTH:
            switch (a) {
            case this.YEAR:
                return 12;
            case this.QUARTER:
                return 3
            }
            break;
        case this.WEEK:
            switch (a) {
            case this.DAY:
                return 1 / 7;
            case this.HOUR:
                return 1 / 168
            }
            break;
        case this.DAY:
            switch (a) {
            case this.WEEK:
                return 7;
            case this.HOUR:
                return 1 / 24;
            case this.MINUTE:
                return 1 / 1440
            }
            break;
        case this.HOUR:
            switch (a) {
            case this.DAY:
                return 24;
            case this.MINUTE:
                return 1 / 60
            }
            break;
        case this.MINUTE:
            switch (a) {
            case this.HOUR:
                return 60;
            case this.SECOND:
                return 1 / 60;
            case this.MILLI:
                return 1 / 60000
            }
            break;
        case this.SECOND:
            switch (a) {
            case this.MILLI:
                return 1 / 1000
            }
            break;
        case this.MILLI:
            switch (a) {
            case this.SECOND:
                return 1000
            }
            break
        }
        return - 1
    },
    getDurationInMilliseconds: function(b, a) {
        return (a - b)
    },
    getDurationInSeconds: function(b, a) {
        return (a - b) / 1000
    },
    getDurationInMinutes: function(b, a) {
        return (a - b) / 60000
    },
    getDurationInHours: function(b, a) {
        return (a - b) / 3600000
    },
    getDurationInDays: function(c, b) {
        var a = c.getTimezoneOffset() - b.getTimezoneOffset();
        return (b - c + a * 60 * 1000) / 86400000
    },
    getDurationInMonths: function(b, a) {
        return ((a.getFullYear() - b.getFullYear()) * 12) + (a.getMonth() - b.getMonth())
    },
    getDurationInYears: function(b, a) {
        return this.getDurationInMonths(b, a) / 12
    },
    min: function(b, a) {
        return b < a ? b: a
    },
    max: function(b, a) {
        return b > a ? b: a
    },
    intersectSpans: function(c, d, b, a) {
        return this.betweenLesser(c, b, a) || this.betweenLesser(b, c, d)
    },
    getNameOfUnit: function(a) {
        a = this.getUnitByName(a);
        switch (a.toLowerCase()) {
        case this.YEAR:
            return "YEAR";
        case this.QUARTER:
            return "QUARTER";
        case this.MONTH:
            return "MONTH";
        case this.WEEK:
            return "WEEK";
        case this.DAY:
            return "DAY";
        case this.HOUR:
            return "HOUR";
        case this.MINUTE:
            return "MINUTE";
        case this.SECOND:
            return "SECOND";
        case this.MILLI:
            return "MILLI"
        }
        throw "Incorrect UnitName"
    },
    getReadableNameOfUnit: function(b, a) {
        if (!this.isLocaleApplied()) {
            this.applyLocale()
        }
        return this._unitNames[b][a ? "plural": "single"]
    },
    getShortNameOfUnit: function(a) {
        if (!this.isLocaleApplied()) {
            this.applyLocale()
        }
        return this._unitNames[a].abbrev
    },
    getUnitByName: function(a) {
        if (!this.isLocaleApplied()) {
            this.applyLocale()
        }
        if (!this.unitsByName[a]) {
            Ext.Error.raise("Unknown unit name: " + a)
        }
        return this.unitsByName[a]
    },
    getNext: function(c, g, a, f) {
        var e = Ext.Date.clone(c);
        f = arguments.length < 4 ? 1 : f;
        a = a == null ? 1 : a;
        switch (g) {
        case this.MILLI:
            e = this.add(c, g, a);
            break;
        case this.SECOND:
            e = this.add(c, g, a);
            if (e.getMilliseconds() > 0) {
                e.setMilliseconds(0)
            }
            break;
        case this.MINUTE:
            e = this.add(c, g, a);
            if (e.getSeconds() > 0) {
                e.setSeconds(0)
            }
            if (e.getMilliseconds() > 0) {
                e.setMilliseconds(0)
            }
            break;
        case this.HOUR:
            e = this.add(c, g, a);
            if (e.getMinutes() > 0) {
                e.setMinutes(0)
            }
            if (e.getSeconds() > 0) {
                e.setSeconds(0)
            }
            if (e.getMilliseconds() > 0) {
                e.setMilliseconds(0)
            }
            break;
        case this.DAY:
            var d = c.getHours() === 23 && this.add(e, this.HOUR, 1).getHours() === 1;
            if (d) {
                e = this.add(e, this.DAY, 2);
                this.clearTime(e);
                return e
            }
            this.clearTime(e);
            e = this.add(e, this.DAY, a);
            if (e.getHours() === 1) {
                this.clearTime(e)
            }
            break;
        case this.WEEK:
            this.clearTime(e);
            var b = e.getDay();
            e = this.add(e, this.DAY, f - b + 7 * (a - (f <= b ? 0 : 1)));
            if (e.getDay() !== f) {
                e = this.add(e, this.HOUR, 1)
            } else {
                this.clearTime(e)
            }
            break;
        case this.MONTH:
            e = this.add(e, this.MONTH, a);
            e.setDate(1);
            this.clearTime(e);
            break;
        case this.QUARTER:
            e = this.add(e, this.MONTH, ((a - 1) * 3) + (3 - (e.getMonth() % 3)));
            this.clearTime(e);
            e.setDate(1);
            break;
        case this.YEAR:
            e = new Date(e.getFullYear() + a, 0, 1);
            break;
        default:
            throw "Invalid date unit"
        }
        return e
    },
    getNumberOfMsFromTheStartOfDay: function(a) {
        return a - this.clearTime(a, true) || 86400000
    },
    getNumberOfMsTillTheEndOfDay: function(a) {
        return this.getStartOfNextDay(a, true) - a
    },
    getStartOfNextDay: function(b, f, e) {
        var d = this.add(e ? b: this.clearTime(b, f), this.DAY, 1);
        if (d.getDate() == b.getDate()) {
            var c = this.add(this.clearTime(b, f), this.DAY, 2).getTimezoneOffset();
            var a = b.getTimezoneOffset();
            d = this.add(d, this.MINUTE, a - c)
        }
        return d
    },
    getEndOfPreviousDay: function(b, c) {
        var a = c ? b: this.clearTime(b, true);
        if (a - b) {
            return a
        } else {
            return this.add(a, this.DAY, -1)
        }
    },
    timeSpanContains: function(c, b, d, a) {
        return (d - c) >= 0 && (b - a) >= 0
    },
    compareWithPrecision: function(e, c, f) {
        var d = Sch.util.Date,
        b = Ext.Date,
        a;
        switch (f) {
        case d.DAY:
            e = Number(b.format(e, "Ymd"));
            c = Number(b.format(c, "Ymd"));
            break;
        case d.WEEK:
            e = Number(b.format(e, "YmW"));
            c = Number(b.format(c, "YmW"));
            break;
        case d.MONTH:
            e = Number(b.format(e, "Ym"));
            c = Number(b.format(c, "Ym"));
            break;
        case d.QUARTER:
            e = e.getFullYear() * 4 + Math.floor(e.getMonth() / 3);
            c = c.getFullYear() * 4 + Math.floor(c.getMonth() / 3);
            break;
        case d.YEAR:
            e = e.getFullYear();
            c = c.getFullYear();
            break;
        default:
        case d.MILLI:
        case d.SECOND:
        case d.MINUTE:
        case d.HOUR:
            f = f && this.getUnitDurationInMs(f) || 1;
            e = Math.floor(e.valueOf() / f);
            c = Math.floor(c.valueOf() / f);
            break
        } ((e < c) && (a = -1)) || ((e > c) && (a = +1)) || (a = 0);
        return a
    },
    getValueInUnits: function(a, b) {
        switch (b) {
        case this.MONTH:
            return a.getMonth();
        case this.DAY:
            return a.getDate();
        case this.HOUR:
            return a.getHours();
        case this.MINUTE:
            return a.getMinutes();
        case this.SECOND:
            return a.getSeconds()
        }
    },
    setValueInUnits: function(b, c, e) {
        var a = Ext.Date.clone(b),
        d;
        switch (c) {
        case this.YEAR:
            d = "setFullYear";
            break;
        case this.MONTH:
            d = "setMonth";
            break;
        case this.DAY:
            d = "setDate";
            break;
        case this.HOUR:
            d = "setHours";
            break;
        case this.MINUTE:
            d = "setMinutes";
            break;
        case this.SECOND:
            d = "setSeconds";
            break;
        case this.MILLI:
            d = "setMilliseconds";
            break
        }
        a[d](e);
        return a
    },
    getSubUnit: function(a) {
        switch (a) {
        case this.YEAR:
            return this.MONTH;
        case this.MONTH:
            return this.DAY;
        case this.DAY:
            return this.HOUR;
        case this.HOUR:
            return this.MINUTE;
        case this.MINUTE:
            return this.SECOND;
        case this.SECOND:
            return this.MILLI
        }
    },
    setValueInSubUnits: function(a, b, c) {
        b = this.getSubUnit(b);
        return this.setValueInUnits(a, b, c)
    },
    mergeDates: function(c, b, a) {
        var d = Ext.Date.clone(c);
        switch (a) {
        case this.YEAR:
            d.setFullYear(b.getFullYear());
        case this.MONTH:
            d.setMonth(b.getMonth());
        case this.WEEK:
        case this.DAY:
            if (a === this.WEEK) {
                d = this.add(d, this.DAY, b.getDay() - d.getDay())
            } else {
                d.setDate(b.getDate())
            }
        case this.HOUR:
            d.setHours(b.getHours());
        case this.MINUTE:
            d.setMinutes(b.getMinutes());
        case this.SECOND:
            d.setSeconds(b.getSeconds());
        case this.MILLI:
            d.setMilliseconds(b.getMilliseconds())
        }
        return d
    },
    splitToSubUnits: function(d, c, a, b) {
        a = a || 1;
        b = arguments.length < 4 ? 1 : b;
        switch (c) {
        case this.MONTH:
            return this.splitMonth(d, a, b);
        case this.WEEK:
        case this.DAY:
            return this.splitDay(d, a);
        default:
            break
        }
    },
    splitYear: function(e, c) {
        var b = this.clearTime(e, true);
        b.setMonth(0);
        b.setDate(1);
        var a = [];
        for (var d = 0; d <= 12; d = d + c) {
            a.push(this.add(b, this.MONTH, d))
        }
        return a
    },
    splitMonth: function(h, c, g) {
        var b = this.clearTime(h, true);
        b.setDate(1);
        b = this.add(b, this.DAY, g - b.getDay());
        var d = Ext.Date.clone(b);
        var f = this.add(b, this.MONTH, 1);
        var a = [];
        for (var e = 0; d.getTime() < f.getTime(); e = e + c) {
            d = this.add(b, this.WEEK, e);
            a.push(d)
        }
        return a
    },
    splitWeek: function(f, c, e) {
        var b = this.add(f, this.DAY, e - f.getDay());
        b = this.clearTime(b);
        var a = [];
        for (var d = 0; d <= 7; d = d + c) {
            a.push(this.add(b, this.DAY, d))
        }
        return a
    },
    splitDay: function(e, b) {
        var d = this.clearTime(e, true);
        var a = [];
        for (var c = 0; c <= 24; c = c + b) {
            a.push(this.add(d, this.HOUR, c))
        }
        return a
    },
    splitHour: function(e, b) {
        var d = new Date(e.getTime());
        d.setMinutes(0);
        d.setSeconds(0);
        d.setMilliseconds(0);
        var a = [];
        for (var c = 0; c <= 60; c = c + b) {
            a.push(this.add(d, this.MINUTE, c))
        }
        return a
    },
    splitMinute: function(e, b) {
        var d = Ext.Date.clone(e);
        d.setSeconds(0);
        d.setMilliseconds(0);
        var a = [];
        for (var c = 0; c <= 60; c = c + b) {
            a.push(this.add(d, this.SECOND, c))
        }
        return a
    },
    clearTime: function(a, b) {
        if (a.getHours() > 0 || a.getMinutes() > 0 || a.getSeconds() > 0) {
            return Ext.Date.clearTime(a, b)
        }
        return b ? Ext.Date.clone(a) : a
    }
});
Ext.define("Sch.util.DragTracker", {
    extend: "Ext.dd.DragTracker",
    requires: ["Ext.util.Region"],
    xStep: 1,
    yStep: 1,
    deferredActivation: 0,
    constructor: function() {
        this.callParent(arguments);
        this.on("dragstart",
        function() {
            var b = this.el;
            var a = {
                scroll: this.onMouseMove,
                pinchstart: this.onMouseUp,
                scope: this
            };
            b.on(a);
            this.on("dragend",
            function() {
                b.un(a)
            },
            this, {
                single: true
            })
        });
        this.moveListener = {
            pinchstart: this.abortWait,
            touchend: this.abortWait,
            mouseup: this.abortWait,
            mousemove: this.onMoveWhileWaiting,
            scope: this,
            capture: true
        }
    },
    setXStep: function(a) {
        this.xStep = a
    },
    startScroll: null,
    deferTimer: null,
    deferTolerance: 10,
    moveListener: null,
    setYStep: function(a) {
        this.yStep = a
    },
    onMoveWhileWaiting: function(d, a) {
        var c = d.getXY();
        var b = this.startXY;
        if (Math.max(Math.abs(b[0] - c[0]), Math.abs(b[1] - c[1])) > this.deferTolerance) {
            this.abortWait();
            this.onMouseUp(d)
        }
    },
    abortWait: function() {
        clearTimeout(this.deferTimer);
        this.deferTimer = null;
        Ext.getDoc().un(this.moveListener)
    },
    getRegion: function() {
        var j = this.startXY,
        f = this.el.getScroll(),
        l = this.getXY(),
        c = l[0],
        b = l[1],
        h = f.left - this.startScroll.left,
        m = f.top - this.startScroll.top,
        i = j[0] - h,
        g = j[1] - m,
        e = Math.min(i, c),
        d = Math.min(g, b),
        a = Math.abs(i - c),
        k = Math.abs(g - b);
        return new Ext.util.Region(d, e + a, d + k, e)
    },
    onMouseDown: function(c, b) {
        if (c.event.touches && c.event.touches.length > 1) {
            return
        }
        c.stopPropagation = Ext.emptyFn;
        this.startXY = c.getXY();
        if (this.deferredActivation) {
            var a = this;
            Ext.getDoc().on(this.moveListener);
            this.deferTimer = setTimeout(function() {
                var d = a.deferredActivation;
                Ext.getDoc().un(a.moveListener);
                a.deferredActivation = false;
                a.onMouseDown(c, b);
                a.deferredActivation = d
            },
            this.deferredActivation);
            return
        }
        this.callParent([c, b]);
        this.lastXY = this.startXY;
        this.startScroll = this.el.getScroll()
    },
    onMouseMove: function(g, f) {
        if (this.active && g.type === "mousemove" && Ext.isIE9m && !g.browserEvent.button) {
            g.preventDefault();
            this.onMouseUp(g);
            return
        }
        g.preventDefault();
        var d = g.type === "scroll" ? this.lastXY: g.getXY(),
        b = this.startXY;
        if (!this.active) {
            if (Math.max(Math.abs(b[0] - d[0]), Math.abs(b[1] - d[1])) > this.tolerance) {
                this.triggerStart(g)
            } else {
                return
            }
        }
        var a = d[0],
        h = d[1];
        if (this.xStep > 1) {
            a -= this.startXY[0];
            a = Math.round(a / this.xStep) * this.xStep;
            a += this.startXY[0]
        }
        if (this.yStep > 1) {
            h -= this.startXY[1];
            h = Math.round(h / this.yStep) * this.yStep;
            h += this.startXY[1]
        }
        var c = this.xStep > 1 || this.yStep > 1;
        if (!c || a !== d[0] || h !== d[1]) {
            this.lastXY = [a, h];
            if (this.fireEvent("mousemove", this, g) === false) {
                this.onMouseUp(g)
            } else {
                this.onDrag(g);
                this.fireEvent("drag", this, g)
            }
        }
    }
});
Ext.define("Sch.util.ScrollManager", {
    singleton: true,
    vthresh: 25,
    hthresh: 25,
    increment: 100,
    frequency: 500,
    animate: true,
    animDuration: 200,
    activeCmp: null,
    activeEl: null,
    targetScroller: null,
    scrollElRegion: null,
    scrollProcess: {},
    pt: null,
    scrollWidth: null,
    scrollHeight: null,
    direction: "both",
    constructor: function() {
        this.doScroll = Ext.Function.bind(this.doScroll, this)
    },
    triggerRefresh: function() {
        if (this.activeEl) {
            this.refreshElRegion();
            this.clearScrollInterval();
            this.onMouseMove()
        }
    },
    doScroll: function() {
        var f = this.scrollProcess,
        e = f.cmp,
        d = f.dir[0],
        b = this.increment,
        h = this.activeCmp.getScrollX(),
        g = this.activeCmp.getScrollY();
        if (d === "r") {
            b = Math.min(b, this.scrollWidth - h - this.activeEl.dom.clientWidth)
        } else {
            if (d === "d") {
                b = Math.min(b, this.scrollHeight - g - this.activeEl.dom.clientHeight)
            }
        }
        b = Math.max(b, 0);
        var c = 0,
        a = 0;
        if (d === "r") {
            c = b
        }
        if (d === "l") {
            c = -b
        }
        if (d === "u") {
            a = -b
        }
        if (d === "d") {
            a = b
        }
        e.scrollBy(c, a, {
            duration: this.animDuration,
            callback: this.triggerRefresh,
            scope: this
        })
    },
    clearScrollInterval: function() {
        var a = this.scrollProcess;
        if (a.id) {
            clearTimeout(a.id)
        }
        a.id = 0;
        a.cmp = null;
        a.dir = ""
    },
    isScrollAllowed: function(a) {
        switch (this.direction) {
        case "both":
            return true;
        case "horizontal":
            return a === "right" || a === "left";
        case "vertical":
            return a === "up" || a === "down";
        default:
            throw "Invalid direction: " + this.direction
        }
    },
    startScrollInterval: function(b, a) {
        if (!this.isScrollAllowed(a)) {
            return
        }
        this.clearScrollInterval();
        this.scrollProcess.cmp = b;
        this.scrollProcess.dir = a;
        this.scrollProcess.id = setTimeout(this.doScroll, this.frequency)
    },
    onMouseMove: function(g) {
        var n = g ? g.getPoint() : this.pt,
        m = n.x,
        l = n.y,
        h = this.scrollProcess,
        d = this.activeCmp.getScrollX(),
        c = this.activeCmp.getScrollY(),
        a,
        k = this.activeCmp,
        b = this.activeEl,
        j = this.scrollElRegion,
        f = b.dom,
        i = this;
        this.pt = n;
        if (j && j.contains(n) && b.isScrollable()) {
            if (j.bottom - l <= i.vthresh && (this.scrollHeight - c - f.clientHeight > 0)) {
                if (h.cmp != k) {
                    this.startScrollInterval(this.activeCmp, "down")
                }
                return
            } else {
                if (j.right - m <= i.hthresh && (this.scrollWidth - d - f.clientWidth > 0)) {
                    if (h.cmp != k) {
                        this.startScrollInterval(this.activeCmp, "right")
                    }
                    return
                } else {
                    if (l - j.top <= i.vthresh && c > 0) {
                        if (h.cmp != k) {
                            this.startScrollInterval(this.activeCmp, "up")
                        }
                        return
                    } else {
                        if (m - j.left <= i.hthresh && d > 0) {
                            if (h.cmp != k) {
                                this.startScrollInterval(this.activeCmp, "left")
                            }
                            return
                        }
                    }
                }
            }
        }
        this.clearScrollInterval()
    },
    refreshElRegion: function() {
        this.scrollElRegion = this.activeEl.getRegion()
    },
    activate: function(a, b) {
        this.direction = b || "both";
        this.activeCmp = a;
        this.activeEl = a.getEl();
        if (a.scrollManager) {
            this.targetScroller = a.scrollManager.scroller;
            this.scrollWidth = this.targetScroller.getMaxPosition().x;
            this.scrollHeight = this.targetScroller.getMaxPosition().y
        } else {
            this.scrollWidth = this.activeEl.dom.scrollWidth;
            this.scrollHeight = this.activeEl.dom.scrollHeight
        }
        this.refreshElRegion();
        this.activeEl.on("mousemove", this.onMouseMove, this)
    },
    deactivate: function() {
        this.clearScrollInterval();
        this.activeEl.un("mousemove", this.onMouseMove, this);
        this.targetScroller = this.activeEl = this.activeCmp = this.scrollElRegion = this.scrollWidth = this.scrollHeight = null;
        this.direction = "both"
    }
});
if (!Ext.ClassManager.get("Sch.model.Customizable")) {
    Ext.define("Sch.model.Customizable", {
        extend: "Ext.data.Model",
        customizableFields: null,
        previous: null,
        __editing: null,
        __editCounter: 0,
        constructor: function() {
            var a = this.callParent(arguments);
            return a
        },
        onClassExtended: function(b, d, a) {
            var c = a.onBeforeCreated;
            a.onBeforeCreated = function(n, i) {
                c.apply(this, arguments);
                var j = n.prototype;
                if (!j.customizableFields) {
                    return
                }
                j.customizableFields = (n.superclass.customizableFields || []).concat(j.customizableFields);
                var g = j.customizableFields;
                var h = {};
                var l = this;
                var f = Ext.Array.findBy(n.fields,
                function(o) {
                    return o.name === j.idProperty
                });
                l.idField = j.idField = f;
                if (!n.fieldsMap[j.idProperty]) {
                    n.fieldsMap[j.idProperty] = f
                }
                Ext.Array.each(g,
                function(o) {
                    if (typeof o == "string") {
                        o = {
                            name: o
                        }
                    }
                    h[o.name] = o
                });
                var k = j.fields;
                var m = [];
                var e = [];
                Ext.Array.each(k,
                function(o) {
                    if (o.isCustomizableField) {
                        e.push(o.getName())
                    }
                });
                if (j.idProperty !== "id" && j.getField("id")) {
                    if (!j.getField("id").hasOwnProperty("name")) {
                        e.push("id")
                    }
                }
                if (j.idProperty !== "Id" && j.getField("Id")) {
                    if (!j.getField("Id").hasOwnProperty("name")) {
                        e.push("Id")
                    }
                }
                n.removeFields(e);
                Ext.Object.each(h,
                function(o, r) {
                    r.isCustomizableField = true;
                    var s = r.name || r.getName();
                    var x = s === "Id" ? "idProperty": s.charAt(0).toLowerCase() + s.substr(1) + "Field";
                    var t = j[x];
                    var w = t || s;
                    var v;
                    if (j.getField(w)) {
                        v = Ext.applyIf({
                            name: s,
                            isCustomizableField: true
                        },
                        j.getField(w));
                        j.getField(w).isCustomizableField = true;
                        v = Ext.create("data.field." + (v.type || "auto"), v);
                        g.push(v)
                    } else {
                        v = Ext.applyIf({
                            name: w,
                            isCustomizableField: true
                        },
                        r);
                        v = Ext.create("data.field." + (v.type || "auto"), v);
                        m.push(v)
                    }
                    var q = Ext.String.capitalize(s);
                    if (q != "Id") {
                        var u = "get" + q;
                        var p = "set" + q;
                        if (!j[u] || j[u].__getterFor__ && j[u].__getterFor__ != w) {
                            j[u] = function() {
                                return this.get(w)
                            };
                            j[u].__getterFor__ = w
                        }
                        if (!j[p] || j[p].__setterFor__ && j[p].__setterFor__ != w) {
                            j[p] = function(y) {
                                return this.set(w, y)
                            };
                            j[p].__setterFor__ = w
                        }
                    }
                });
                n.addFields(m)
            }
        },
        set: function(f, b) {
            var a;
            var d;
            this.previous = this.previous || {};
            if (typeof f === "string") {
                a = this.get(f);
                if (a instanceof Date && !(b instanceof Date)) {
                    b = this.getField(f).convert(b, this)
                }
                if ((a instanceof Date && (a - b)) || !(a instanceof Date) && a !== b) {
                    this.previous[f] = a
                } else {
                    return []
                }
            } else {
                for (var e in f) {
                    a = this.get(e);
                    var c = f[e];
                    if (a instanceof Date && !(c instanceof Date)) {
                        c = this.getField(e).convert(c, this)
                    }
                    if ((a instanceof Date && (a - c)) || !(a instanceof Date) && a !== c) {
                        this.previous[e] = a
                    }
                }
            }
            d = this.callParent(arguments);
            if (!this.__editing) {
                delete this.previous
            }
            return d
        },
        reject: function() {
            var b = this,
            a = b.modified || {},
            c;
            b.__editing = true;
            b.previous = b.previous || {};
            for (c in a) {
                if (a.hasOwnProperty(c)) {
                    if (typeof a[c] != "function") {
                        b.previous[c] = b.get(c)
                    }
                }
            }
            b.callParent(arguments);
            delete b.previous;
            b.__editing = false
        },
        beginEdit: function() {
            this.__editCounter++;
            this.__editing = true;
            this.callParent(arguments)
        },
        cancelEdit: function() {
            this.__editCounter = 0;
            this.__editing = false;
            this.callParent(arguments);
            delete this.previous
        },
        endEdit: function(b, c) {
            if (--this.__editCounter === 0) {
                if (!b && this.getModifiedFieldNames) {
                    var a = this.editMemento;
                    if (!c) {
                        c = this.getModifiedFieldNames(a.data)
                    }
                    if (c && c.length === 0) {
                        b = true
                    }
                }
                this.callParent([b].concat(Array.prototype.slice.call(arguments, 1)));
                this.__editing = false;
                delete this.previous
            }
        }
    })
}
Ext.define("Sch.data.mixin.EventStore", {
    model: "Sch.model.Event",
    config: {
        model: "Sch.model.Event"
    },
    requires: ["Sch.util.Date", "Sch.patches.NodeStore"],
    resourceStore: null,
    isEventStore: true,
    getResourceStore: function() {
        return this.resourceStore
    },
    setResourceStore: function(a) {
        if (this.resourceStore) {
            this.resourceStore.un({
                beforesync: this.onResourceStoreBeforeSync,
                write: this.onResourceStoreWrite,
                scope: this
            })
        }
        this.resourceStore = a;
        if (a) {
            a.on({
                beforesync: this.onResourceStoreBeforeSync,
                write: this.onResourceStoreWrite,
                scope: this
            })
        }
    },
    onResourceStoreBeforeSync: function(b, c) {
        var a = b.create;
        if (a) {
            for (var e, d = a.length - 1; d >= 0; d--) {
                e = a[d];
                e._phantomId = e.id
            }
        }
    },
    onResourceStoreWrite: function(c, b) {
        if (b.wasSuccessful()) {
            var d = this,
            a = b.getRecords();
            Ext.each(a,
            function(e) {
                if (e._phantomId && !e.phantom) {
                    d.each(function(f) {
                        if (f.getResourceId() === e._phantomId) {
                            f.assign(e)
                        }
                    })
                }
            })
        }
    },
    isDateRangeAvailable: function(g, a, c, e) {
        var f = Sch.util.Date,
        b = e.getEvents(this),
        d = true;
        Ext.each(b,
        function(h) {
            d = (c === h || !f.intersectSpans(g, a, h.getStartDate(), h.getEndDate()));
            return d
        });
        return d
    },
    getEventsInTimeSpan: function(f, b, a) {
        var d = new Ext.util.MixedCollection();
        var c = [];
        if (a !== false) {
            var e = Sch.util.Date;
            this.forEachScheduledEvent(function(i, h, g) {
                if (e.intersectSpans(h, g, f, b)) {
                    c.push(i)
                }
            })
        } else {
            this.forEachScheduledEvent(function(i, h, g) {
                if (h - f >= 0 && b - g >= 0) {
                    c.push(i)
                }
            })
        }
        d.addAll(c);
        return d
    },
    forEachScheduledEvent: function(b, a) {
        this.each(function(e) {
            var d = e.getStartDate(),
            c = e.getEndDate();
            if (d && c) {
                return b.call(a || this, e, d, c)
            }
        },
        this)
    },
    getTotalTimeSpan: function() {
        var a = new Date(9999, 0, 1),
        b = new Date(0),
        c = Sch.util.Date;
        this.each(function(d) {
            if (d.getStartDate()) {
                a = c.min(d.getStartDate(), a)
            }
            if (d.getEndDate()) {
                b = c.max(d.getEndDate(), b)
            }
        });
        a = a < new Date(9999, 0, 1) ? a: null;
        b = b > new Date(0) ? b: null;
        return {
            start: a || null,
            end: b || a || null
        }
    },
    getEventsForResource: function(a) {
        return a.getEvents(this)
    },
    append: function(a) {
        throw "Must be implemented by consuming class"
    },
    setAssignmentStore: null,
    getAssignmentStore: null
});
if (!Ext.ClassManager.get("Sch.model.Range")) {
    Ext.define("Sch.model.Range", {
        extend: "Sch.model.Customizable",
        requires: ["Sch.util.Date"],
        idProperty: "Id",
        config: Ext.versions.touch ? {
            idProperty: "Id"
        }: null,
        startDateField: "StartDate",
        endDateField: "EndDate",
        nameField: "Name",
        clsField: "Cls",
        customizableFields: [{
            name: "StartDate",
            type: "date",
            dateFormat: "c"
        },
        {
            name: "EndDate",
            type: "date",
            dateFormat: "c"
        },
        {
            name: "Cls",
            type: "string"
        },
        {
            name: "Name",
            type: "string"
        }],
        setStartDate: function(a, d) {
            var c = this.getEndDate();
            var b = this.getStartDate();
            this.set(this.startDateField, a);
            if (d === true && c && b) {
                this.setEndDate(Sch.util.Date.add(a, Sch.util.Date.MILLI, c - b))
            }
        },
        setEndDate: function(b, d) {
            var a = this.getStartDate();
            var c = this.getEndDate();
            this.set(this.endDateField, b);
            if (d === true && a && c) {
                this.setStartDate(Sch.util.Date.add(b, Sch.util.Date.MILLI, -(c - a)))
            }
        },
        setStartEndDate: function(b, a) {
            this.beginEdit();
            this.set(this.startDateField, b);
            this.set(this.endDateField, a);
            this.endEdit()
        },
        getDates: function() {
            var c = [],
            b = this.getEndDate();
            for (var a = Ext.Date.clearTime(this.getStartDate(), true); a < b; a = Sch.util.Date.add(a, Sch.util.Date.DAY, 1)) {
                c.push(a)
            }
            return c
        },
        forEachDate: function(b, a) {
            return Ext.each(this.getDates(), b, a)
        },
        isValid: function() {
            var b = this.callParent(arguments);
            if (b) {
                var c = this.getStartDate(),
                a = this.getEndDate();
                b = !c || !a || (a - c >= 0)
            }
            return b
        },
        shift: function(b, a) {
            this.setStartEndDate(Sch.util.Date.add(this.getStartDate(), b, a), Sch.util.Date.add(this.getEndDate(), b, a))
        },
        fullCopy: function() {
            return this.copy.apply(this, arguments)
        }
    })
}
if (!Ext.ClassManager.get("Sch.model.TimeAxisTick")) {
    Ext.define("Sch.model.TimeAxisTick", {
        extend: "Sch.model.Range",
        startDateField: "start",
        endDateField: "end"
    })
}
if (!Ext.ClassManager.get("Sch.model.Resource")) {
    Ext.define("Sch.model.Resource", {
        extend: "Sch.model.Customizable",
        idProperty: "Id",
        config: Ext.versions.touch ? {
            idProperty: "Id"
        }: null,
        nameField: "Name",
        customizableFields: [{
            name: "Name",
            type: "string"
        }],
        getEventStore: function() {
            return this.joined && this.joined[0] && this.joined[0].eventStore || this.parentNode && this.parentNode.getEventStore()
        },
        getEvents: function(d) {
            var f = this.getId();
            f = f == null ? this.internalId: f;
            d = d || this.getEventStore();
            if (d.indexByResource) {
                return d.indexByResource[f] || []
            } else {
                var c = [];
                for (var b = 0,
                a = d.getCount(); b < a; b++) {
                    var e = d.getAt(b);
                    if (e.data[e.resourceIdField] === f) {
                        c.push(e)
                    }
                }
                return c
            }
        }
    })
}
Ext.define("Sch.data.mixin.ResourceStore", {});
Ext.define("Sch.data.mixin.FilterableTreeStore", {
    isFilteredFlag: false,
    isHiddenFlag: false,
    lastTreeFilter: null,
    lastTreeHiding: null,
    allowExpandCollapseWhileFiltered: true,
    reApplyFilterOnDataChange: true,
    suspendIncrementalFilterRefresh: 0,
    filterGeneration: 0,
    currentFilterGeneration: null,
    dataChangeListeners: null,
    monitoringDataChange: false,
    onClassMixedIn: function(a) {
        a.override(Sch.data.mixin.FilterableTreeStore.prototype.inheritables() || {})
    },
    initTreeFiltering: function() {
        this.treeFilter = new Ext.util.Filter({
            filterFn: this.isNodeFilteredIn,
            scope: this
        });
        this.dataChangeListeners = {
            nodeappend: this.onNeedToUpdateFilter,
            nodeinsert: this.onNeedToUpdateFilter,
            scope: this
        }
    },
    startDataChangeMonitoring: function() {
        if (this.monitoringDataChange) {
            return
        }
        this.monitoringDataChange = true;
        this.on(this.dataChangeListeners)
    },
    stopDataChangeMonitoring: function() {
        if (!this.monitoringDataChange) {
            return
        }
        this.monitoringDataChange = false;
        this.un(this.dataChangeListeners)
    },
    onNeedToUpdateFilter: function() {
        if (this.reApplyFilterOnDataChange && !this.suspendIncrementalFilterRefresh) {
            this.reApplyFilter()
        }
    },
    clearTreeFilter: function() {
        if (!this.isTreeFiltered()) {
            return
        }
        this.currentFilterGeneration = null;
        this.isFilteredFlag = false;
        this.lastTreeFilter = null;
        if (!this.isTreeFiltered(true)) {
            this.stopDataChangeMonitoring()
        }
        this.refreshNodeStoreContent();
        this.fireEvent("filter-clear", this)
    },
    reApplyFilter: function() {
        if (this.isHiddenFlag) {
            this.hideNodesBy.apply(this, this.lastTreeHiding.concat(this.isFilteredFlag))
        }
        if (this.isFilteredFlag) {
            this.filterTreeBy(this.lastTreeFilter)
        }
    },
    refreshNodeStoreContent: function() {
        var b = this,
        a = b.getFilters();
        if (a.indexOf(b.treeFilter) < 0) {
            b.addFilter(b.treeFilter)
        } else {
            this.getFilters().fireEvent("endupdate", this.getFilters())
        }
    },
    getIndexInTotalDataset: function(d) {
        var c = this.getRootNode(),
        f = -1;
        var g = this.rootVisible;
        if (!g && d == c) {
            return - 1
        }
        var b = this.isTreeFiltered();
        var a = this.currentFilterGeneration;
        var e = function(j) {
            if (b && j.__filterGen != a || j.hidden) {
                if (j == d) {
                    return false
                }
            }
            if (g || j != c) {
                f++
            }
            if (j == d) {
                return false
            }
            if (!j.data.leaf && j.isExpanded()) {
                var l = j.childNodes,
                i = l.length;
                for (var h = 0; h < i; h++) {
                    if (e(l[h]) === false) {
                        return false
                    }
                }
            }
        };
        e(c);
        return f
    },
    isTreeFiltered: function(a) {
        return this.isFilteredFlag || a && this.isHiddenFlag
    },
    markFilteredNodes: function(i, b) {
        var h = this;
        var d = this.currentFilterGeneration;
        var c = {};
        var j = this.getRootNode(),
        l = this.rootVisible;
        var o = function(q) {
            var p = q.parentNode;
            while (p && !c[p.internalId]) {
                c[p.internalId] = true;
                p = p.parentNode
            }
        };
        var a = b.filter;
        var n = b.scope || this;
        var k = b.shallow;
        var m = b.checkParents || k;
        var f = b.fullMatchingParents;
        var e = b.onlyParents || f;
        if (e && m) {
            throw new Error("Can't combine `onlyParents` and `checkParents` options")
        }
        if (l) {
            c[j.internalId] = true
        }
        var g = function(s) {
            if (s.hidden) {
                return
            }
            var q, t, r, p;
            if (s.data.leaf) {
                if (a.call(n, s, c)) {
                    c[s.internalId] = true;
                    o(s)
                }
            } else {
                if (e) {
                    q = a.call(n, s);
                    t = s.childNodes;
                    r = t.length;
                    if (q) {
                        c[s.internalId] = true;
                        o(s);
                        if (f) {
                            s.cascadeBy(function(u) {
                                c[u.internalId] = true
                            });
                            return
                        }
                    }
                    for (p = 0; p < r; p++) {
                        if (q && t[p].data.leaf) {
                            c[t[p].internalId] = true
                        } else {
                            if (!t[p].data.leaf) {
                                g(t[p])
                            }
                        }
                    }
                } else {
                    if (m) {
                        q = a.call(n, s, c);
                        if (q) {
                            c[s.internalId] = true;
                            o(s)
                        }
                    }
                    if (!m || !k || k && (q || s == j && !l)) {
                        t = s.childNodes;
                        r = t.length;
                        for (p = 0; p < r; p++) {
                            g(t[p])
                        }
                    }
                }
            }
        };
        g(i);
        j.cascadeBy(function(p) {
            if (c[p.internalId]) {
                p.__filterGen = d;
                if (h.allowExpandCollapseWhileFiltered && !p.data.leaf) {
                    p.expand()
                }
            }
        })
    },
    filterTreeBy: function(c, b) {
        this.currentFilterGeneration = this.filterGeneration++;
        var a;
        if (arguments.length == 1 && Ext.isObject(arguments[0])) {
            b = c.scope;
            a = c.filter
        } else {
            a = c;
            c = {
                filter: a,
                scope: b
            }
        }
        this.fireEvent("nodestore-datachange-start", this);
        c = c || {};
        this.markFilteredNodes(this.getRootNode(), c);
        this.startDataChangeMonitoring();
        this.isFilteredFlag = true;
        this.lastTreeFilter = c;
        this.fireEvent("nodestore-datachange-end", this);
        this.fireEvent("filter-set", this);
        this.refreshNodeStoreContent()
    },
    isNodeFilteredIn: function(c) {
        var b = this.isTreeFiltered();
        var a = this.currentFilterGeneration;
        return this.loading || !Boolean(b && c.__filterGen != a || c.hidden)
    },
    hasNativeFilters: function() {
        var c = this,
        b = c.getFilters(),
        a = b.getCount();
        return (a && a > 1) || b.indexOf(c.treeFilter) < 0
    },
    hideNodesBy: function(b, a, d) {
        var c = this;
        if (c.isFiltered() && c.hasNativeFilters()) {
            throw new Error("Can't hide nodes of the filtered tree store")
        }
        a = a || c;
        c.getRootNode().cascadeBy(function(e) {
            e.hidden = Boolean(b.call(a, e, c))
        });
        c.startDataChangeMonitoring();
        c.isHiddenFlag = true;
        c.lastTreeHiding = [b, a];
        if (!d) {
            c.refreshNodeStoreContent()
        }
    },
    showAllNodes: function(a) {
        this.getRootNode().cascadeBy(function(b) {
            b.hidden = false
        });
        this.isHiddenFlag = false;
        this.lastTreeHiding = null;
        if (!this.isTreeFiltered(true)) {
            this.stopDataChangeMonitoring()
        }
        if (!a) {
            this.refreshNodeStoreContent()
        }
    },
    inheritables: function() {
        return {
            onNodeExpand: function(c, b, a) {
                if (this.isTreeFiltered(true) && c == this.getRoot()) {
                    this.callParent(arguments);
                    this.reApplyFilter()
                } else {
                    return this.callParent(arguments)
                }
            },
            onNodeCollapse: function(f, a, h, g, i) {
                var e = this;
                var c = e.data;
                var j = c.contains;
                var b = e.isTreeFiltered();
                var d = e.currentFilterGeneration;
                c.contains = function() {
                    var n, m, p;
                    var l = e.indexOf(f) + 1;
                    var o = false;
                    for (var k = 0; k < a.length; k++) {
                        if (! (a[k].hidden || b && a[k].__filterGen != d) && j.call(this, a[k])) {
                            n = f;
                            while (n.parentNode) {
                                m = n;
                                do {
                                    m = m.nextSibling
                                } while ( m && ( m . hidden || b && m . __filterGen != d ));
                                if (m) {
                                    o = true;
                                    p = e.indexOf(m);
                                    break
                                } else {
                                    n = n.parentNode
                                }
                            }
                            if (!o) {
                                p = e.getCount()
                            }
                            e.removeAt(l, p - l);
                            break
                        }
                    }
                    return false
                };
                this.callParent(arguments);
                c.contains = j
            },
            handleNodeExpand: function(h, a, j) {
                var e = this;
                var f = [];
                var b = e.isTreeFiltered();
                var g = e.currentFilterGeneration;
                for (var c = 0; c < a.length; c++) {
                    var d = a[c];
                    if (! (b && d.__filterGen != g || d.hidden)) {
                        f[f.length] = d
                    }
                }
                return this.callParent([h, f, j])
            },
            onNodeInsert: function(m, a, g) {
                var i = this,
                h, n, j, b, k, f, c = a.raw || a.data,
                l, e, d;
                if (i.filterFn) {
                    e = i.filterFn(a);
                    a.set("visible", e);
                    if (e) {
                        m.set("visible", i.filterFn(m))
                    }
                }
                i.registerNode(a, true);
                i.beginUpdate();
                if (i.isVisible(a)) {
                    if (g === 0 || !a.previousSibling) {
                        h = m
                    } else {
                        for (n = a.previousSibling; n && !n.get("visible"); n = n.previousSibling) {}
                        if (!n) {
                            h = m
                        } else {
                            while (n.isExpanded() && n.lastChild) {
                                n = n.lastChild
                            }
                            h = n
                        }
                    }
                    i.insert(i.indexOf(h) + 1, a);
                    if (!a.isLeaf() && a.isExpanded()) {
                        if (a.isLoaded()) {
                            i.onNodeExpand(a, a.childNodes)
                        } else {
                            if (!i.fillCount) {
                                a.set("expanded", false);
                                a.expand()
                            }
                        }
                    }
                } else {
                    i.needsSync = i.needsSync || a.phantom || a.dirty
                }
                if (!a.isLeaf() && !a.isLoaded() && !i.lazyFill) {
                    j = i.getProxy().getReader();
                    b = a.getProxy();
                    k = b ? b.getReader() : null;
                    f = k && k.initialConfig.rootProperty ? k: j;
                    l = f.getRoot(c);
                    if (l) {
                        d = a.childType;
                        i.fillNode(a, f.extractData(l, d ? {
                            model: d
                        }: undefined))
                    }
                }
                i.endUpdate()
            },
            isFiltered: function() {
                return this.callParent(arguments) || this.isTreeFiltered()
            }
        }
    }
});
Ext.define("Sch.data.ResourceStore", {
    extend: "Ext.data.Store",
    model: "Sch.model.Resource",
    config: {
        model: "Sch.model.Resource"
    },
    alias: "store.resourcestore",
    storeId: "resources",
    mixins: ["Sch.data.mixin.ResourceStore"],
    constructor: function() {
        this.callParent(arguments);
        if (this.getModel() !== Sch.model.Resource && !(this.getModel().prototype instanceof Sch.model.Resource)) {
            throw "The model for the ResourceStore must subclass Sch.model.Resource"
        }
    }
});
Ext.define("Sch.data.TimeAxis", {
    extend: "Ext.data.JsonStore",
    requires: ["Sch.util.Date", "Sch.model.TimeAxisTick"],
    model: "Sch.model.TimeAxisTick",
    continuous: true,
    originalContinuous: null,
    autoAdjust: true,
    unit: null,
    increment: null,
    resolutionUnit: null,
    resolutionIncrement: null,
    weekStartDay: null,
    mainUnit: null,
    shiftUnit: null,
    shiftIncrement: 1,
    defaultSpan: 1,
    isConfigured: false,
    adjustedStart: null,
    adjustedEnd: null,
    visibleTickStart: null,
    visibleTickEnd: null,
    presetName: null,
    mode: "plain",
    constructor: function(a) {
        var c = this;
        if (c.setModel) {
            c.setModel(c.model)
        }
        c.originalContinuous = c.continuous;
        c.callParent(arguments);
        c.on(Ext.versions.touch ? "refresh": "datachanged",
        function(d) {
            c.fireEvent("reconfigure", c, false)
        });
        c.on("endreconfigure",
        function(d, e) {
            d.fireEvent("reconfigure", d, e)
        });
        if (a && a.viewPreset) {
            var b = Sch.preset.Manager.getPreset(a.viewPreset);
            b && c.consumeViewPreset(b)
        }
        if (a && (a.start || c.start)) {
            c.reconfigure(a)
        }
    },
    reconfigure: function(d, a) {
        this.isConfigured = true;
        Ext.apply(this, d);
        var k = this.getAdjustedDates(d.start, d.end, true);
        var j = this.getAdjustedDates(d.start, d.end);
        var b = j.start;
        var e = j.end;
        if (this.fireEvent("beforereconfigure", this, b, e) !== false) {
            this.fireEvent("beginreconfigure", this);
            var h = this.unit;
            var i = this.increment || 1;
            var g = this.generateTicks(b, e, h, i, this.mainUnit);
            this.removeAll(true);
            this.suspendEvents();
            this.add(g);
            if (this.getCount() === 0) {
                Ext.Error.raise("Invalid time axis configuration or filter, please check your input data.")
            }
            this.resumeEvents();
            var c = Sch.util.Date;
            var f = g.length;
            if (this.isContinuous()) {
                this.adjustedStart = k.start;
                this.adjustedEnd = this.getNext(f > 1 ? g[f - 1].start: k.start, h, i)
            } else {
                this.adjustedStart = this.getStart();
                this.adjustedEnd = this.getEnd()
            }
            do {
                this.visibleTickStart = (this.getStart() - this.adjustedStart) / (c.getUnitDurationInMs(h) * i);
                if (this.visibleTickStart >= 1) {
                    this.adjustedStart = c.getNext(this.adjustedStart, h, i)
                }
            } while ( this . visibleTickStart >= 1 );
            do {
                this.visibleTickEnd = f - (this.adjustedEnd - this.getEnd()) / (c.getUnitDurationInMs(h) * i);
                if (f - this.visibleTickEnd >= 1) {
                    this.adjustedEnd = c.getNext(this.adjustedEnd, h, -1)
                }
            } while ( f - this . visibleTickEnd >= 1 );
            this.fireEvent("endreconfigure", this, a)
        }
    },
    setTimeSpan: function(c, a) {
        var b = this.getAdjustedDates(c, a);
        c = b.start;
        a = b.end;
        if (this.getStart() - c !== 0 || this.getEnd() - a !== 0) {
            this.reconfigure({
                start: c,
                end: a
            })
        }
    },
    filterBy: function(b, a) {
        this.continuous = false;
        a = a || this;
        this.clearFilter(true);
        this.suspendEvents(true);
        this.filter([{
            filterFn: function(d, c) {
                return b.call(a, d.data, c)
            }
        }]);
        if (this.getCount() === 0) {
            this.clearFilter();
            this.resumeEvents();
            Ext.Error.raise("Invalid time axis filter - no ticks passed through the filter. Please check your filter method.")
        }
        this.resumeEvents()
    },
    isContinuous: function() {
        return this.continuous && !this.isFiltered()
    },
    clearFilter: function() {
        this.continuous = this.originalContinuous;
        this.callParent(arguments)
    },
    generateTicks: function(a, d, g, i) {
        var h = [],
        f,
        b = Sch.util.Date,
        e = 0;
        g = g || this.unit;
        i = i || this.increment;
        var j = this.getAdjustedDates(a, d);
        a = j.start;
        d = j.end;
        while (a < d) {
            f = this.getNext(a, g, i);
            if (!this.autoAdjust && f > d) {
                f = d
            }
            if (g === b.HOUR && i > 1 && h.length > 0 && e === 0) {
                var c = h[h.length - 1];
                e = ((c.start.getHours() + i) % 24) - c.end.getHours();
                if (e !== 0) {
                    f = b.add(f, b.HOUR, e)
                }
            }
            h.push({
                start: a,
                end: f
            });
            a = f
        }
        return h
    },
    getVisibleTickTimeSpan: function() {
        return this.isContinuous() ? this.visibleTickEnd - this.visibleTickStart: this.getCount()
    },
    getAdjustedDates: function(b, e, d) {
        var c = Sch.util.Date;
        b = b || this.getStart();
        e = e || c.add(b, this.mainUnit, this.defaultSpan);
        if (this.mode === "calendar") {
            if (this.shiftUnit === c.MONTH) {
                var g = c.add(b, c.WEEK, 1);
                var f = c.add(e, c.WEEK, -1);
                if (!e) {
                    e = this.getNext(b, this.shiftUnit, 1);
                    e = this.ceilDate(e, false, this.shiftUnit, 1);
                    e = this.ceilDate(e, false, this.mainUnit, 1)
                }
                if (g.getMonth() !== b.getMonth() && f.getMonth() !== e.getMonth()) {
                    return {
                        start: b,
                        end: e
                    }
                }
            }
            var i = this.floorDate(b, false, this.shiftUnit, 1);
            i = this.floorDate(i, false, this.mainUnit, 1);
            var h = this.getNext(b, this.shiftUnit, 1);
            var a = this.ceilDate(h, false, this.shiftUnit, 1);
            a = this.ceilDate(a, false, this.mainUnit, 1);
            return {
                start: i,
                end: a
            }
        } else {
            return this.autoAdjust || d ? {
                start: this.floorDate(b, false, this.autoAdjust ? this.mainUnit: this.unit, 1),
                end: this.ceilDate(e, false, this.autoAdjust ? this.mainUnit: this.unit, 1)
            }: {
                start: b,
                end: e
            }
        }
    },
    getTickFromDate: function(d) {
        var j = this.data.items;
        var h = j.length - 1;
        if (d < j[0].data.start || d > j[h].data.end) {
            return - 1
        }
        var f, g, b;
        if (this.isContinuous()) {
            if (d - j[0].data.start === 0) {
                return this.visibleTickStart
            }
            if (d - j[h].data.end === 0) {
                return this.visibleTickEnd
            }
            var k = this.adjustedStart;
            var a = this.adjustedEnd;
            var c = Math.floor(j.length * (d - k) / (a - k));
            if (c > h) {
                c = h
            }
            g = c === 0 ? k: j[c].data.start;
            b = c == h ? a: j[c].data.end;
            f = c + (d - g) / (b - g);
            if (f < this.visibleTickStart || f > this.visibleTickEnd) {
                return - 1
            }
            return f
        } else {
            for (var e = 0; e <= h; e++) {
                b = j[e].data.end;
                if (d <= b) {
                    g = j[e].data.start;
                    f = e + (d > g ? (d - g) / (b - g) : 0);
                    return f
                }
            }
        }
        return - 1
    },
    getDateFromTick: function(e, i) {
        if (e === this.visibleTickEnd) {
            return this.getEnd()
        }
        var b = Math.floor(e),
        g = e - b,
        h = this.getAt(b);
        if (!h) {
            return null
        }
        var f = h.data;
        var a = b === 0 ? this.adjustedStart: f.start;
        var d = (b == this.getCount() - 1) && this.isContinuous() ? this.adjustedEnd: f.end;
        var c = Sch.util.Date.add(a, Sch.util.Date.MILLI, g * (d - a));
        if (i) {
            c = this[i + "Date"](c)
        }
        return c
    },
    getTicks: function() {
        var a = [];
        this.each(function(b) {
            a.push(b.data)
        });
        return a
    },
    getStart: function() {
        var a = this.first();
        if (a) {
            return new Date(a.data.start)
        }
        return null
    },
    getEnd: function() {
        var a = this.last();
        if (a) {
            return new Date(a.data.end)
        }
        return null
    },
    floorDate: function(e, g, h, a) {
        g = g !== false;
        var c = Ext.Date.clone(e),
        d = g ? this.getStart() : null,
        l = a || this.resolutionIncrement,
        k;
        if (h) {
            k = h
        } else {
            k = g ? this.resolutionUnit: this.mainUnit
        }
        var b = Sch.util.Date;
        var f = function(n, m) {
            return Math.floor(n / m) * m
        };
        switch (k) {
        case b.MILLI:
            if (g) {
                c = b.add(d, b.MILLI, f(b.getDurationInMilliseconds(d, c), l))
            }
            break;
        case b.SECOND:
            if (g) {
                c = b.add(d, b.MILLI, f(b.getDurationInSeconds(d, c), l) * 1000)
            } else {
                c.setMilliseconds(0);
                c.setSeconds(f(c.getSeconds(), l))
            }
            break;
        case b.MINUTE:
            if (g) {
                c = b.add(d, b.SECOND, f(b.getDurationInMinutes(d, c), l) * 60)
            } else {
                c.setMinutes(f(c.getMinutes(), l));
                c.setSeconds(0);
                c.setMilliseconds(0)
            }
            break;
        case b.HOUR:
            if (g) {
                c = b.add(d, b.MINUTE, f(b.getDurationInHours(this.getStart(), c), l) * 60)
            } else {
                c.setMinutes(0);
                c.setSeconds(0);
                c.setMilliseconds(0);
                c.setHours(f(c.getHours(), l))
            }
            break;
        case b.DAY:
            if (g) {
                c = b.add(d, b.DAY, f(b.getDurationInDays(d, c), l))
            } else {
                Sch.util.Date.clearTime(c);
                c.setDate(f(c.getDate() - 1, l) + 1)
            }
            break;
        case b.WEEK:
            var j = c.getDay() || 7;
            var i = this.weekStartDay || 7;
            Sch.util.Date.clearTime(c);
            c = b.add(c, b.DAY, j >= i ? i - j: -(7 - i + j));
            if (c.getDay() !== i && c.getHours() === 23) {
                c = b.add(c, b.HOUR, 1)
            }
            break;
        case b.MONTH:
            if (g) {
                c = b.add(d, b.MONTH, f(b.getDurationInMonths(d, c), l))
            } else {
                Sch.util.Date.clearTime(c);
                c.setDate(1);
                c.setMonth(f(c.getMonth(), l))
            }
            break;
        case b.QUARTER:
            Sch.util.Date.clearTime(c);
            c.setDate(1);
            c = b.add(c, b.MONTH, -(c.getMonth() % 3));
            break;
        case b.YEAR:
            if (g) {
                c = b.add(d, b.YEAR, f(b.getDurationInYears(d, c), l))
            } else {
                c = new Date(f(e.getFullYear() - 1, l) + 1, 0, 1)
            }
            break
        }
        return c
    },
    roundDate: function(r, b) {
        var l = Ext.Date.clone(r),
        s = this.resolutionIncrement;
        b = b || this.getStart();
        switch (this.resolutionUnit) {
        case Sch.util.Date.MILLI:
            var e = Sch.util.Date.getDurationInMilliseconds(b, l),
            d = Math.round(e / s) * s;
            l = Sch.util.Date.add(b, Sch.util.Date.MILLI, d);
            break;
        case Sch.util.Date.SECOND:
            var i = Sch.util.Date.getDurationInSeconds(b, l),
            q = Math.round(i / s) * s;
            l = Sch.util.Date.add(b, Sch.util.Date.MILLI, q * 1000);
            break;
        case Sch.util.Date.MINUTE:
            var n = Sch.util.Date.getDurationInMinutes(b, l),
            a = Math.round(n / s) * s;
            l = Sch.util.Date.add(b, Sch.util.Date.SECOND, a * 60);
            break;
        case Sch.util.Date.HOUR:
            var m = Sch.util.Date.getDurationInHours(b, l),
            j = Math.round(m / s) * s;
            l = Sch.util.Date.add(b, Sch.util.Date.MINUTE, j * 60);
            break;
        case Sch.util.Date.DAY:
            var c = Sch.util.Date.getDurationInDays(b, l),
            f = Math.round(c / s) * s;
            l = Sch.util.Date.add(b, Sch.util.Date.DAY, f);
            break;
        case Sch.util.Date.WEEK:
            Sch.util.Date.clearTime(l);
            var o = l.getDay() - this.weekStartDay,
            t;
            if (o < 0) {
                o = 7 + o
            }
            if (Math.round(o / 7) === 1) {
                t = 7 - o
            } else {
                t = -o
            }
            l = Sch.util.Date.add(l, Sch.util.Date.DAY, t);
            break;
        case Sch.util.Date.MONTH:
            var p = Sch.util.Date.getDurationInMonths(b, l) + (l.getDate() / Ext.Date.getDaysInMonth(l)),
            h = Math.round(p / s) * s;
            l = Sch.util.Date.add(b, Sch.util.Date.MONTH, h);
            break;
        case Sch.util.Date.QUARTER:
            Sch.util.Date.clearTime(l);
            l.setDate(1);
            l = Sch.util.Date.add(l, Sch.util.Date.MONTH, 3 - (l.getMonth() % 3));
            break;
        case Sch.util.Date.YEAR:
            var k = Sch.util.Date.getDurationInYears(b, l),
            g = Math.round(k / s) * s;
            l = Sch.util.Date.add(b, Sch.util.Date.YEAR, g);
            break
        }
        return l
    },
    ceilDate: function(c, b, f) {
        var e = Ext.Date.clone(c);
        b = b !== false;
        var a = b ? this.resolutionIncrement: 1,
        g = false,
        d;
        if (f) {
            d = f
        } else {
            d = b ? this.resolutionUnit: this.mainUnit
        }
        switch (d) {
        case Sch.util.Date.HOUR:
            if (e.getMinutes() > 0 || e.getSeconds() > 0 || e.getMilliseconds() > 0) {
                g = true
            }
            break;
        case Sch.util.Date.DAY:
            if (e.getHours() > 0 || e.getMinutes() > 0 || e.getSeconds() > 0 || e.getMilliseconds() > 0) {
                g = true
            }
            break;
        case Sch.util.Date.WEEK:
            Sch.util.Date.clearTime(e);
            if (e.getDay() !== this.weekStartDay || c.getTime() - e.getTime() > 0) {
                g = true
            }
            break;
        case Sch.util.Date.MONTH:
            Sch.util.Date.clearTime(e);
            if (e.getDate() !== 1 || c.getTime() - e.getTime() > 0) {
                g = true
            }
            break;
        case Sch.util.Date.QUARTER:
            Sch.util.Date.clearTime(e);
            if (e.getMonth() % 3 !== 0 || e.getDate() !== 1 || c.getTime() - e.getTime() > 0) {
                g = true
            }
            break;
        case Sch.util.Date.YEAR:
            Sch.util.Date.clearTime(e);
            if (e.getMonth() !== 0 || e.getDate() !== 1 || c.getTime() - e.getTime() > 0) {
                g = true
            }
            break;
        default:
            break
        }
        if (g) {
            return this.getNext(e, d, a)
        } else {
            return e
        }
    },
    getNext: function(b, c, a) {
        return Sch.util.Date.getNext(b, c, a, this.weekStartDay)
    },
    getResolution: function() {
        return {
            unit: this.resolutionUnit,
            increment: this.resolutionIncrement
        }
    },
    setResolution: function(b, a) {
        this.resolutionUnit = b;
        this.resolutionIncrement = a || 1
    },
    shift: function(a, b) {
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), b, a), Sch.util.Date.add(this.getEnd(), b, a))
    },
    shiftNext: function(a) {
        a = a || this.getShiftIncrement();
        var b = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), b, a), Sch.util.Date.add(this.getEnd(), b, a))
    },
    shiftPrevious: function(a) {
        a = -(a || this.getShiftIncrement());
        var b = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), b, a), Sch.util.Date.add(this.getEnd(), b, a))
    },
    getShiftUnit: function() {
        return this.shiftUnit || this.mainUnit
    },
    getShiftIncrement: function() {
        return this.shiftIncrement || 1
    },
    getUnit: function() {
        return this.unit
    },
    getIncrement: function() {
        return this.increment
    },
    dateInAxis: function(a) {
        return Sch.util.Date.betweenLesser(a, this.getStart(), this.getEnd())
    },
    timeSpanInAxis: function(b, a) {
        if (this.isContinuous()) {
            return Sch.util.Date.intersectSpans(b, a, this.getStart(), this.getEnd())
        } else {
            return (b < this.getStart() && a > this.getEnd()) || this.getTickFromDate(b) !== this.getTickFromDate(a)
        }
    },
    forEachAuxInterval: function(h, b, a, f) {
        f = f || this;
        var c = this.getEnd(),
        g = this.getStart(),
        e = 0,
        d;
        if (g > c) {
            throw "Invalid time axis configuration"
        }
        while (g < c) {
            d = Sch.util.Date.min(this.getNext(g, h, b || 1), c);
            a.call(f, g, d, e);
            g = d;
            e++
        }
    },
    consumeViewPreset: function(a) {
        Ext.apply(this, {
            unit: a.getBottomHeader().unit,
            increment: a.getBottomHeader().increment || 1,
            resolutionUnit: a.timeResolution.unit,
            resolutionIncrement: a.timeResolution.increment,
            mainUnit: a.getMainHeader().unit,
            shiftUnit: a.shiftUnit,
            shiftIncrement: a.shiftIncrement || 1,
            defaultSpan: a.defaultSpan || 1,
            presetName: a.name,
            headerConfig: a.headerConfig
        })
    }
});
Ext.define("Sch.preset.ViewPreset", {
    name: null,
    rowHeight: null,
    timeColumnWidth: 50,
    timeRowHeight: null,
    timeAxisColumnWidth: null,
    displayDateFormat: "G:i",
    shiftUnit: "HOUR",
    shiftIncrement: 1,
    defaultSpan: 12,
    timeResolution: null,
    headerConfig: null,
    columnLinesFor: "middle",
    headers: null,
    mainHeader: 0,
    constructor: function(a) {
        Ext.apply(this, a)
    },
    getHeaders: function() {
        if (this.headers) {
            return this.headers
        }
        var a = this.headerConfig;
        this.mainHeader = a.top ? 1 : 0;
        return this.headers = [].concat(a.top || [], a.middle || [], a.bottom || [])
    },
    getMainHeader: function() {
        return this.getHeaders()[this.mainHeader]
    },
    getBottomHeader: function() {
        var a = this.getHeaders();
        return a[a.length - 1]
    },
    clone: function() {
        var a = {};
        var b = this;
        Ext.each(["rowHeight", "timeColumnWidth", "timeRowHeight", "timeAxisColumnWidth", "displayDateFormat", "shiftUnit", "shiftIncrement", "defaultSpan", "timeResolution", "headerConfig"],
        function(c) {
            a[c] = b[c]
        });
        return new this.self(Ext.clone(a))
    }
});
Ext.define("Sch.preset.Manager", {
    extend: "Ext.util.MixedCollection",
    requires: ["Sch.util.Date", "Sch.preset.ViewPreset"],
    mixins: ["Sch.mixin.Localizable"],
    singleton: true,
    defaultPresets: {
        secondAndMinute: {
            timeColumnWidth: 30,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "G:i:s",
            shiftIncrement: 10,
            shiftUnit: "MINUTE",
            defaultSpan: 24,
            timeResolution: {
                unit: "SECOND",
                increment: 5
            },
            headerConfig: {
                middle: {
                    unit: "SECOND",
                    increment: 10,
                    align: "center",
                    dateFormat: "s"
                },
                top: {
                    unit: "MINUTE",
                    align: "center",
                    dateFormat: "D, d g:iA"
                }
            }
        },
        minuteAndHour: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "G:i",
            shiftIncrement: 1,
            shiftUnit: "HOUR",
            defaultSpan: 24,
            timeResolution: {
                unit: "MINUTE",
                increment: 30
            },
            headerConfig: {
                middle: {
                    unit: "MINUTE",
                    increment: "30",
                    align: "center",
                    dateFormat: "i"
                },
                top: {
                    unit: "HOUR",
                    align: "center",
                    dateFormat: "D, gA/d"
                }
            }
        },
        hourAndDay: {
            timeColumnWidth: 60,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "G:i",
            shiftIncrement: 1,
            shiftUnit: "DAY",
            defaultSpan: 24,
            timeResolution: {
                unit: "MINUTE",
                increment: 30
            },
            headerConfig: {
                middle: {
                    unit: "HOUR",
                    align: "center",
                    dateFormat: "G:i"
                },
                top: {
                    unit: "DAY",
                    align: "center",
                    dateFormat: "D d/m"
                }
            }
        },
        dayAndWeek: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d G:i",
            shiftUnit: "DAY",
            shiftIncrement: 1,
            defaultSpan: 5,
            timeResolution: {
                unit: "HOUR",
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: "DAY",
                    align: "center",
                    dateFormat: "D d M"
                },
                top: {
                    unit: "WEEK",
                    align: "center",
                    renderer: function(c, b, a) {
                        return Sch.util.Date.getShortNameOfUnit("WEEK") + "." + Ext.Date.format(c, "W M Y")
                    }
                }
            }
        },
        weekAndDay: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "WEEK",
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {
                unit: "DAY",
                increment: 1
            },
            headerConfig: {
                bottom: {
                    unit: "DAY",
                    align: "center",
                    increment: 1,
                    dateFormat: "d/m"
                },
                middle: {
                    unit: "WEEK",
                    dateFormat: "D d M"
                }
            }
        },
        weekAndMonth: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "WEEK",
            shiftIncrement: 5,
            defaultSpan: 6,
            timeResolution: {
                unit: "DAY",
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: "WEEK",
                    renderer: function(c, b, a) {
                        return Ext.Date.format(c, "d M")
                    }
                },
                top: {
                    unit: "MONTH",
                    align: "center",
                    dateFormat: "M Y"
                }
            }
        },
        monthAndYear: {
            timeColumnWidth: 110,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftIncrement: 3,
            shiftUnit: "MONTH",
            defaultSpan: 12,
            timeResolution: {
                unit: "DAY",
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: "MONTH",
                    align: "center",
                    dateFormat: "M Y"
                },
                top: {
                    unit: "YEAR",
                    align: "center",
                    dateFormat: "Y"
                }
            }
        },
        year: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "YEAR",
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {
                unit: "MONTH",
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: "QUARTER",
                    align: "center",
                    renderer: function(c, b, a) {
                        return Ext.String.format(Sch.util.Date.getShortNameOfUnit("QUARTER").toUpperCase() + "{0}", Math.floor(c.getMonth() / 3) + 1)
                    }
                },
                top: {
                    unit: "YEAR",
                    align: "center",
                    dateFormat: "Y"
                }
            }
        },
        manyYears: {
            timeColumnWidth: 50,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "YEAR",
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {
                unit: "YEAR",
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: "YEAR",
                    align: "center",
                    dateFormat: "Y",
                    increment: 5
                },
                bottom: {
                    unit: "YEAR",
                    align: "center",
                    increment: 1,
                    renderer: Ext.emptyFn
                }
            }
        },
        weekAndDayLetter: {
            timeColumnWidth: 20,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "WEEK",
            shiftIncrement: 1,
            defaultSpan: 10,
            timeResolution: {
                unit: "DAY",
                increment: 1
            },
            headerConfig: {
                bottom: {
                    unit: "DAY",
                    align: "center",
                    renderer: function(a) {
                        return Ext.Date.dayNames[a.getDay()].substring(0, 1)
                    }
                },
                middle: {
                    unit: "WEEK",
                    dateFormat: "D d M Y"
                }
            }
        },
        weekDateAndMonth: {
            timeColumnWidth: 30,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "WEEK",
            shiftIncrement: 1,
            defaultSpan: 10,
            timeResolution: {
                unit: "DAY",
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: "WEEK",
                    align: "center",
                    dateFormat: "d"
                },
                top: {
                    unit: "MONTH",
                    dateFormat: "Y F"
                }
            }
        },
        day: {
            timeRowHeight: 40,
            calendarColumnWidth: 200,
            displayDateFormat: "G:i",
            shiftIncrement: 1,
            shiftUnit: "DAY",
            defaultSpan: 24,
            timeResolution: {
                unit: "MINUTE",
                increment: 30
            },
            headerConfig: {
                bottom: {
                    unit: "HOUR",
                    align: "center",
                    renderer: function(a) {
                        return Ext.String.format('<div class="sch-calendarcolumn-ct"><span class="sch-calendarcolumn-hours">{0}</span><span class="sch-calendarcolumn-minutes">{1}</span></div>', Ext.Date.format(a, "H"), Ext.Date.format(a, "i"))
                    }
                },
                middle: {
                    unit: "DAY",
                    align: "center",
                    dateFormat: "D d/m",
                    splitUnit: "DAY"
                }
            }
        },
        week: {
            timeRowHeight: 40,
            calendarColumnWidth: 164,
            displayDateFormat: "G:i",
            shiftIncrement: 1,
            shiftUnit: "WEEK",
            defaultSpan: 24,
            timeResolution: {
                unit: "MINUTE",
                increment: 30
            },
            headerConfig: {
                bottom: {
                    unit: "HOUR",
                    align: "center",
                    dateFormat: "H:i",
                    renderer: function(a) {
                        return Ext.String.format('<div class="sch-calendarcolumn-ct"><span class="sch-calendarcolumn-hours">{0}</span><span class="sch-calendarcolumn-minutes">{1}</span></div>', Ext.Date.format(a, "H"), Ext.Date.format(a, "i"))
                    }
                },
                middle: {
                    unit: "WEEK",
                    align: "center",
                    dateFormat: "D d",
                    splitUnit: "DAY"
                }
            }
        },
        month: {
            timeColumnWidth: 60,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "G:i",
            shiftIncrement: 1,
            shiftUnit: "MONTH",
            defaultSpan: 4,
            timeResolution: {
                unit: "HOUR",
                increment: 12
            },
            headerConfig: {
                bottom: {
                    unit: "DAY",
                    align: "center",
                    dateFormat: "D",
                    splitUnit: "WEEK"
                },
                middle: {
                    unit: "WEEK",
                    align: "center",
                    dateFormat: "D d/m"
                },
                top: {
                    unit: "MONTH",
                    align: "center",
                    renderer: function(c, b, a) {
                        return Ext.Date.format(c, "d/m") + " - " + Ext.Date.format(b, "d/m, Y")
                    },
                    splitUnit: "WEEK"
                }
            }
        }
    },
    constructor: function() {
        this.callParent(arguments);
        this.registerDefaults()
    },
    onLocalized: function() {
        var a = this;
        this.eachKey(function(c, d) {
            if (a.l10n[c]) {
                var b = a.L(c);
                b.displayDateFormat && (d.displayDateFormat = b.displayDateFormat);
                b.middleDateFormat && (d.headerConfig.middle.dateFormat = b.middleDateFormat);
                b.topDateFormat && (d.headerConfig.top.dateFormat = b.topDateFormat);
                b.bottomDateFormat && (d.headerConfig.bottom.dateFormat = b.bottomDateFormat)
            }
        })
    },
    registerPreset: function(b, a) {
        if (a) {
            var c = a.headerConfig;
            var f = Sch.util.Date;
            for (var g in c) {
                if (c.hasOwnProperty(g)) {
                    if (f[c[g].unit]) {
                        c[g].unit = f[c[g].unit.toUpperCase()]
                    }
                    if (f[c[g].splitUnit]) {
                        c[g].splitUnit = f[c[g].splitUnit.toUpperCase()]
                    }
                }
            }
            if (!a.timeColumnWidth) {
                a.timeColumnWidth = 50
            }
            if (!a.rowHeight) {
                a.rowHeight = 24
            }
            var d = a.timeResolution;
            if (d && f[d.unit]) {
                d.unit = f[d.unit.toUpperCase()]
            }
            var e = a.shiftUnit;
            if (e && f[e]) {
                a.shiftUnit = f[e.toUpperCase()]
            }
        }
        if (this.isValidPreset(a)) {
            if (this.containsKey(b)) {
                this.removeAtKey(b)
            }
            a.name = b;
            this.add(b, new Sch.preset.ViewPreset(a))
        } else {
            throw "Invalid preset, please check your configuration"
        }
    },
    isValidPreset: function(a) {
        var e = Sch.util.Date,
        c = true,
        d = Sch.util.Date.units,
        b = {};
        for (var f in a.headerConfig) {
            if (a.headerConfig.hasOwnProperty(f)) {
                b[f] = true;
                c = c && Ext.Array.indexOf(d, a.headerConfig[f].unit) >= 0
            }
        }
        if (! (a.columnLinesFor in b)) {
            a.columnLinesFor = "middle"
        }
        if (a.timeResolution) {
            c = c && Ext.Array.indexOf(d, a.timeResolution.unit) >= 0
        }
        if (a.shiftUnit) {
            c = c && Ext.Array.indexOf(d, a.shiftUnit) >= 0
        }
        return c
    },
    getPreset: function(a) {
        return this.get(a)
    },
    deletePreset: function(a) {
        this.removeAtKey(a)
    },
    registerDefaults: function() {
        var b = this,
        a = this.defaultPresets;
        for (var c in a) {
            b.registerPreset(c, a[c])
        }
    }
});
if (!Ext.ClassManager.get("Sch.feature.AbstractTimeSpan")) {
    Ext.define("Sch.feature.AbstractTimeSpan", {
        extend: "Ext.AbstractPlugin",
        mixins: {
            observable: "Ext.util.Observable"
        },
        lockableScope: "top",
        schedulerView: null,
        timeAxis: null,
        containerEl: null,
        expandToFitView: false,
        disabled: false,
        cls: null,
        clsField: "Cls",
        template: null,
        store: null,
        renderElementsBuffered: false,
        renderDelay: 15,
        refreshSizeOnItemUpdate: true,
        _resizeTimer: null,
        _renderTimer: null,
        showHeaderElements: false,
        headerTemplate: null,
        innerHeaderTpl: null,
        headerContainerCls: "sch-header-secondary-canvas",
        headerContainerEl: null,
        renderingDoneEvent: null,
        constructor: function(a) {
            this.uniqueCls = this.uniqueCls || ("sch-timespangroup-" + Ext.id());
            Ext.apply(this, a);
            this.mixins.observable.constructor.call(this);
            this.callParent(arguments)
        },
        setDisabled: function(a) {
            if (a) {
                this.removeElements()
            }
            this.disabled = a
        },
        removeElements: function() {
            this.removeBodyElements();
            if (this.showHeaderElements) {
                this.removeHeaderElements()
            }
        },
        getBodyElements: function() {
            if (this.containerEl) {
                return this.containerEl.select("." + this.uniqueCls)
            }
            return null
        },
        getHeaderContainerEl: function() {
            var c = this.headerContainerEl,
            b = Ext.baseCSSPrefix,
            a;
            if (!c || !c.dom) {
                if (this.schedulerView.isHorizontal()) {
                    a = this.panel.getHorizontalTimeAxisColumn().headerView.containerEl
                } else {
                    a = this.panel.el.down("." + b + "grid-inner-locked ." + b + "panel-body ." + b + "grid-view")
                }
                if (a) {
                    c = a.down("." + this.headerContainerCls);
                    if (!c) {
                        c = a.appendChild({
                            cls: this.headerContainerCls
                        })
                    }
                    this.headerContainerEl = c
                }
            }
            return c
        },
        getHeaderElements: function() {
            var a = this.getHeaderContainerEl();
            if (a) {
                return a.select("." + this.uniqueCls)
            }
            return null
        },
        removeBodyElements: function() {
            var a = this.getBodyElements();
            if (a) {
                a.each(function(b) {
                    b.destroy()
                })
            }
        },
        removeHeaderElements: function() {
            var a = this.getHeaderElements();
            if (a) {
                a.each(function(b) {
                    b.destroy()
                })
            }
        },
        getElementId: function(a) {
            return this.uniqueCls + "-" + a.internalId
        },
        getHeaderElementId: function(a) {
            return this.uniqueCls + "-header-" + a.internalId
        },
        getTemplateData: function(a) {
            return this.prepareTemplateData ? this.prepareTemplateData(a) : a.data
        },
        getElementCls: function(a, c) {
            var b = a.clsField || this.clsField;
            if (!c) {
                c = this.getTemplateData(a)
            }
            return this.cls + " " + this.uniqueCls + " " + (c[b] || "")
        },
        getHeaderElementCls: function(a, c) {
            var b = a.clsField || this.clsField;
            if (!c) {
                c = this.getTemplateData(a)
            }
            return "sch-header-indicator " + this.uniqueCls + " " + (c[b] || "")
        },
        init: function(a) {
            if (Ext.versions.touch && !a.isReady()) {
                a.on("viewready",
                function() {
                    this.init(a)
                },
                this);
                return
            }
            if (Ext.isString(this.innerHeaderTpl)) {
                this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl)
            }
            var b = this.innerHeaderTpl;
            if (!this.headerTemplate) {
                this.headerTemplate = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" class="{cls}" style="{side}:{position}px;">' + (b ? "{[this.renderInner(values)]}": "") + "</div>", "</tpl>", {
                    renderInner: function(c) {
                        return b.apply(c)
                    }
                })
            }
            this.schedulerView = a.getSchedulingView();
            this.panel = a;
            this.timeAxis = a.getTimeAxis();
            this.store = Ext.StoreManager.lookup(this.store);
            if (!this.store) {
                Ext.Error.raise("Error: You must define a store for this plugin")
            }
            if (!this.schedulerView.getEl()) {
                this.schedulerView.on({
                    afterrender: this.onAfterRender,
                    scope: this
                })
            } else {
                this.onAfterRender()
            }
        },
        onAfterRender: function(c) {
            var a = this.schedulerView;
            this.containerEl = a.getSecondaryCanvasEl();
            this.storeListeners = {
                load: this.renderElements,
                datachanged: this.renderElements,
                clear: this.renderElements,
                add: this.refreshSingle,
                remove: this.renderElements,
                update: this.refreshSingle,
                addrecords: this.refreshSingle,
                removerecords: this.renderElements,
                updaterecord: this.refreshSingle,
                expand: this.renderElements,
                collapse: this.renderElements,
                scope: this
            };
            this.store.on(this.storeListeners);
            a.on({
                bufferedrefresh: this.renderElements,
                refresh: this.renderElements,
                itemadd: this.refreshSizeOnItemUpdate ? this.refreshSizes: this.renderElements,
                itemremove: this.refreshSizeOnItemUpdate ? this.refreshSizes: this.renderElements,
                itemupdate: this.refreshSizeOnItemUpdate ? this.refreshSizes: this.renderElements,
                groupexpand: this.renderElements,
                groupcollapse: this.renderElements,
                columnwidthchange: this.renderElements,
                resize: this.renderElements,
                scope: this
            });
            if (a.headerCt) {
                a.headerCt.on({
                    add: this.renderElements,
                    remove: this.renderElements,
                    scope: this
                })
            }
            this.panel.on({
                viewchange: this.renderElements,
                show: this.refreshSizes,
                modechange: this.forceNewRenderingTimeout,
                scope: this
            });
            var b = a.getRowContainerEl();
            if (b && b.down(".sch-timetd")) {
                this.renderElements()
            }
        },
        forceNewRenderingTimeout: function() {
            this.renderElementsBuffered = false;
            clearTimeout(this._renderTimer);
            clearTimeout(this._resizeTimer);
            this.renderElements()
        },
        refreshSizesInternal: function() {
            if (!this.schedulerView.isDestroyed && this.schedulerView.isHorizontal()) {
                var a = this.schedulerView.getTimeSpanRegion(new Date(), null, this.expandToFitView);
                this.getBodyElements().setHeight(a.bottom - a.top)
            }
        },
        refreshSizes: function() {
            clearTimeout(this._resizeTimer);
            this._resizeTimer = Ext.Function.defer(this.refreshSizesInternal, this.renderDelay, this)
        },
        renderElements: function() {
            if (this.renderElementsBuffered || this.disabled) {
                return
            }
            this.renderElementsBuffered = true;
            clearTimeout(this._renderTimer);
            this._renderTimer = Ext.Function.defer(this.renderElementsInternal, this.renderDelay, this)
        },
        setElementX: function(b, a) {
            if (this.panel.rtl) {
                b.setRight(a)
            } else {
                b.setLeft(a)
            }
        },
        getHeaderElementPosition: function(b) {
            var a = this.schedulerView.getTimeAxisViewModel();
            return Math.round(a.getPositionFromDate(b))
        },
        renderBodyElementsInternal: function(a) {
            Ext.DomHelper.append(this.containerEl, this.generateMarkup(false, a))
        },
        getHeaderElementData: function(a, b) {
            throw "Abstract method call"
        },
        renderHeaderElementsInternal: function(a) {
            var b = this.getHeaderContainerEl();
            if (b) {
                Ext.DomHelper.append(b, this.generateHeaderMarkup(false, a))
            }
        },
        renderElementsInternal: function() {
            this.renderElementsBuffered = false;
            if (this.disabled || this.schedulerView.isDestroyed) {
                return
            }
            if (Ext.versions.extjs && !this.schedulerView.el.down("." + Ext.baseCSSPrefix + "grid-item-container")) {
                return
            }
            this.removeElements();
            this.renderBodyElementsInternal();
            if (this.showHeaderElements) {
                this.headerContainerEl = null;
                this.renderHeaderElementsInternal()
            }
            if (this.renderingDoneEvent) {
                this.fireEvent(this.renderingDoneEvent, this)
            }
        },
        generateMarkup: function(c, b) {
            var e = this.timeAxis.getStart(),
            a = this.timeAxis.getEnd(),
            d = this.getElementData(e, a, b, c);
            return this.template.apply(d)
        },
        generateHeaderMarkup: function(b, a) {
            var c = this.getHeaderElementData(a, b);
            return this.headerTemplate.apply(c)
        },
        getElementData: function(d, c, a, b) {
            throw "Abstract method call"
        },
        updateBodyElement: function(b) {
            var c = Ext.get(this.getElementId(b));
            if (c) {
                var e = this.timeAxis.getStart(),
                a = this.timeAxis.getEnd(),
                d = this.getElementData(e, a, [b])[0];
                if (d) {
                    c.dom.className = d.$cls;
                    c.setTop(d.top);
                    this.setElementX(c, d.left);
                    c.setSize(d.width, d.height)
                } else {
                    Ext.destroy(c)
                }
            } else {
                this.renderBodyElementsInternal([b])
            }
        },
        updateHeaderElement: function(a) {
            var b = Ext.get(this.getHeaderElementId(a));
            if (b) {
                var c = this.getHeaderElementData([a])[0];
                if (c) {
                    b.dom.className = c.cls;
                    if (this.schedulerView.isHorizontal()) {
                        this.setElementX(b, c.position);
                        b.setWidth(c.size)
                    } else {
                        b.setTop(c.position);
                        b.setHeight(c.size)
                    }
                } else {
                    Ext.destroy(b)
                }
            } else {
                this.renderHeaderElementsInternal([a])
            }
        },
        destroy: function() {
            clearTimeout(this._renderTimer);
            clearTimeout(this._resizeTimer);
            if (this.store.autoDestroy) {
                this.store.destroy()
            }
            this.store.un(this.storeListeners)
        },
        refreshSingle: function(b, a) {
            Ext.each(a, this.updateBodyElement, this);
            if (this.showHeaderElements) {
                Ext.each(a, this.updateHeaderElement, this)
            }
        }
    })
}
Ext.define("Sch.plugin.Lines", {
    extend: "Sch.feature.AbstractTimeSpan",
    alias: "plugin.scheduler_lines",
    cls: "sch-timeline",
    showTip: true,
    innerTpl: null,
    prepareTemplateData: null,
    side: null,
    init: function(a) {
        if (Ext.isString(this.innerTpl)) {
            this.innerTpl = new Ext.XTemplate(this.innerTpl)
        }
        this.side = a.rtl ? "right": "left";
        var b = this.innerTpl;
        if (!this.template) {
            this.template = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" ' + (this.showTip ? 'title="{[this.getTipText(values)]}" ': "") + 'class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px">' + (b ? "{[this.renderInner(values)]}": "") + "</div>", "</tpl>", {
                getTipText: function(c) {
                    return a.getSchedulingView().getFormattedDate(c.Date) + " " + (c.Text || "")
                },
                renderInner: function(c) {
                    return b.apply(c)
                }
            })
        }
        this.callParent(arguments)
    },
    getElementData: function(m, q, c) {
        var t = this.store,
        j = this.schedulerView,
        p = j.isHorizontal(),
        f = c || t.getRange(),
        h = [],
        r,
        a,
        o = j.getTimeSpanRegion(m, null, this.expandToFitView),
        k,
        b,
        e;
        if (Ext.versions.touch) {
            r = "100%"
        } else {
            r = p ? o.bottom - o.top: 1
        }
        a = p ? 1 : o.right - o.left;
        for (var g = 0,
        d = f.length; g < d; g++) {
            k = f[g];
            b = k.get("Date");
            if (b && Sch.util.Date.betweenLesser(b, m, q)) {
                var n = j.getCoordinateFromDate(b);
                e = Ext.apply({},
                this.getTemplateData(k));
                e.id = this.getElementId(k);
                e.$cls = this.getElementCls(k, e);
                e.width = a;
                e.height = r;
                if (p) {
                    e.left = n
                } else {
                    e.top = n
                }
                h.push(e)
            }
        }
        return h
    },
    getHeaderElementData: function(c) {
        var a = this.timeAxis.getStart(),
        k = this.timeAxis.getEnd(),
        m = this.schedulerView.isHorizontal(),
        g = [],
        h,
        b,
        j,
        e;
        c = c || this.store.getRange();
        for (var f = 0,
        d = c.length; f < d; f++) {
            h = c[f];
            b = h.get("Date");
            if (b && Sch.util.Date.betweenLesser(b, a, k)) {
                j = this.getHeaderElementPosition(b);
                e = this.getTemplateData(h);
                e = Ext.apply({
                    side: m ? this.side: "top",
                    cls: this.getHeaderElementCls(h, e),
                    position: j
                },
                e);
                e.id = this.getHeaderElementId(h);
                g.push(e)
            }
        }
        return g
    }
});
Ext.define("Sch.plugin.Zones", {
    extend: "Sch.feature.AbstractTimeSpan",
    alias: "plugin.scheduler_zones",
    requires: ["Sch.model.Range"],
    innerTpl: null,
    cls: "sch-zone",
    side: null,
    init: function(a) {
        if (Ext.isString(this.innerTpl)) {
            this.innerTpl = new Ext.XTemplate(this.innerTpl)
        }
        this.side = a.rtl ? "right": "left";
        var b = this.innerTpl;
        if (!this.template) {
            this.template = new Ext.XTemplate('<tpl for="."><div id="{id}" class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px;{style}">' + (b ? "{[this.renderInner(values)]}": "") + "</div></tpl>", {
                renderInner: function(c) {
                    return b.apply(c)
                }
            })
        }
        if (Ext.isString(this.innerHeaderTpl)) {
            this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl)
        }
        this.callParent(arguments)
    },
    getElementData: function(h, d, r, f) {
        var g = this.schedulerView,
        t = [];
        var c = g.getTimeSpanRegion(h, d, this.expandToFitView);
        var b, k, a, j, n, e;
        r = r || this.store.getRange();
        for (var q = 0,
        p = r.length; q < p; q++) {
            b = r[q];
            k = b.getStartDate();
            a = b.getEndDate();
            e = this.getTemplateData(b);
            if (k && a && Sch.util.Date.intersectSpans(k, a, h, d)) {
                j = Ext.apply({},
                e);
                j.id = this.getElementId(b);
                j.$cls = this.getElementCls(b, e);
                var m = g.getMode();
                if (m === "calendar") {
                    var s = g.getTimeSpanRegion(k, a);
                    j.left = s.left;
                    j.top = s.top;
                    j.height = s.bottom - s.top;
                    j.width = s.right - s.left
                } else {
                    var u = g.getCoordinateFromDate(Sch.util.Date.max(k, h));
                    var o = g.getCoordinateFromDate(Sch.util.Date.min(a, d));
                    if (m === "horizontal") {
                        j.left = u;
                        j.top = c.top;
                        j.width = f ? 0 : o - u;
                        j.height = c.bottom - c.top;
                        j.style = f ? ("border-left-width:" + (o - u) + "px") : ""
                    } else {
                        j.left = c.left;
                        j.top = u;
                        j.height = f ? 0 : o - u;
                        j.width = c.right - c.left;
                        j.style = f ? ("border-top-width:" + (o - u) + "px") : ""
                    }
                }
                t.push(j)
            }
        }
        return t
    },
    getHeaderElementId: function(b, a) {
        return this.callParent([b]) + (a ? "-start": "-end")
    },
    getHeaderElementCls: function(b, d, a) {
        var c = b.clsField || this.clsField;
        if (!d) {
            d = this.getTemplateData(b)
        }
        return "sch-header-indicator sch-header-indicator-" + (a ? "start ": "end ") + this.uniqueCls + " " + (d[c] || "")
    },
    getZoneHeaderElementData: function(b, h, f, a) {
        var c = a ? f.getStartDate() : f.getEndDate(),
        e = null,
        g,
        i,
        d;
        if (c && Sch.util.Date.betweenLesser(c, b, h)) {
            g = this.getHeaderElementPosition(c);
            i = this.schedulerView.isHorizontal();
            d = this.getTemplateData(f);
            e = Ext.apply({
                id: this.getHeaderElementId(f, a),
                cls: this.getHeaderElementCls(f, d, a),
                isStart: a,
                side: i ? this.side: "top",
                position: g
            },
            d)
        }
        return e
    },
    getHeaderElementData: function(b) {
        var a = this.timeAxis.getStart(),
        h = this.timeAxis.getEnd(),
        e = [],
        g,
        d,
        j;
        b = b || this.store.getRange();
        for (var f = 0,
        c = b.length; f < c; f++) {
            g = b[f];
            d = this.getZoneHeaderElementData(a, h, g, true);
            if (d) {
                e.push(d)
            }
            j = this.getZoneHeaderElementData(a, h, g, false);
            if (j) {
                e.push(j)
            }
        }
        return e
    },
    updateZoneHeaderElement: function(a, b) {
        a.dom.className = b.cls;
        if (this.schedulerView.isHorizontal()) {
            this.setElementX(a, b.position)
        } else {
            a.setTop(b.position)
        }
    },
    updateHeaderElement: function(c) {
        var a = this.timeAxis.getStart(),
        g = this.timeAxis.getEnd(),
        f = Ext.get(this.getHeaderElementId(c, true)),
        e = Ext.get(this.getHeaderElementId(c, false)),
        d = this.getZoneHeaderElementData(a, g, c, true),
        b = this.getZoneHeaderElementData(a, g, c, false);
        if (! (f && b) || !(e && b)) {
            Ext.destroy(f, e);
            this.renderHeaderElementsInternal([c])
        } else {
            if (f) {
                if (!d) {
                    Ext.destroy(f)
                } else {
                    this.updateZoneHeaderElement(f, d)
                }
            }
            if (e) {
                if (!b) {
                    Ext.destroy(e)
                } else {
                    this.updateZoneHeaderElement(e, b)
                }
            }
        }
    }
});
Ext.define("Sch.plugin.Pan", {
    extend: "Ext.AbstractPlugin",
    alias: "plugin.scheduler_pan",
    lockableScope: "top",
    enableVerticalPan: true,
    statics: {
        KEY_SHIFT: 1,
        KEY_CTRL: 2,
        KEY_ALT: 4,
        KEY_ALL: 7
    },
    disableOnKey: 0,
    constructor: function(a) {
        Ext.apply(this, a)
    },
    init: function(a) {
        if (Ext.supports.Touch) {
            return
        }
        this.view = a.getSchedulingView();
        this.view.on("afterrender", this.onRender, this)
    },
    onRender: function(a) {
        this.view.el.on("mousedown", this.onMouseDown, this)
    },
    onMouseDown: function(d, c) {
        var b = this.self,
        a = this.disableOnKey;
        if ((d.shiftKey && (a & b.KEY_SHIFT)) || (d.ctrlKey && (a & b.KEY_CTRL)) || (d.altKey && (a & b.KEY_ALT))) {
            return
        }
        if (d.getTarget("." + this.view.timeCellCls, 10) && !d.getTarget(this.view.eventSelector)) {
            this.mouseX = d.getX();
            this.mouseY = d.getY();
            Ext.getBody().on("mousemove", this.onMouseMove, this);
            Ext.getDoc().on("mouseup", this.onMouseUp, this);
            if (Ext.isIE || Ext.isGecko) {
                Ext.getBody().on("mouseenter", this.onMouseUp, this)
            }
            d.stopEvent()
        }
    },
    onMouseMove: function(d) {
        d.stopEvent();
        var a = d.getX();
        var f = d.getY();
        var b = 0,
        c = this.mouseX - a;
        if (this.enableVerticalPan) {
            b = this.mouseY - f
        }
        this.mouseX = a;
        this.mouseY = f;
        this.view.scrollBy(c, b, false)
    },
    onMouseUp: function(a) {
        Ext.getBody().un("mousemove", this.onMouseMove, this);
        Ext.getDoc().un("mouseup", this.onMouseUp, this);
        if (Ext.isIE || Ext.isGecko) {
            Ext.getBody().un("mouseenter", this.onMouseUp, this)
        }
    }
});
Ext.define("Sch.tooltip.ClockTemplate", {
    extend: "Ext.XTemplate",
    minuteHeight: 8,
    minuteTop: 2,
    hourHeight: 8,
    hourTop: 2,
    handLeft: 10,
    getRotateStyle: function(a) {
        return "transform:rotate(Ddeg);-ms-transform:rotate(Ddeg);-moz-transform: rotate(Ddeg);-webkit-transform: rotate(Ddeg);-o-transform:rotate(Ddeg);".replace(/D/g, a)
    },
    getRotateStyleIE: (function() {
        var c = Math.PI / 180,
        b = Math.cos,
        a = Math.sin;
        return function(d, j, n) {
            var g = this,
            h = d * c,
            f = b(h),
            l = a(h),
            i = n * a((90 - d) * c),
            k = n * b((90 - d) * c),
            m = Math.min(n, n - i),
            e = d > 180 ? k: 0,
            o = "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', M11 = " + f + ", M12 = " + ( - l) + ", M21 = " + l + ", M22 = " + f + ")";
            return Ext.String.format("filter:{0};-ms-filter:{0};top:{1}px;left:{2}px;", o, m + j, e + g.handLeft)
        }
    })(),
    constructor: function() {
        var a = Ext.isIE && Ext.isIE8m;
        this.callParent(['<div class="sch-clockwrap ' + (a ? "": "sch-supports-border-radius") + ' {cls}"><div class="sch-clock"><div class="sch-hourIndicator" style="{[this.getHourStyle((values.date.getHours() % 12) * 30,' + this.hourTop + ", + " + this.hourHeight + ')]}">{[Ext.Date.monthNames[values.date.getMonth()].substr(0,3)]}</div><div class="sch-minuteIndicator" style="{[this.getMinuteStyle(values.date.getMinutes() * 6,' + this.minuteTop + ", + " + this.minuteHeight + ')]}">{[values.date.getDate()]}</div>' + (a ? "": '<div class="sch-clock-dot"></div>') + '</div><span class="sch-clock-text">{text}</span></div>', {
            disableFormats: true,
            getMinuteStyle: a ? this.getRotateStyleIE: this.getRotateStyle,
            getHourStyle: a ? this.getRotateStyleIE: this.getRotateStyle
        }])
    }
});
Ext.define("Sch.tooltip.Tooltip", {
    extend: "Ext.tip.ToolTip",
    requires: ["Sch.tooltip.ClockTemplate"],
    autoHide: false,
    anchor: "b",
    padding: "0 3 0 0",
    showDelay: 0,
    hideDelay: 0,
    quickShowInterval: 0,
    dismissDelay: 0,
    trackMouse: false,
    anchorOffset: 5,
    shadow: false,
    frame: false,
    schedulerView: null,
    message: null,
    valid: true,
    offsetAdjust: [18, 5],
    constructor: function(b) {
        var a = new Sch.tooltip.ClockTemplate();
        this.startDate = this.endDate = new Date();
        if (!this.template) {
            this.template = Ext.create("Ext.XTemplate", '<div class="sch-tip-{[values.valid ? "ok" : "notok"]}">{[this.renderClock(values.startDate, values.startText, "sch-tooltip-startdate")]}{[this.renderClock(values.endDate, values.endText, "sch-tooltip-enddate")]}<div class="sch-dragdrop-message">{message}</div></div>', {
                disableFormats: true,
                renderClock: function(d, e, c) {
                    return a.apply({
                        date: d,
                        text: e,
                        cls: c
                    })
                }
            })
        }
        this.callParent(arguments)
    },
    update: function(a, g, f, e) {
        if (this.startDate - a !== 0 || this.endDate - g !== 0 || this.valid !== f || this.message !== e) {
            var d = (this.message && !e) || (!this.message && e);
            this.startDate = a;
            this.endDate = g;
            this.valid = f;
            this.message = e;
            var c = this.schedulerView.getFormattedDate(a),
            b = this.schedulerView.getFormattedEndDate(g, a);
            if (this.mode === "calendar" && g.getHours() === 0 && g.getMinutes() === 0 && !(g.getYear() === a.getYear() && g.getMonth() === a.getMonth() && g.getDate() === a.getDate())) {
                g = Sch.util.Date.add(g, Sch.util.Date.DAY, -1)
            }
            this.callParent([this.template.apply({
                valid: f,
                startDate: a,
                endDate: g,
                startText: c,
                endText: b,
                message: e
            })]);
            if (d) {
                this.realign()
            }
        }
    },
    show: function(b, a) {
        if (!b || Ext.isArray(b)) {
            return
        }
        if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
            this.mode = "calendar";
            this.addCls("sch-day-resolution");
            this.removeCls("sch-hour-resolution")
        } else {
            this.mode = "clock";
            this.removeCls("sch-day-resolution");
            this.addCls("sch-hour-resolution")
        }
        a = arguments.length > 1 ? a: this.offsetAdjust[0];
        this.mouseOffsets = [a - this.offsetAdjust[0], -this.offsetAdjust[1]];
        this.setTarget(b);
        this.callParent();
        this.realign()
    },
    realign: function() {
        this.el.alignTo(this.target, "bl-tl", this.mouseOffsets)
    },
    afterRender: function() {
        this.callParent(arguments);
        this.el.on("mouseenter", this.realign, this)
    }
});
if (!Ext.ClassManager.get("Sch.view.model.TimeAxis")) {
    Ext.define("Sch.view.model.TimeAxis", {
        extend: "Ext.util.Observable",
        requires: ["Ext.Date", "Sch.util.Date", "Sch.preset.Manager"],
        timeAxis: null,
        availableWidth: 0,
        tickWidth: 100,
        snapToIncrement: false,
        forceFit: false,
        headerConfig: null,
        headers: null,
        mainHeader: 0,
        timeAxisColumnWidth: null,
        resourceColumnWidth: null,
        calendarColumnWidth: null,
        timeColumnWidth: null,
        rowHeightHorizontal: null,
        rowHeightVertical: null,
        mode: "horizontal",
        suppressFit: false,
        refCount: 0,
        columnConfig: {},
        viewPreset: null,
        columnLinesFor: "middle",
        eventStore: null,
        originalTickWidth: null,
        constructor: function(a) {
            var c = this;
            Ext.apply(this, a);
            if (this.viewPreset) {
                if (this.viewPreset instanceof Sch.preset.ViewPreset) {
                    this.consumeViewPreset(this.viewPreset)
                } else {
                    var b = Sch.preset.Manager.getPreset(this.viewPreset);
                    b && this.consumeViewPreset(b)
                }
            }
            c.timeAxis.on("reconfigure", c.onTimeAxisReconfigure, c);
            this.callParent(arguments)
        },
        destroy: function() {
            this.timeAxis.un("reconfigure", this.onTimeAxisReconfigure, this)
        },
        onTimeAxisReconfigure: function(a, b) {
            if (!b) {
                this.update()
            }
        },
        reconfigure: function(a) {
            this.headers = null;
            Ext.apply(this, a);
            switch (this.mode) {
            case "horizontal":
                this.setTickWidth(this.timeColumnWidth);
                break;
            case "vertical":
                this.setTickWidth(this.rowHeightVertical);
                break;
            case "calendar":
                this.setTickWidth(this.rowHeightVertical);
                break
            }
            this.fireEvent("reconfigure", this)
        },
        getColumnConfig: function() {
            return this.columnConfig
        },
        update: function(d, b) {
            var e = this.timeAxis,
            c = this.headerConfig;
            this.availableWidth = Math.max(d || this.availableWidth, 0);
            if (!Ext.isNumber(this.availableWidth)) {
                throw "Invalid available width provided to Sch.view.model.TimeAxis"
            }
            if (this.forceFit && this.availableWidth <= 0) {
                return
            }
            this.columnConfig = {};
            for (var f in c) {
                if (c[f].cellGenerator) {
                    this.columnConfig[f] = c[f].cellGenerator.call(this, e.getStart(), e.getEnd())
                } else {
                    this.columnConfig[f] = this.createHeaderRow(f, c[f])
                }
            }
            var a = this.calculateTickWidth(this.originalTickWidth);
            if (!Ext.isNumber(a) || a <= 0) {
                throw "Invalid column width calculated in Sch.view.model.TimeAxis"
            }
            this.updateTickWidth(a);
            if (!b) {
                this.fireEvent("update", this)
            }
        },
        createHeaderRow: function(a, d) {
            var c = [],
            e = this,
            f = d.align,
            b = Ext.Date.clearTime(new Date());
            e.forEachInterval(a,
            function(k, g, h) {
                var j = {
                    align: f,
                    start: k,
                    end: g,
                    headerCls: ""
                };
                if (d.renderer) {
                    j.header = d.renderer.call(d.scope || e, k, g, j, h, e.eventStore)
                } else {
                    j.header = Ext.Date.format(k, d.dateFormat)
                }
                if (d.unit === Sch.util.Date.DAY && (!d.increment || d.increment === 1)) {
                    j.headerCls += " sch-dayheadercell-" + k.getDay();
                    if (Ext.Date.clearTime(k, true) - b === 0) {
                        j.headerCls += " sch-dayheadercell-today"
                    }
                }
                c.push(j)
            });
            return c
        },
        getDistanceBetweenDates: function(b, a) {
            return Math.round(this.getPositionFromDate(a, true) - this.getPositionFromDate(b))
        },
        getPositionFromDate: function(e, d) {
            if (this.mode === "calendar") {
                var a = this.rowHeightCalendar || this.rowHeightVertical;
                var c = this.getHeaders();
                var b = this.timeAxis.getStart();
                var g = Sch.util.Date;
                var i = g.mergeDates(b, e, c[1].unit);
                var j = g.getDurationInUnit(b, i, c[1].unit, true) * a;
                var k = Math.round(j);
                if (k === 0 && d) {
                    return this.calendarRowsAmount * a
                }
                return k
            } else {
                var h = -1,
                f = this.timeAxis.getTickFromDate(e);
                if (f >= 0) {
                    h = Math.round(this.tickWidth * (f - this.timeAxis.visibleTickStart))
                }
                return h
            }
        },
        getDateFromPosition: function(i, l) {
            if (this.mode === "calendar") {
                var b = this.rowHeightCalendar || this.rowHeightVertical;
                var h = Sch.util.Date;
                var c = this.timeAxis.getStart();
                var d = this.getHeaders();
                var j = h.add(c, d[0].splitUnit, Math.floor(i[0] / this.calendarColumnWidth));
                var g = this.timeAxis.first();
                var e = (g.get("end") - g.get("start")) / b;
                var k = h.add(j, h.MILLI, Math.round(i[1] * e));
                if (l) {
                    k = this.timeAxis[l + "Date"](k)
                }
                return k
            } else {
                var f = i / this.getTickWidth() + this.timeAxis.visibleTickStart,
                a = this.timeAxis.getCount();
                if (f < 0 || f > a) {
                    return null
                }
                return this.timeAxis.getDateFromTick(f, l)
            }
        },
        getSingleUnitInPixels: function(a) {
            return Sch.util.Date.getUnitToBaseUnitRatio(this.timeAxis.getUnit(), a) * this.tickWidth / this.timeAxis.increment
        },
        getSnapPixelAmount: function() {
            if (this.snapToIncrement) {
                var a = this.timeAxis.getResolution();
                return (a.increment || 1) * this.getSingleUnitInPixels(a.unit)
            } else {
                return 1
            }
        },
        getTickWidth: function() {
            return this.tickWidth
        },
        setTickWidth: function(b, a) {
            this.originalTickWidth = b;
            this.updateTickWidth(b);
            this.update(null, a)
        },
        updateTickWidth: function(a) {
            this.tickWidth = a;
            switch (this.mode) {
            case "horizontal":
                this.timeColumnWidth = a;
                break;
            case "vertical":
                this.rowHeightVertical = a;
                break;
            case "calendar":
                this.rowHeightVertical = a;
                break
            }
        },
        getTotalWidth: function() {
            return Math.round(this.tickWidth * this.timeAxis.getVisibleTickTimeSpan())
        },
        calculateTickWidth: function(e) {
            var k = this.forceFit;
            var h = this.timeAxis;
            var c = 0,
            g = h.getUnit(),
            j = Number.MAX_VALUE,
            d = Sch.util.Date;
            if (this.snapToIncrement) {
                var f = h.getResolution();
                j = d.getUnitToBaseUnitRatio(g, f.unit) * f.increment
            } else {
                var i = d.getMeasuringUnit(g);
                j = Math.min(j, d.getUnitToBaseUnitRatio(g, i))
            }
            var b = Math[k ? "floor": "round"](this.getAvailableWidth() / h.getVisibleTickTimeSpan());
            if (!this.suppressFit) {
                c = (k || e < b) ? b: e;
                if (j > 0 && (!k || j < 1)) {
                    var a = Ext.versions.touch && k ? "ceil": (k ? "floor": "round");
                    c = Math.round(Math.max(1, Math[a](j * c)) / j)
                }
            } else {
                c = e
            }
            return c
        },
        getAvailableWidth: function() {
            return this.availableWidth
        },
        setAvailableWidth: function(a) {
            this.availableWidth = Math.max(0, a);
            var b = this.calculateTickWidth(this.originalTickWidth);
            if (b !== this.tickWidth) {
                this.update()
            }
        },
        fitToAvailableWidth: function(a) {
            var b = Math.floor(this.availableWidth / this.timeAxis.getVisibleTickTimeSpan());
            this.setTickWidth(b, a)
        },
        setForceFit: function(a) {
            if (a !== this.forceFit) {
                this.forceFit = a;
                this.update()
            }
        },
        setSnapToIncrement: function(a) {
            if (a !== this.snapToIncrement) {
                this.snapToIncrement = a;
                this.update()
            }
        },
        getViewRowHeight: function() {
            var a = this.mode == "horizontal" ? this.rowHeightHorizontal: this.rowHeightVertical;
            if (!a) {
                throw "rowHeight info not available"
            }
            return a
        },
        setViewRowHeight: function(c, a) {
            var d = this.mode === "horizontal";
            var b = "rowHeight" + Ext.String.capitalize(this.mode);
            if (this[b] != c) {
                this[b] = c;
                if (d) {
                    if (!a) {
                        this.fireEvent("update", this)
                    }
                } else {
                    this.setTickWidth(c, a)
                }
            }
        },
        setViewColumnWidth: function(b, a) {
            switch (this.mode) {
            case "horizontal":
                this.setTickWidth(b, a);
                break;
            case "vertical":
                this.resourceColumnWidth = b;
                break;
            case "calendar":
                this.calendarColumnWidth = b;
                break
            }
            if (!a) {
                this.fireEvent("columnwidthchange", this, b)
            }
        },
        getHeaders: function() {
            if (this.headers) {
                return this.headers
            }
            var a = this.headerConfig;
            this.mainHeader = a.top ? 1 : 0;
            return this.headers = [].concat(a.top || [], a.middle || [], a.bottom || [])
        },
        getMainHeader: function() {
            return this.getHeaders()[this.mainHeader]
        },
        getBottomHeader: function() {
            var a = this.getHeaders();
            return a[a.length - 1]
        },
        forEachInterval: function(b, a, d) {
            d = d || this;
            var c = this.headerConfig;
            if (!c) {
                return
            }
            if (b === "top" || (b === "middle" && c.bottom)) {
                var e = c[b];
                this.timeAxis.forEachAuxInterval(e.unit, e.increment, a, d)
            } else {
                this.timeAxis.each(function(g, f) {
                    return a.call(d, g.data.start, g.data.end, f)
                })
            }
        },
        forEachMainInterval: function(a, b) {
            this.forEachInterval("middle", a, b)
        },
        consumeViewPreset: function(a) {
            this.headers = null;
            var b = this.mode == "horizontal";
            Ext.apply(this, {
                headerConfig: a.headerConfig,
                columnLinesFor: a.columnLinesFor || "middle",
                rowHeightHorizontal: a.rowHeight,
                tickWidth: b ? a.timeColumnWidth: a.timeRowHeight || a.timeColumnWidth || 60,
                timeColumnWidth: a.timeColumnWidth,
                rowHeightVertical: a.timeRowHeight || a.timeColumnWidth || 60,
                timeAxisColumnWidth: a.timeAxisColumnWidth,
                resourceColumnWidth: a.resourceColumnWidth || 100
            });
            this.originalTickWidth = this.tickWidth
        }
    })
}
Ext.define("Sch.view.HorizontalTimeAxis", {
    extend: "Ext.util.Observable",
    requires: ["Ext.XTemplate"],
    trackHeaderOver: true,
    compactCellWidthThreshold: 15,
    baseCls: "sch-column-header",
    tableCls: "sch-header-row",
    headerHtmlRowTpl: '<table border="0" cellspacing="0" cellpadding="0" style="width: {totalWidth}px; {tstyle}" class="{{tableCls}} sch-header-row-{position} {cls}"><thead><tr><tpl for="cells"><td class="{{baseCls}} {headerCls}" style="position : static; text-align: {align}; width: {width}px; {style}" tabIndex="0"headerPosition="{parent.position}" headerIndex="{[xindex-1]}"><div class="sch-simple-timeheader">{header}</div></td></tpl></tr></thead></table>',
    model: null,
    hoverCls: "",
    containerEl: null,
    height: null,
    constructor: function(d) {
        var e = this;
        var b = !!Ext.versions.touch;
        var a = b ? "tap": "click";
        Ext.apply(this, d);
        e.callParent(arguments);
        e.model.on("update", e.onModelUpdate, this, {
            priority: 5
        });
        e.containerEl = Ext.get(e.containerEl);
        if (! (e.headerHtmlRowTpl instanceof Ext.Template)) {
            e.headerHtmlRowTpl = e.headerHtmlRowTpl.replace("{{baseCls}}", this.baseCls).replace("{{tableCls}}", this.tableCls);
            e.headerHtmlRowTpl = new Ext.XTemplate(e.headerHtmlRowTpl)
        }
        if (e.trackHeaderOver && e.hoverCls) {
            e.containerEl.on({
                mousemove: e.highlightCell,
                delegate: ".sch-column-header",
                scope: e
            });
            e.containerEl.on({
                mouseleave: e.clearHighlight,
                scope: e
            })
        }
        var c = {
            scope: this,
            delegate: ".sch-column-header"
        };
        if (b) {
            c.tap = this.onElClick("tap");
            c.doubletap = this.onElClick("doubletap")
        } else {
            c.click = this.onElClick("click");
            c.dblclick = this.onElClick("dblclick");
            c.contextmenu = this.onElClick("contextmenu")
        }
        e._listenerCfg = c;
        if (e.containerEl) {
            e.containerEl.on(c)
        }
    },
    destroy: function() {
        var a = this;
        if (a.containerEl) {
            a.containerEl.un(a._listenerCfg);
            a.containerEl.un({
                mousemove: a.highlightCell,
                delegate: ".sch-simple-timeheader",
                scope: a
            });
            a.containerEl.un({
                mouseleave: a.clearHighlight,
                scope: a
            })
        }
        a.model.un({
            update: a.onModelUpdate,
            scope: a
        })
    },
    onModelUpdate: function() {
        this.render()
    },
    getHTML: function(e, h, d) {
        var i = this.model.getColumnConfig();
        var g = this.model.getTotalWidth();
        var c = Ext.Object.getKeys(i).length;
        var b = this.height ? this.height / c: 0;
        var f = "";
        var a;
        if (i.top) {
            this.embedCellWidths(i.top);
            f += this.headerHtmlRowTpl.apply({
                totalWidth: g,
                cells: i.top,
                position: "top",
                tstyle: "border-top : 0;" + (b ? "height:" + b + "px": "")
            })
        }
        if (i.middle) {
            this.embedCellWidths(i.middle);
            f += this.headerHtmlRowTpl.apply({
                totalWidth: g,
                cells: i.middle,
                position: "middle",
                tstyle: (i.top ? "": "border-top : 0;") + (b ? "height:" + b + "px": ""),
                cls: !i.bottom && this.model.getTickWidth() <= this.compactCellWidthThreshold ? "sch-header-row-compact": ""
            })
        }
        if (i.bottom) {
            this.embedCellWidths(i.bottom);
            f += this.headerHtmlRowTpl.apply({
                totalWidth: g,
                cells: i.bottom,
                position: "bottom",
                tstyle: (b ? "height:" + b + "px": ""),
                cls: this.model.getTickWidth() <= this.compactCellWidthThreshold ? "sch-header-row-compact": ""
            })
        }
        return f + '<div class="sch-header-secondary-canvas"></div>'
    },
    render: function() {
        if (!this.containerEl) {
            return
        }
        var e = this.containerEl,
        f = e.dom,
        d = f.style.display,
        a = this.model.getColumnConfig(),
        b = f.parentNode;
        f.style.display = "none";
        b.removeChild(f);
        var c = this.getHTML();
        f.innerHTML = c;
        if (!a.top && !a.middle) {
            this.containerEl.addCls("sch-header-single-row")
        } else {
            this.containerEl.removeCls("sch-header-single-row")
        }
        b && b.appendChild(f);
        f.style.display = d;
        this.fireEvent("refresh", this)
    },
    embedCellWidths: function(b) {
        var e = (Ext.isIE7 || (Ext.isSafari && !Ext.supports.Touch)) ? 1 : 0;
        for (var c = 0; c < b.length; c++) {
            var a = b[c];
            var d = this.model.getDistanceBetweenDates(a.start, a.end);
            if (d) {
                a.width = d - (c ? e: 0)
            } else {
                a.width = 0;
                a.style = "display: none"
            }
        }
    },
    onElClick: function(a) {
        return function(e, f) {
            f = e.delegatedTarget || f;
            var b = Ext.fly(f).getAttribute("headerPosition"),
            c = Ext.fly(f).getAttribute("headerIndex"),
            d = this.model.getColumnConfig()[b][c];
            this.fireEvent("timeheader" + a, this, d.start, d.end, e)
        }
    },
    highlightCell: function(c, a) {
        var b = this;
        if (a !== b.highlightedCell) {
            b.clearHighlight();
            b.highlightedCell = a;
            Ext.fly(a).addCls(b.hoverCls)
        }
    },
    clearHighlight: function() {
        var b = this,
        a = b.highlightedCell;
        if (a) {
            Ext.fly(a).removeCls(b.hoverCls);
            delete b.highlightedCell
        }
    }
});
Ext.define("Sch.column.timeAxis.Horizontal", {
    extend: "Ext.grid.column.Column",
    alias: "widget.timeaxiscolumn",
    draggable: false,
    groupable: false,
    hideable: false,
    sortable: false,
    fixed: true,
    menuDisabled: true,
    cls: "sch-simple-timeaxis",
    tdCls: "sch-timetd",
    enableLocking: false,
    requires: ["Sch.view.HorizontalTimeAxis"],
    timeAxisViewModel: null,
    headerView: null,
    hoverCls: "",
    ownHoverCls: "sch-column-header-over",
    trackHeaderOver: true,
    compactCellWidthThreshold: 20,
    afterRender: function() {
        var a = this;
        a.headerView = new Sch.view.HorizontalTimeAxis({
            model: a.timeAxisViewModel,
            containerEl: a.titleEl,
            hoverCls: a.ownHoverCls,
            trackHeaderOver: a.trackHeaderOver,
            compactCellWidthThreshold: a.compactCellWidthThreshold
        });
        a.headerView.on("refresh", a.onTimeAxisViewRefresh, a);
        a.ownerCt.on("afterlayout",
        function() {
            if (!a.ownerCt) {
                return
            }
            a.mon(a.ownerCt, "resize", a.onHeaderContainerResize, a);
            if (this.getWidth() > 0) {
                if (a.getAvailableWidthForSchedule() === a.timeAxisViewModel.getAvailableWidth()) {
                    a.headerView.render()
                } else {
                    a.timeAxisViewModel.update(a.getAvailableWidthForSchedule())
                }
                a.setWidth(a.timeAxisViewModel.getTotalWidth())
            }
        },
        null, {
            single: true
        });
        this.enableBubble("timeheaderclick", "timeheaderdblclick", "timeheadercontextmenu");
        a.relayEvents(a.headerView, ["timeheaderclick", "timeheaderdblclick", "timeheadercontextmenu"]);
        a.callParent(arguments);
        a.focusable = false
    },
    initRenderData: function() {
        var a = this;
        a.renderData.headerCls = a.renderData.headerCls || a.headerCls;
        return a.callParent(arguments)
    },
    destroy: function() {
        if (this.headerView) {
            this.headerView.destroy()
        }
        this.callParent(arguments)
    },
    onTimeAxisViewRefresh: function() {
        this.headerView.un("refresh", this.onTimeAxisViewRefresh, this);
        this.setWidth(this.timeAxisViewModel.getTotalWidth());
        this.headerView.on("refresh", this.onTimeAxisViewRefresh, this)
    },
    getAvailableWidthForSchedule: function() {
        var d = this.ownerCt.isVisible(true) ? this.ownerCt.getWidth() : (this.ownerCt.lastBox && this.ownerCt.lastBox.width || 0),
        a = this.ownerCt.items,
        c;
        for (var b = 1; b < a.length; b++) {
            c = a.get(b);
            if (!c.hidden) {
                d -= c.isVisible(true) ? c.getWidth() : (c.lastBox && c.lastBox.width || 0)
            }
        }
        return d - Ext.getScrollbarSize().width - 1
    },
    onResize: function() {
        this.callParent(arguments);
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule())
    },
    onHeaderContainerResize: function() {
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
        this.headerView.render()
    },
    refresh: function() {
        this.timeAxisViewModel.update(null, true);
        this.headerView.render()
    }
});
Ext.define("Sch.plugin.TreeCellEditing", {
    extend: "Ext.grid.plugin.CellEditing",
    alias: "plugin.scheduler_treecellediting",
    lockableScope: "locked",
    editorsStarted: 0,
    init: function(a) {
        this._grid = a;
        this.on("beforeedit", this.onMyBeforeEdit, this);
        this.callParent(arguments)
    },
    bindPositionFixer: function() {},
    unbindPositionFixer: function() {},
    fixEditorPosition: function() {
        var a = this.getActiveEditor();
        if (a && a.getEl()) {
            var c = this.getEditingContext(this.context.record, this.context.column);
            if (c) {
                this.context.row = c.row;
                this.context.rowIdx = c.rowIdx;
                a.boundEl = this.getCell(c.record, c.column);
                a.realign();
                this.scroll = this.view.el.getScroll();
                var b = this._grid.getView();
                b.focusedRow = b.getNode(c.rowIdx)
            }
        }
    },
    checkReadOnly: function() {
        var a = this._grid;
        if (! (a instanceof Sch.panel.TimelineTreePanel)) {
            a = a.up("tablepanel")
        }
        return ! a.isReadOnly()
    },
    onEditComplete: function(b, d, a) {
        var c = this;
        if (b.field.applyChanges) {
            b.field.applyChanges(b.field.task || c.context.record);
            c.callParent([b, d, d])
        } else {
            c.callParent([b, d, a])
        }
        c.unbindPositionFixer()
    },
    onMyBeforeEdit: function(b, a) {
        return this.checkReadOnly()
    },
    showEditor: function(a, b, c) {
        var d = a.field;
        if (d) {
            if (d.setTask) {
                d.setTask(b.record);
                c = b.value = b.originalValue = d.getValue()
            } else {
                if (!b.column.dataIndex && b.value === undefined) {
                    c = b.value = d.getDisplayValue(b.record)
                }
            }
        }
        this.callParent([a, b, c])
    },
    _cancelEdit: function() {
        this.callParent(arguments);
        this.unbindPositionFixer()
    }
});
Ext.define("Sch.feature.ResizeZone", {
    extend: "Ext.util.Observable",
    requires: ["Ext.resizer.Resizer", "Sch.tooltip.Tooltip", "Sch.util.ScrollManager"],
    showTooltip: true,
    showExactResizePosition: false,
    validatorFn: Ext.emptyFn,
    validatorFnScope: null,
    schedulerView: null,
    origEl: null,
    handlePos: null,
    eventRec: null,
    tip: null,
    tipInstance: null,
    startScroll: null,
    constructor: function(a) {
        Ext.apply(this, a);
        var b = this.schedulerView;
        b.on({
            destroy: this.cleanUp,
            scope: this
        });
        b.mon(b.el, {
            mousedown: this.onMouseDown,
            mouseup: this.onMouseUp,
            scope: this,
            delegate: ".sch-resizable-handle"
        });
        this.callParent(arguments)
    },
    onMouseDown: function(f, a) {
        var b = this.schedulerView;
        var d = this.eventRec = b.resolveEventRecord(a);
        var c = d.isResizable();
        if (f.button !== 0 || (c === false || typeof c === "string" && !a.className.match(c))) {
            return
        }
        this.eventRec = d;
        this.handlePos = this.getHandlePosition(a);
        this.origEl = Ext.get(f.getTarget(".sch-event"));
        b.el.on({
            mousemove: this.onMouseMove,
            scope: this,
            single: true
        })
    },
    onMouseUp: function(c, a) {
        var b = this.schedulerView;
        b.el.un({
            mousemove: this.onMouseMove,
            scope: this,
            single: true
        })
    },
    getTipInstance: function() {
        if (this.tipInstance) {
            return this.tipInstance
        }
        var a = this.schedulerView;
        var c = this.tip;
        var b = a.up("[lockable=true]").el;
        if (c instanceof Ext.tip.ToolTip) {
            Ext.applyIf(c, {
                schedulerView: a
            })
        } else {
            c = new Sch.tooltip.Tooltip(Ext.apply({
                rtl: this.rtl,
                schedulerView: a,
                constrainTo: b,
                cls: "sch-resize-tip",
                onMyMouseMove: function(d) {
                    this.el.alignTo(this.target, "bl-tl", [d.getX() - this.target.getX(), -5])
                }
            },
            c))
        }
        return this.tipInstance = c
    },
    onMouseMove: function(h, a) {
        var b = this.schedulerView,
        g = this.eventRec,
        d = this.handlePos;
        if (!g || b.fireEvent("beforeeventresize", b, g, h) === false) {
            return
        }
        delete this.eventRec;
        h.stopEvent();
        this.origEl.addCls("sch-event-resizing");
        this.resizer = this.createResizer(this.origEl, g, d);
        var c = this.resizer.resizeTracker;
        if (this.showTooltip) {
            var f = this.getTipInstance();
            f.update(g.getStartDate(), g.getEndDate(), true);
            f.show(this.origEl)
        }
        c.onMouseDown(h, this.resizer[d].dom);
        c.onMouseMove(h, this.resizer[d].dom);
        b.fireEvent("eventresizestart", b, g);
        b.el.on("scroll", this.onViewElScroll, this)
    },
    getHandlePosition: function(b) {
        var a = b.className.match("start");
        if (this.schedulerView.getMode() === "horizontal") {
            if (this.schedulerView.rtl) {
                return a ? "east": "west"
            }
            return a ? "west": "east"
        } else {
            return a ? "north": "south"
        }
    },
    createResizer: function(b, e, o) {
        var l = this.schedulerView,
        r = this,
        f = l.resolveResource(b),
        q = l.getSnapPixelAmount(),
        n = l.getScheduleRegion(f, e),
        p = l.getDateConstraints(f, e),
        m = b.getHeight(),
        g = (l.rtl && o[0] === "e") || (!l.rtl && o[0] === "w") || o[0] === "n",
        h = l.getMode() !== "horizontal",
        d = {
            otherEdgeX: g ? b.getRight() : b.getLeft(),
            otherEdgeY: g ? b.getBottom() : b.getTop(),
            target: b,
            isStart: g,
            startYOffset: b.getY() - b.parent().getY(),
            startXOffset: b.getX() - b.parent().getX(),
            dateConstraints: p,
            resourceRecord: f,
            eventRecord: e,
            handles: o[0],
            minHeight: m,
            constrainTo: n,
            listeners: {
                resizedrag: this.partialResize,
                resize: this.afterResize,
                scope: this
            }
        };
        var c = b.id;
        var j = "_" + c;
        b.id = b.dom.id = j;
        Ext.cache[j] = Ext.cache[c];
        if (h) {
            if (q > 0) {
                var i = b.getWidth();
                Ext.apply(d, {
                    minHeight: q,
                    minWidth: i,
                    maxWidth: i,
                    heightIncrement: q
                })
            }
        } else {
            if (q > 0) {
                Ext.apply(d, {
                    minWidth: q,
                    maxHeight: m,
                    widthIncrement: q
                })
            }
        }
        var k = new Ext.resizer.Resizer(d);
        k.prevId = c;
        if (k.resizeTracker) {
            k.resizeTracker.tolerance = -1;
            var a = k.resizeTracker.updateDimensions;
            k.resizeTracker.updateDimensions = function(t) {
                if (!Ext.isWebKit || t.getTarget(".sch-timelineview")) {
                    var s;
                    if (h) {
                        s = l.el.getScroll().top - r.startScroll.top;
                        k.resizeTracker.minHeight = d.minHeight - Math.abs(s)
                    } else {
                        s = l.el.getScroll().left - r.startScroll.left;
                        k.resizeTracker.minWidth = d.minWidth - Math.abs(s)
                    }
                    a.apply(this, arguments)
                }
            };
            k.resizeTracker.resize = function(s) {
                var t;
                if (h) {
                    t = l.el.getScroll().top - r.startScroll.top;
                    if (o[0] === "s") {
                        s.y -= t
                    }
                    s.height += Math.abs(t)
                } else {
                    t = l.el.getScroll().left - r.startScroll.left;
                    if (o[0] === "e") {
                        s.x -= t
                    }
                    s.width += Math.abs(t)
                }
                Ext.resizer.ResizeTracker.prototype.resize.apply(this, arguments)
            }
        }
        b.setStyle("z-index", parseInt(b.getStyle("z-index"), 10) + 1);
        Sch.util.ScrollManager.activate(l, l.getMode() === "horizontal" ? "horizontal": "vertical");
        this.startScroll = l.el.getScroll();
        return k
    },
    getStartEndDates: function() {
        var e = this.resizer,
        c = e.el,
        d = this.schedulerView,
        b = e.isStart,
        g, a, f;
        if (b) {
            if (d.getMode() === "horizontal") {
                f = [d.rtl ? c.getRight() : c.getLeft() + 1, c.getTop()]
            } else {
                f = [(c.getRight() + c.getLeft()) / 2, c.getTop()]
            }
            a = e.eventRecord.getEndDate();
            if (d.snapRelativeToEventStartDate) {
                g = d.getDateFromXY(f);
                g = d.timeAxis.roundDate(g, e.eventRecord.getStartDate())
            } else {
                g = d.getDateFromXY(f, "round")
            }
        } else {
            if (d.getMode() === "horizontal") {
                f = [d.rtl ? c.getLeft() : c.getRight(), c.getBottom()]
            } else {
                f = [(c.getRight() + c.getLeft()) / 2, c.getBottom()]
            }
            g = e.eventRecord.getStartDate();
            if (d.snapRelativeToEventStartDate) {
                a = d.getDateFromXY(f);
                a = d.timeAxis.roundDate(a, e.eventRecord.getEndDate())
            } else {
                a = d.getDateFromXY(f, "round")
            }
        }
        g = g || e.start;
        a = a || e.end;
        if (e.dateConstraints) {
            g = Sch.util.Date.constrain(g, e.dateConstraints.start, e.dateConstraints.end);
            a = Sch.util.Date.constrain(a, e.dateConstraints.start, e.dateConstraints.end)
        }
        return {
            start: g,
            end: a
        }
    },
    partialResize: function(o, t, p, u) {
        var m = this.schedulerView,
        g = u.type === "scroll" ? this.resizer.resizeTracker.lastXY: u.getXY(),
        n = this.getStartEndDates(g),
        d = n.start,
        c = n.end,
        b = o.eventRecord,
        l = m.getMode(),
        i = m.isHorizontal();
        if (i) {
            o.target.el.setY(o.target.parent().getY() + o.startYOffset)
        } else {
            o.target.el.setX(o.target.parent().getX() + o.startXOffset)
        }
        if (this.showTooltip) {
            var q = this.validatorFn.call(this.validatorFnScope || this, o.resourceRecord, b, d, c);
            var k = "";
            if (q && typeof q !== "boolean") {
                k = q.message;
                q = q.valid
            }
            this.getTipInstance().update(d, c, q !== false, k)
        }
        if (this.showExactResizePosition) {
            var v = o.target.el,
            h, j, f;
            if (o.isStart) {
                if (m.getMode() === "calendar") {
                    var a = m.calendar.getEventColumns(b)[0];
                    h = m.timeAxisViewModel.getDistanceBetweenDates(d, a.end)
                } else {
                    h = m.timeAxisViewModel.getDistanceBetweenDates(d, b.getEndDate())
                }
                if (i) {
                    j = m.getDateFromCoordinate(o.otherEdgeX - Math.min(t, o.maxWidth)) || d;
                    f = m.timeAxisViewModel.getDistanceBetweenDates(j, d);
                    v.setWidth(h);
                    v.setX(v.getX() + f)
                } else {
                    j = m.getDateFromCoordinate(o.otherEdgeY - Math.min(t, o.maxHeight)) || d;
                    f = m.timeAxisViewModel.getDistanceBetweenDates(j, d);
                    v.setHeight(h);
                    v.setY(v.getY() + f)
                }
            } else {
                h = m.timeAxisViewModel.getDistanceBetweenDates(b.getStartDate(), c);
                if (i) {
                    v.setWidth(h)
                } else {
                    v.setHeight(h)
                }
            }
        } else {
            if (!d || !c || ((o.start - d === 0) && (o.end - c === 0))) {
                return
            }
        }
        o.end = c;
        o.start = d;
        m.fireEvent("eventpartialresize", m, b, d, c, o.el)
    },
    onViewElScroll: function(b, a) {
        this.resizer.resizeTracker.onDrag.apply(this.resizer.resizeTracker, arguments);
        this.partialResize(this.resizer, 0, 0, b)
    },
    afterResize: function(b, n, g, i) {
        var k = this,
        j = b.resourceRecord,
        l = b.eventRecord,
        f = l.getStartDate(),
        q = l.getEndDate(),
        c = b.start || f,
        d = b.end || q,
        p = k.schedulerView,
        o = false,
        m = true,
        a = k.validatorFn.call(k.validatorFnScope || k, j, l, c, d, i);
        Sch.util.ScrollManager.deactivate();
        p.el.un("scroll", this.onViewElScroll, this);
        if (this.showTooltip) {
            this.getTipInstance().hide()
        }
        p.el.select("[id^=calendar-resizer-placeholder]").remove();
        delete Ext.cache[b.el.id];
        b.el.id = b.el.dom.id = b.el.id.substr(1);
        k.resizeContext = {
            resourceRecord: b.resourceRecord,
            eventRecord: l,
            start: c,
            end: d,
            finalize: function() {
                k.finalize.apply(k, arguments)
            }
        };
        if (a && typeof a !== "boolean") {
            a = a.valid
        }
        if (c && d && (d - c > 0) && ((c - f !== 0) || (d - q !== 0)) && a !== false) {
            m = p.fireEvent("beforeeventresizefinalize", k, k.resizeContext, i) !== false;
            o = true
        } else {
            p.repaintEventsForResource(j)
        }
        if (m) {
            k.finalize(o)
        }
    },
    finalize: function(a) {
        var b = this.schedulerView;
        var e = this.resizeContext;
        var d = false;
        var c = function() {
            d = true
        };
        b.eventStore.on("update", c);
        this.resizer.target.destroy();
        if (a) {
            if (this.resizer.isStart) {
                e.eventRecord.setStartDate(e.start, false, b.eventStore.skipWeekendsDuringDragDrop)
            } else {
                e.eventRecord.setEndDate(e.end, false, b.eventStore.skipWeekendsDuringDragDrop)
            }
            if (!d) {
                b.repaintEventsForResource(e.resourceRecord)
            }
        } else {
            b.repaintEventsForResource(e.resourceRecord)
        }
        this.resizer.destroy();
        b.eventStore.un("update", c);
        b.fireEvent("eventresizeend", b, e.eventRecord);
        this.resizeContext = null
    },
    cleanUp: function() {
        if (this.tipInstance) {
            this.tipInstance.destroy()
        }
    }
});
Ext.define("Sch.feature.ColumnLines", {
    extend: "Sch.plugin.Lines",
    requires: ["Ext.data.JsonStore"],
    cls: "sch-column-line",
    showTip: false,
    timeAxisViewModel: null,
    renderingDoneEvent: "columnlinessynced",
    init: function(a) {
        this.timeAxis = a.getTimeAxis();
        this.timeAxisViewModel = a.timeAxisViewModel;
        this.panel = a;
        this.store = new Ext.data.JsonStore({
            fields: ["Date"]
        });
        this.callParent(arguments);
        a.on({
            modechange: this.populate,
            destroy: this.onHostDestroy,
            scope: this
        });
        this.timeAxisViewModel.on("update", this.populate, this);
        this.populate()
    },
    onHostDestroy: function() {
        this.timeAxisViewModel.un("update", this.populate, this)
    },
    populate: function() {
        this.store.setData(this.getData())
    },
    getElementData: function() {
        var a = this.schedulerView;
        if (a.isHorizontal() && a.store.getCount() > 0) {
            return this.callParent(arguments)
        }
        return []
    },
    getData: function() {
        var a = this.panel,
        m = [];
        if (a.isHorizontal()) {
            var k = this.timeAxisViewModel;
            var g = k.columnLinesFor;
            var e = !!(k.headerConfig && k.headerConfig[g].cellGenerator);
            if (e) {
                var o = k.getColumnConfig()[g];
                for (var d = 1,
                b = o.length; d < b; d++) {
                    m.push({
                        Date: o[d].start
                    })
                }
            } else {
                var c, j, n = k.getColumnConfig(),
                f;
                if (g === "bottom") {
                    c = "middle"
                } else {
                    if (g === "middle") {
                        c = "top"
                    }
                }
                j = n[c];
                if (j) {
                    var h = k.headerConfig;
                    if (h[c].increment !== h[g].increment || h[c].unit !== h[g].unit) {
                        f = {};
                        Ext.Array.each(j,
                        function(i) {
                            f[i.start.getTime()] = 1
                        })
                    }
                }
                k.forEachInterval(g,
                function(q, l, p) {
                    if (p > 0) {
                        m.push({
                            Date: q,
                            Cls: f && f[q.getTime()] ? "sch-column-line-solid": ""
                        })
                    }
                })
            }
        }
        return m
    }
});
Ext.define("Sch.plugin.CurrentTimeLine", {
    extend: "Sch.plugin.Lines",
    alias: "plugin.scheduler_currenttimeline",
    mixins: ["Sch.mixin.Localizable"],
    requires: ["Ext.data.JsonStore"],
    updateInterval: 60000,
    showHeaderElements: true,
    autoUpdate: true,
    expandToFitView: true,
    timer: null,
    init: function(c) {
        if (Ext.getVersion("touch")) {
            this.showHeaderElements = false
        }
        var b = new Ext.data.JsonStore({
            fields: ["Date", "Cls", "Text"],
            data: [{
                Date: new Date(),
                Cls: "sch-todayLine",
                Text: this.L("tooltipText")
            }]
        });
        var a = b.first();
        if (this.autoUpdate) {
            this.timer = setInterval(function() {
                a.set("Date", new Date())
            },
            this.updateInterval)
        }
        this.store = b;
        this.callParent(arguments)
    },
    destroy: function() {
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null
        }
        if (this.store.autoDestroy) {
            this.store.destroy()
        }
        this.callParent(arguments)
    }
});
Ext.define("Sch.view.Horizontal", {
    requires: ["Ext.util.Region", "Ext.Element", "Sch.util.Date"],
    view: null,
    constructor: function(a) {
        Ext.apply(this, a)
    },
    translateToScheduleCoordinate: function(a) {
        var b = this.view;
        if (b.rtl) {
            return b.getHorizontalTimeAxisColumn().getEl().getRight() - a
        }
        return a - b.getEl().getX() + b.getScroll().left
    },
    translateToPageCoordinate: function(a) {
        var b = this.view;
        return a + b.getEl().getX() - b.getScroll().left
    },
    getDateFromXY: function(c, b, a) {
        var d = c[0];
        if (!a) {
            d = this.translateToScheduleCoordinate(d)
        }
        return this.view.timeAxisViewModel.getDateFromPosition(d, b)
    },
    getEventRenderData: function(a) {
        var f = a.getStartDate(),
        e = a.getEndDate() || f,
        h = this.view,
        c = h.timeAxis.getStart(),
        i = h.timeAxis.getEnd(),
        g = Math,
        d = h.getXFromDate(Sch.util.Date.max(f, c)),
        j = h.getXFromDate(Sch.util.Date.min(e, i)),
        b = {};
        if (this.view.rtl) {
            b.right = g.min(d, j)
        } else {
            b.left = g.min(d, j)
        }
        b.width = g.max(1, g.abs(j - d)) - h.eventBorderWidth;
        if (h.managedEventSizing) {
            b.top = g.max(0, (h.barMargin - ((Ext.isIE && !Ext.isStrict) ? 0 : h.eventBorderWidth - h.cellTopBorderWidth)));
            b.height = h.timeAxisViewModel.rowHeightHorizontal - (2 * h.barMargin) - h.eventBorderWidth
        }
        b.start = f;
        b.end = e;
        b.startsOutsideView = f < c;
        b.endsOutsideView = e > i;
        return b
    },
    getScheduleRegion: function(e, g) {
        var c = Ext.Element.prototype.getRegion ? "getRegion": "getPageBox",
        j = this.view,
        i = e ? Ext.fly(j.getRowNode(e))[c]() : j.getTableRegion(),
        f = j.timeAxis.getStart(),
        l = j.timeAxis.getEnd(),
        b = j.getDateConstraints(e, g) || {
            start: f,
            end: l
        },
        d = this.translateToPageCoordinate(j.getXFromDate(Sch.util.Date.max(f, b.start))),
        k = this.translateToPageCoordinate(j.getXFromDate(Sch.util.Date.min(l, b.end))),
        h = i.top + j.barMargin,
        a = i.bottom - j.barMargin - j.eventBorderWidth;
        return new Ext.util.Region(h, Math.max(d, k), a, Math.min(d, k))
    },
    getResourceRegion: function(j, e, i) {
        var m = this.view,
        d = m.getRowNode(j),
        f = Ext.fly(d).getOffsetsTo(m.getEl()),
        k = m.timeAxis.getStart(),
        o = m.timeAxis.getEnd(),
        c = e ? Sch.util.Date.max(k, e) : k,
        g = i ? Sch.util.Date.min(o, i) : o,
        h = m.getXFromDate(c),
        n = m.getXFromDate(g),
        l = f[1] + m.cellTopBorderWidth,
        a = f[1] + Ext.fly(d).getHeight() - m.cellBottomBorderWidth;
        if (!Ext.versions.touch) {
            var b = m.getScroll();
            l += b.top;
            a += b.top
        }
        return new Ext.util.Region(l, Math.max(h, n), a, Math.min(h, n))
    },
    columnRenderer: function(d, q, k, n, p) {
        var o = this.view;
        var b = o.eventStore.getEventsForResource(k);
        if (b.length === 0) {
            return
        }
        var h = o.timeAxis,
        m = [],
        g,
        e;
        for (g = 0, e = b.length; g < e; g++) {
            var a = b[g],
            c = a.getStartDate(),
            f = a.getEndDate();
            if (c && f && h.timeSpanInAxis(c, f)) {
                m[m.length] = o.generateTplData(a, k, n)
            }
        }
        if (o.dynamicRowHeight) {
            var j = o.eventLayout.horizontal;
            j.applyLayout(m, k);
            q.rowHeight = j.getRowHeight(k, b)
        }
        return o.eventTpl.apply(m)
    },
    resolveResource: function(b) {
        var a = this.view;
        var c = a.findRowByChild(b);
        if (c) {
            return a.getRecordForRowNode(c)
        }
        return null
    },
    getTimeSpanRegion: function(b, h, g) {
        var d = this.view,
        c = d.getXFromDate(b),
        e = h ? d.getXFromDate(h) : c,
        a,
        f;
        f = d.getTableRegion();
        if (g) {
            a = Math.max(f ? f.bottom - f.top: 0, d.getEl().dom.clientHeight)
        } else {
            a = f ? f.bottom - f.top: 0
        }
        return new Ext.util.Region(0, Math.max(c, e), a, Math.min(c, e))
    },
    getStartEndDatesFromRegion: function(g, d, c) {
        var b = this.view;
        var f = b.rtl;
        var a = b.getDateFromCoordinate(f ? g.right: g.left, d),
        e = b.getDateFromCoordinate(f ? g.left: g.right, d);
        if (a && e || c && (a || e)) {
            return {
                start: a,
                end: e
            }
        }
        return null
    },
    onEventAdd: function(q, p) {
        var o = this.view;
        var h = {};
        for (var m = 0,
        e = p.length; m < e; m++) {
            var a = p[m],
            b = a.getStartDate(),
            n = a.getEndDate();
            if (b && n && o.timeAxis.timeSpanInAxis(b, n)) {
                var c = p[m].getResources(o.eventStore);
                for (var g = 0,
                f = c.length; g < f; g++) {
                    var d = c[g];
                    h[d.getId()] = d
                }
            }
        }
        Ext.Object.each(h,
        function(j, i) {
            o.repaintEventsForResource(i)
        })
    },
    onEventRemove: function(k, e) {
        var h = this.view;
        var j = this.resourceStore;
        var f = Ext.tree && Ext.tree.View && h instanceof Ext.tree.View;
        if (!Ext.isArray(e)) {
            e = [e]
        }
        var g = function(i) {
            if (h.store.indexOf(i) >= 0) {
                h.repaintEventsForResource(i)
            }
        };
        for (var d = 0; d < e.length; d++) {
            var a = e[d].getResources(h.eventStore);
            if (a.length > 1) {
                Ext.each(a, g, this)
            } else {
                var b = h.getEventNodeByRecord(e[d]);
                if (b) {
                    var c = h.resolveResource(b);
                    if (Ext.Element.prototype.fadeOut) {
                        Ext.get(b).fadeOut({
                            callback: function() {
                                g(c)
                            }
                        })
                    } else {
                        Ext.Anim.run(Ext.get(b), "fade", {
                            out: true,
                            duration: 500,
                            after: function() {
                                g(c)
                            },
                            autoClear: false
                        })
                    }
                }
            }
        }
    },
    onEventUpdate: function(e, f) {
        var i = f.previous || {};
        var k = this.view;
        var h = k.timeAxis;
        var a = f.getStartDate();
        var j = f.getEndDate();
        var b = i.StartDate || a;
        var g = i.EndDate || j;
        var l = b && g && h.timeSpanInAxis(b, g);
        if (f.resourceIdField in i && l) {
            var d = e.getResourceStore().getById(i[f.resourceIdField]);
            if (d) {
                k.repaintEventsForResource(d, true)
            }
        }
        if ((a && j && h.timeSpanInAxis(a, j)) || l) {
            var c = f.getResources(k.eventStore);
            Ext.each(c,
            function(m) {
                k.repaintEventsForResource(m, true)
            })
        }
    },
    setColumnWidth: function(c, b) {
        var a = this.view;
        a.getTimeAxisViewModel().setViewColumnWidth(c, b)
    },
    getVisibleDateRange: function() {
        var d = this.view;
        if (!d.getEl()) {
            return null
        }
        var c = d.getTableRegion(),
        b = d.timeAxis.getStart(),
        f = d.timeAxis.getEnd(),
        e = d.getWidth();
        if ((c.right - c.left) < e) {
            return {
                startDate: b,
                endDate: f
            }
        }
        var a = d.getScroll();
        return {
            startDate: d.getDateFromCoordinate(a.left, null, true),
            endDate: d.getDateFromCoordinate(a.left + e, null, true)
        }
    }
});
Ext.define("Sch.mixin.AbstractTimelineView", {
    requires: ["Sch.data.TimeAxis", "Sch.view.Horizontal"],
    selectedEventCls: "sch-event-selected",
    readOnly: false,
    horizontalViewClass: "Sch.view.Horizontal",
    timeCellCls: "sch-timetd",
    timeCellSelector: ".sch-timetd",
    eventBorderWidth: 1,
    timeAxis: null,
    timeAxisViewModel: null,
    eventPrefix: null,
    rowHeight: null,
    orientation: "horizontal",
    mode: "horizontal",
    horizontal: null,
    vertical: null,
    secondaryCanvasEl: null,
    panel: null,
    displayDateFormat: null,
    el: null,
    constructor: function(a) {
        if (a && a.orientation) {
            a.mode = this.mode = a.orientation
        }
        this.callParent([a])
    },
    _initializeTimelineView: function() {
        if (this.horizontalViewClass) {
            this.horizontal = Ext.create(this.horizontalViewClass, {
                view: this
            })
        }
        if (this.verticalViewClass) {
            this.vertical = Ext.create(this.verticalViewClass, {
                view: this
            })
        }
        if (this.calendarViewClass) {
            this.calendar = Ext.create(this.calendarViewClass, {
                view: this
            })
        }
        this.eventPrefix = (this.eventPrefix || this.getId()) + "-"
    },
    getTimeAxisViewModel: function() {
        return this.timeAxisViewModel
    },
    getFormattedDate: function(a) {
        return Ext.Date.format(a, this.getDisplayDateFormat())
    },
    getFormattedEndDate: function(c, a) {
        var b = this.getDisplayDateFormat();
        if (c.getHours() === 0 && c.getMinutes() === 0 && !(c.getYear() === a.getYear() && c.getMonth() === a.getMonth() && c.getDate() === a.getDate()) && !Sch.util.Date.hourInfoRe.test(b.replace(Sch.util.Date.stripEscapeRe, ""))) {
            c = Sch.util.Date.add(c, Sch.util.Date.DAY, -1)
        }
        return Ext.Date.format(c, b)
    },
    getDisplayDateFormat: function() {
        return this.displayDateFormat
    },
    setDisplayDateFormat: function(a) {
        this.displayDateFormat = a
    },
    fitColumns: function(b) {
        if (this.mode === "horizontal") {
            this.getTimeAxisViewModel().fitToAvailableWidth(b)
        } else {
            var a = Math.floor((this.panel.getWidth() - Ext.getScrollbarSize().width - 1) / this.headerCt.getColumnCount());
            this.setColumnWidth(a, b)
        }
    },
    getElementFromEventRecord: function(a, b) {
        if (b === true) {
            return this.getEventNodesByRecord(a)
        } else {
            if (this.getMode() === "calendar") {
                return this.getEventNodesByRecord(a).item(0)
            } else {
                return Ext.get(this.eventPrefix + a.internalId)
            }
        }
    },
    getEventNodeByRecord: function(a) {
        return document.getElementById(this.eventPrefix + a.internalId)
    },
    getEventNodesByRecord: function(a) {
        if (this.getMode() === "calendar") {
            return this.getEl().select("[id^=" + this.eventPrefix + a.internalId + "-]")
        } else {
            return this.getEl().select("[id=" + this.eventPrefix + a.internalId + "]")
        }
    },
    getStartEndDatesFromRegion: function(c, b, a) {
        return this[this.mode].getStartEndDatesFromRegion(c, b, a)
    },
    getTimeResolution: function() {
        return this.timeAxis.getResolution()
    },
    setTimeResolution: function(b, a) {
        this.timeAxis.setResolution(b, a);
        if (this.getTimeAxisViewModel().snapToIncrement) {
            this.refreshKeepingScroll()
        }
    },
    getEventIdFromDomNodeId: function(b) {
        if (this.getMode() === "calendar") {
            var a = b.substring(this.eventPrefix.length).split("-");
            a.pop();
            return a.join("-")
        } else {
            return b.substring(this.eventPrefix.length)
        }
    },
    getDateFromDomEvent: function(b, a) {
        return this.getDateFromXY(b.getXY(), a)
    },
    getSnapPixelAmount: function() {
        return this.getTimeAxisViewModel().getSnapPixelAmount()
    },
    setSnapEnabled: function(a) {
        this.getTimeAxisViewModel().setSnapToIncrement(a)
    },
    setReadOnly: function(a) {
        this.readOnly = a;
        this[a ? "addCls": "removeCls"](this._cmpCls + "-readonly")
    },
    isReadOnly: function() {
        return this.readOnly
    },
    setOrientation: function() {
        this.setMode.apply(this, arguments)
    },
    setMode: function(a) {
        this.mode = a;
        this.timeAxisViewModel.mode = a
    },
    getOrientation: function() {
        return this.getMode.apply(this, arguments)
    },
    getMode: function() {
        return this.mode
    },
    isHorizontal: function() {
        return this.getMode() === "horizontal"
    },
    isVertical: function() {
        return ! this.isHorizontal()
    },
    getDateFromXY: function(c, b, a) {
        return this[this.mode].getDateFromXY(c, b, a)
    },
    getDateFromCoordinate: function(c, b, a) {
        if (!a) {
            c = this[this.mode].translateToScheduleCoordinate(c)
        }
        return this.timeAxisViewModel.getDateFromPosition(c, b)
    },
    getDateFromX: function(a, b) {
        return this.getDateFromCoordinate(a, b)
    },
    getDateFromY: function(b, a) {
        return this.getDateFromCoordinate(b, a)
    },
    getCoordinateFromDate: function(a, b) {
        var c = this.timeAxisViewModel.getPositionFromDate(a);
        if (b === false) {
            c = this[this.mode].translateToPageCoordinate(c)
        }
        return Math.round(c)
    },
    getXFromDate: function(a, b) {
        return this.getCoordinateFromDate(a, b)
    },
    getYFromDate: function(a, b) {
        return this.getCoordinateFromDate(a, b)
    },
    getTimeSpanDistance: function(a, b) {
        return this.timeAxisViewModel.getDistanceBetweenDates(a, b)
    },
    getTimeSpanRegion: function(a, b) {
        return this[this.mode].getTimeSpanRegion(a, b)
    },
    getScheduleRegion: function(b, a) {
        return this[this.mode].getScheduleRegion(b, a)
    },
    getTableRegion: function() {
        throw "Abstract method call"
    },
    getRowNode: function(a) {
        throw "Abstract method call"
    },
    getRecordForRowNode: function(a) {
        throw "Abstract method call"
    },
    getVisibleDateRange: function() {
        return this[this.mode].getVisibleDateRange()
    },
    setColumnWidth: function(b, a) {
        this[this.mode].setColumnWidth(b, a)
    },
    findRowByChild: function(a) {
        throw "Abstract method call"
    },
    setBarMargin: function(b, a) {
        this.barMargin = b;
        if (!a) {
            this.refreshKeepingScroll()
        }
    },
    getRowHeight: function() {
        return this.timeAxisViewModel.getViewRowHeight()
    },
    setRowHeight: function(a, b) {
        this.timeAxisViewModel.setViewRowHeight(a, b)
    },
    refreshKeepingScroll: function() {
        throw "Abstract method call"
    },
    scrollVerticallyTo: function(b, a) {
        throw "Abstract method call"
    },
    scrollHorizontallyTo: function(a, b) {
        throw "Abstract method call"
    },
    getVerticalScroll: function() {
        throw "Abstract method call"
    },
    getHorizontalScroll: function() {
        throw "Abstract method call"
    },
    getEl: Ext.emptyFn,
    getSecondaryCanvasEl: function() {
        if (!this.rendered) {
            throw "Calling this method too early"
        }
        if (!this.secondaryCanvasEl) {
            this.secondaryCanvasEl = (this.scrollerEl || this.getEl()).createChild({
                cls: "sch-secondary-canvas"
            })
        }
        return this.secondaryCanvasEl
    },
    getScroll: function() {
        throw "Abstract method call"
    },
    getOuterEl: function() {
        return this.getEl()
    },
    getRowContainerEl: function() {
        return this.getEl()
    },
    getScheduleCell: function(b, a) {
        return this.getCellByPosition({
            row: b,
            column: a
        })
    },
    getScrollEventSource: function() {
        return this.getEl()
    },
    getViewportHeight: function() {
        return this.getEl().getHeight()
    },
    getViewportWidth: function() {
        return this.getEl().getWidth()
    },
    getViewportCenterDate: function() {
        var a = this.getScroll(),
        b;
        if (this.getMode() === "vertical") {
            b = [0, a.top + this.getViewportHeight() / 2]
        } else {
            b = [a.left + this.getViewportWidth() / 2, 0]
        }
        return this.getDateFromXY(b, null, true)
    },
    getDateConstraints: Ext.emptyFn
});
Ext.apply(Sch, {
    VERSION: "3.0.2"
});
Ext.define("Sch.mixin.TimelineView", {
    extend: "Sch.mixin.AbstractTimelineView",
    requires: ["Ext.tip.ToolTip", "Sch.patches.TouchScroll"],
    tip: null,
    overScheduledEventClass: "sch-event-hover",
    ScheduleBarEvents: ["mousedown", "mouseup", "click", "dblclick", "contextmenu"],
    ResourceRowEvents: ["keydown", "keyup"],
    preventOverCls: false,
    _initializeTimelineView: function() {
        this.callParent(arguments);
        this.on("destroy", this._onDestroy, this);
        this.on("afterrender", this._onAfterRender, this);
        this.panel.on("viewready", this._onViewReady, this);
        this.setMode(this.mode);
        this.enableBubble("columnwidthchange");
        this.addCls("sch-timelineview");
        if (this.readOnly) {
            this.addCls(this._cmpCls + "-readonly")
        }
        this.addCls(this._cmpCls);
        if (this.eventAnimations) {
            this.addCls("sch-animations-enabled")
        }
    },
    handleScheduleBarEvent: function(b, a) {
        this.fireEvent(this.scheduledEventName + b.type, this, this.resolveEventRecord(a), b)
    },
    handleResourceRowEvent: function(a, b) {
        this.fireEvent(this.scheduledEventName + a.type, this, this.resolveEventRecordFromResourceRow(b), a)
    },
    _onDestroy: function() {
        if (this.tip) {
            this.tip.destroy()
        }
    },
    _onViewReady: function() {
        if (this.touchScroll) {
            this.getSecondaryCanvasEl().insertBefore(this.getNodeContainer())
        }
    },
    _onAfterRender: function() {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true)
        }
        if (this.tooltipTpl) {
            if (typeof this.tooltipTpl === "string") {
                this.tooltipTpl = new Ext.XTemplate(this.tooltipTpl)
            }
            this.el.on("mousemove", this.setupTooltip, this, {
                single: true
            })
        }
        var e = this.bufferedRenderer;
        if (e) {
            this.patchBufferedRenderingPlugin(e);
            this.patchBufferedRenderingPlugin(this.lockingPartner.bufferedRenderer)
        }
        this.on("bufferedrefresh", this.onBufferedRefresh, this, {
            buffer: 10
        });
        this.setupTimeCellEvents();
        var d = this.getSecondaryCanvasEl();
        if (d.getStyle("position").toLowerCase() !== "absolute") {
            var c = Ext.Msg || window;
            c.alert("ERROR: The CSS file for the Bryntum component has not been loaded.")
        }
        var b = {
            delegate: this.eventSelector,
            scope: this
        };
        var a = {
            delegate: this.rowSelector,
            scope: this
        };
        Ext.Array.each(this.ScheduleBarEvents,
        function(f) {
            b[f] = this.handleScheduleBarEvent
        },
        this);
        Ext.Array.each(this.ResourceRowEvents,
        function(f) {
            a[f] = this.handleResourceRowEvent
        },
        this);
        this.el.on(b);
        this.el.on(a)
    },
    patchBufferedRenderingPlugin: function(c) {
        var b = this;
        var a = c.setBodyTop;
        c.setBodyTop = function(d, e) {
            var f = a.apply(this, arguments);
            b.fireEvent("bufferedrefresh", this);
            return f
        }
    },
    onBufferedRefresh: function() {
        var d = this.body.dom;
        var c = d.style;
        if (Ext.isIE9m) {
            this.getSecondaryCanvasEl().dom.style.top = this.body.dom.style.top
        } else {
            var b = c.transform || c.msTransform || c.webkitTransform;
            var a;
            if (b) {
                a = /\(-?\d+px,\s*(-?\d+px),\s*(-?\d+)px\)/.exec(b)
            }
            if (a) {
                this.getSecondaryCanvasEl().dom.style.top = b ? a[1] : d.style.top
            }
        }
    },
    setMouseOverEnabled: function(a) {
        this[a ? "mon": "mun"](this.el, {
            mouseover: this.onEventMouseOver,
            mouseout: this.onEventMouseOut,
            delegate: this.eventSelector,
            scope: this
        })
    },
    onEventMouseOver: function(c, a) {
        if (a !== this.lastItem && !this.preventOverCls) {
            this.lastItem = a;
            Ext.fly(a).addCls(this.overScheduledEventClass);
            var b = this.resolveEventRecord(a);
            if (b) {
                this.fireEvent("eventmouseenter", this, b, c)
            }
        }
    },
    onEventMouseOut: function(b, a) {
        if (this.lastItem) {
            if (!b.within(this.lastItem, true, true)) {
                Ext.fly(this.lastItem).removeCls(this.overScheduledEventClass);
                this.fireEvent("eventmouseleave", this, this.resolveEventRecord(this.lastItem), b);
                delete this.lastItem
            }
        }
    },
    highlightItem: function(b) {
        if (b) {
            var a = this;
            a.clearHighlight();
            a.highlightedItem = b;
            Ext.fly(b).addCls(a.overItemCls)
        }
    },
    setupTooltip: function() {
        var b = this,
        a = Ext.apply({
            delegate: b.eventSelector,
            target: b.el,
            anchor: "b",
            rtl: b.rtl,
            show: function() {
                Ext.ToolTip.prototype.show.apply(this, arguments);
                if (this.triggerElement && b.getMode() === "horizontal") {
                    this.setX(this.targetXY[0] - 10);
                    this.setY(Ext.fly(this.triggerElement).getY() - this.getHeight() - 10)
                }
            }
        },
        b.tipCfg);
        b.tip = new Ext.ToolTip(a);
        b.tip.on({
            beforeshow: function(e) {
                if (!e.triggerElement || !e.triggerElement.id) {
                    return false
                }
                var c = this.resolveEventRecord(e.triggerElement);
                if (!c || this.fireEvent("beforetooltipshow", this, c) === false) {
                    return false
                }
                var f = this.getDataForTooltipTpl(c, e.triggerElement),
                d;
                if (!f) {
                    return false
                }
                d = this.tooltipTpl.apply(f);
                if (!d) {
                    return false
                }
                e.update(d)
            },
            scope: this
        })
    },
    getHorizontalTimeAxisColumn: function() {
        if (!this.timeAxisColumn) {
            this.timeAxisColumn = this.headerCt.down("timeaxiscolumn");
            if (this.timeAxisColumn) {
                this.timeAxisColumn.on("destroy",
                function() {
                    this.timeAxisColumn = null
                },
                this)
            }
        }
        return this.timeAxisColumn
    },
    getDataForTooltipTpl: function(a, b) {
        return Ext.apply({
            _record: a
        },
        a.data)
    },
    refreshKeepingScroll: function() {
        Ext.suspendLayouts();
        this.saveScrollState();
        this.refresh();
        if (this.up("tablepanel[lockable=true]").lockedGridDependsOnSchedule) {
            this.lockingPartner.saveScrollState();
            this.lockingPartner.refresh();
            this.lockingPartner.restoreScrollState()
        }
        Ext.resumeLayouts(true);
        if (this.scrollState.left !== 0 || this.scrollState.top !== 0 || this.infiniteScroll) {
            this.restoreScrollState()
        }
    },
    setupTimeCellEvents: function() {
        this.mon(this.el, {
            click: this.handleScheduleEvent,
            dblclick: this.handleScheduleEvent,
            contextmenu: this.handleScheduleEvent,
            pinch: this.handleScheduleEvent,
            pinchstart: this.handleScheduleEvent,
            pinchend: this.handleScheduleEvent,
            scope: this
        })
    },
    getTableRegion: function() {
        var a = this.el.down("." + Ext.baseCSSPrefix + "grid-item-container");
        return (a || this.el).getRegion()
    },
    getRowNode: function(a) {
        return this.getNodeByRecord(a)
    },
    findRowByChild: function(a) {
        return this.findItemByChild(a)
    },
    getRecordForRowNode: function(a) {
        return this.getRecord(a)
    },
    refreshKeepingResourceScroll: function() {
        var a = this.getScroll();
        this.refresh();
        if (this.getMode() === "horizontal") {
            this.scrollVerticallyTo(a.top)
        } else {
            this.scrollHorizontallyTo(a.left)
        }
    },
    scrollHorizontallyTo: function(a, b) {
        var c = this.getEl();
        if (c) {
            if (Ext.supports.Touch) {
                this.setScrollX(a)
            } else {
                c.scrollTo("left", Math.max(0, a), b)
            }
        }
    },
    scrollVerticallyTo: function(c, a) {
        var b = this.getEl();
        if (b) {
            if (Ext.supports.Touch) {
                this.setScrollY(c)
            } else {
                b.scrollTo("top", Math.max(0, c), a)
            }
        }
    },
    getVerticalScroll: function() {
        var a = this.getEl();
        return a.getScroll().top
    },
    getHorizontalScroll: function() {
        var a = this.getEl();
        return a.getScroll().left
    },
    getScroll: function() {
        return {
            top: this.getScrollY(),
            left: this.getScrollX()
        }
    },
    handleScheduleEvent: function() {},
    scrollElementIntoView: function(c, q, g, f) {
        var a = 20,
        p = c.dom,
        l, i = c.getOffsetsTo(l = Ext.getDom(this.el || this.element)),
        b = this.getScroll(),
        e = i[0] + b.left,
        m = i[1] + b.top,
        j = m + p.offsetHeight,
        r = e + p.offsetWidth,
        n = l.clientHeight,
        h = parseInt(b.top, 10),
        s = parseInt(b.left, 10),
        o = h + n,
        k = s + l.clientWidth,
        d;
        if (f) {
            if (g) {
                g = Ext.apply({
                    listeners: {
                        afteranimate: function() {
                            Ext.fly(p).highlight()
                        }
                    }
                },
                g)
            } else {
                Ext.fly(p).highlight()
            }
        }
        if (p.offsetHeight > n || m < h) {
            d = m - a
        } else {
            if (j > o) {
                d = j - n + a
            }
        }
        if (d != null) {
            this.setScrollY(d)
        }
        if (q !== false) {
            d = null;
            if (p.offsetWidth > l.clientWidth || e < s) {
                d = e - a
            } else {
                if (r > k) {
                    d = r - l.clientWidth + a
                }
            }
            if (d != null) {
                this.setScrollX(d)
            }
        }
        return c
    },
    disableViewScroller: function(b) {
        var a = this.getScrollable();
        if (a) {
            a.setDisabled(b)
        }
    }
});
Ext.define("Sch.view.TimelineGridView", {
    extend: "Ext.grid.View",
    mixins: ["Sch.mixin.TimelineView"],
    infiniteScroll: false,
    bufferCoef: 5,
    bufferThreshold: 0.2,
    cachedScrollLeftDate: null,
    boxIsReady: false,
    ignoreNextHorizontalScroll: false,
    constructor: function(a) {
        this.callParent(arguments);
        if (this.infiniteScroll) {
            this.on("boxready", this.setupInfiniteScroll, this)
        }
        if (this.timeAxisViewModel) {
            this.relayEvents(this.timeAxisViewModel, ["columnwidthchange"])
        }
    },
    indexInStore: function(a) {
        if (a instanceof Ext.data.Model) {
            return this.indexOf(a)
        } else {
            return this.indexOf(this.getRecord(a))
        }
    },
    setupInfiniteScroll: function() {
        var b = this.panel.ownerCt;
        this.cachedScrollLeftDate = b.startDate || this.timeAxis.getStart();
        var a = this;
        b.calculateOptimalDateRange = function(d, c, g, e) {
            if (e) {
                return e
            }
            var f = Sch.preset.Manager.getPreset(g.preset);
            return a.calculateInfiniteScrollingDateRange(d, f.getBottomHeader().unit, g.increment, g.width)
        };
        if (this.scrollManager) {
            this.scrollManager.scroller.on("scroll", this.onHorizontalScroll, this)
        } else {
            this.el.on("scroll", this.onHorizontalScroll, this)
        }
        this.on("resize", this.onSelfResize, this)
    },
    onHorizontalScroll: function() {
        if (this.ignoreNextHorizontalScroll || this.cachedScrollLeftDate) {
            this.ignoreNextHorizontalScroll = false;
            return
        }
        var e = this.el.dom,
        c = this.getWidth(),
        d = this.getScroll().left,
        b = this.scrollManager ? this.scrollManager.scroller.getMaxPosition().x: e.scrollWidth,
        a = c * this.bufferThreshold * this.bufferCoef;
        if ((b - d - c < a) || d < a) {
            this.shiftToDate(this.getDateFromCoordinate(d, null, true));
            this.el.stopAnimation()
        }
    },
    refresh: function() {
        this.callParent(arguments);
        if (this.infiniteScroll && !this.scrollStateSaved && this.boxIsReady) {
            this.restoreScrollLeftDate()
        }
    },
    onSelfResize: function(c, d, a, b, e) {
        this.boxIsReady = true;
        if (d !== b) {
            this.shiftToDate(this.cachedScrollLeftDate || this.getVisibleDateRange().startDate, this.cachedScrollCentered)
        }
    },
    restoreScrollLeftDate: function() {
        if (this.cachedScrollLeftDate && this.boxIsReady) {
            this.ignoreNextHorizontalScroll = true;
            this.scrollToDate(this.cachedScrollLeftDate);
            this.cachedScrollLeftDate = null
        }
    },
    scrollToDate: function(a) {
        this.cachedScrollLeftDate = a;
        if (this.cachedScrollCentered) {
            this.panel.ownerCt.scrollToDateCentered(a)
        } else {
            this.panel.ownerCt.scrollToDate(a)
        }
        var b = this.getScroll().left;
        this.panel.scrollLeftPos = b;
        this.headerCt.el.dom.scrollLeft = b
    },
    saveScrollState: function() {
        this.scrollStateSaved = this.boxIsReady;
        this.callParent(arguments)
    },
    restoreScrollState: function() {
        this.scrollStateSaved = false;
        if (this.infiniteScroll && this.cachedScrollLeftDate) {
            this.restoreScrollLeftDate();
            this.el.dom.scrollTop = this.scrollState.top;
            return
        }
        this.callParent(arguments)
    },
    calculateInfiniteScrollingDateRange: function(e, f, b, a) {
        var g = this.timeAxis;
        var d = this.getWidth();
        a = a || this.timeAxisViewModel.getTickWidth();
        b = b || g.increment || 1;
        f = f || g.unit;
        var h = Sch.util.Date;
        var c = Math.ceil(d * this.bufferCoef / a);
        return {
            start: g.floorDate(h.add(e, f, -c * b), false, f, b),
            end: g.ceilDate(h.add(e, f, Math.ceil((d / a + c) * b)), false, f, b)
        }
    },
    shiftToDate: function(c, b) {
        var a = this.calculateInfiniteScrollingDateRange(c);
        this.cachedScrollLeftDate = c;
        this.cachedScrollCentered = b;
        this.timeAxis.setTimeSpan(a.start, a.end)
    },
    destroy: function() {
        if (this.infiniteScroll && this.rendered) {
            this.el.un("scroll", this.onHorizontalScroll, this)
        }
        this.callParent(arguments)
    }
});
Ext.define("Sch.mixin.FilterableTreeView", {
    prevBlockRefresh: null,
    initTreeFiltering: function() {
        var a = function() {
            var b = this.store;
            this.mon(b, "nodestore-datachange-start", this.onFilterChangeStart, this);
            this.mon(b, "nodestore-datachange-end", this.onFilterChangeEnd, this);
            if (!b.allowExpandCollapseWhileFiltered) {
                this.mon(b, "filter-clear", this.onFilterCleared, this);
                this.mon(b, "filter-set", this.onFilterSet, this)
            }
        };
        if (this.rendered) {
            a.call(this)
        } else {
            this.on("beforerender", a, this, {
                single: true
            })
        }
    },
    onFilterChangeStart: function() {
        this.prevBlockRefresh = this.blockRefresh;
        this.blockRefresh = true;
        Ext.suspendLayouts()
    },
    onFilterChangeEnd: function() {
        Ext.resumeLayouts(true);
        this.blockRefresh = this.prevBlockRefresh
    },
    onFilterCleared: function() {
        delete this.toggle;
        var a = this.getEl();
        if (a) {
            a.removeCls("sch-tree-filtered")
        }
    },
    onFilterSet: function() {
        this.toggle = function() {};
        var a = this.getEl();
        if (a) {
            a.addCls("sch-tree-filtered")
        }
    }
});
Ext.define("Sch.mixin.Zoomable", {
    zoomLevels: [{
        width: 40,
        increment: 1,
        resolution: 1,
        preset: "manyYears",
        resolutionUnit: "YEAR"
    },
    {
        width: 80,
        increment: 1,
        resolution: 1,
        preset: "manyYears",
        resolutionUnit: "YEAR"
    },
    {
        width: 30,
        increment: 1,
        resolution: 1,
        preset: "year",
        resolutionUnit: "MONTH"
    },
    {
        width: 50,
        increment: 1,
        resolution: 1,
        preset: "year",
        resolutionUnit: "MONTH"
    },
    {
        width: 100,
        increment: 1,
        resolution: 1,
        preset: "year",
        resolutionUnit: "MONTH"
    },
    {
        width: 200,
        increment: 1,
        resolution: 1,
        preset: "year",
        resolutionUnit: "MONTH"
    },
    {
        width: 100,
        increment: 1,
        resolution: 7,
        preset: "monthAndYear",
        resolutionUnit: "DAY"
    },
    {
        width: 30,
        increment: 1,
        resolution: 1,
        preset: "weekDateAndMonth",
        resolutionUnit: "DAY"
    },
    {
        width: 35,
        increment: 1,
        resolution: 1,
        preset: "weekAndMonth",
        resolutionUnit: "DAY"
    },
    {
        width: 50,
        increment: 1,
        resolution: 1,
        preset: "weekAndMonth",
        resolutionUnit: "DAY"
    },
    {
        width: 20,
        increment: 1,
        resolution: 1,
        preset: "weekAndDayLetter"
    },
    {
        width: 50,
        increment: 1,
        resolution: 1,
        preset: "weekAndDay",
        resolutionUnit: "HOUR"
    },
    {
        width: 100,
        increment: 1,
        resolution: 1,
        preset: "weekAndDay",
        resolutionUnit: "HOUR"
    },
    {
        width: 50,
        increment: 6,
        resolution: 30,
        preset: "hourAndDay",
        resolutionUnit: "MINUTE"
    },
    {
        width: 100,
        increment: 6,
        resolution: 30,
        preset: "hourAndDay",
        resolutionUnit: "MINUTE"
    },
    {
        width: 60,
        increment: 2,
        resolution: 30,
        preset: "hourAndDay",
        resolutionUnit: "MINUTE"
    },
    {
        width: 60,
        increment: 1,
        resolution: 30,
        preset: "hourAndDay",
        resolutionUnit: "MINUTE"
    },
    {
        width: 30,
        increment: 15,
        resolution: 5,
        preset: "minuteAndHour"
    },
    {
        width: 60,
        increment: 15,
        resolution: 5,
        preset: "minuteAndHour"
    },
    {
        width: 130,
        increment: 15,
        resolution: 5,
        preset: "minuteAndHour"
    },
    {
        width: 60,
        increment: 5,
        resolution: 5,
        preset: "minuteAndHour"
    },
    {
        width: 100,
        increment: 5,
        resolution: 5,
        preset: "minuteAndHour"
    },
    {
        width: 50,
        increment: 2,
        resolution: 1,
        preset: "minuteAndHour"
    },
    {
        width: 30,
        increment: 10,
        resolution: 5,
        preset: "secondAndMinute"
    },
    {
        width: 60,
        increment: 10,
        resolution: 5,
        preset: "secondAndMinute"
    },
    {
        width: 130,
        increment: 5,
        resolution: 5,
        preset: "secondAndMinute"
    }],
    minZoomLevel: null,
    maxZoomLevel: null,
    visibleZoomFactor: 5,
    zoomKeepsOriginalTimespan: false,
    cachedCenterDate: null,
    isFirstZoom: true,
    isZooming: false,
    initializeZooming: function() {
        this.zoomLevels = this.zoomLevels.slice();
        this.setMinZoomLevel(this.minZoomLevel || 0);
        this.setMaxZoomLevel(this.maxZoomLevel !== null ? this.maxZoomLevel: this.zoomLevels.length - 1);
        this.on("viewchange", this.clearCenterDateCache, this)
    },
    getZoomLevelUnit: function(a) {
        return Sch.preset.Manager.getPreset(a.preset).getBottomHeader().unit
    },
    getMilliSecondsPerPixelForZoomLevel: function(c, a) {
        var b = Sch.util.Date;
        return Math.round((b.add(new Date(1, 0, 1), this.getZoomLevelUnit(c), c.increment) - new Date(1, 0, 1)) / (a ? c.width: c.actualWidth || c.width))
    },
    presetToZoomLevel: function(b) {
        var a = Sch.preset.Manager.getPreset(b);
        return {
            preset: b,
            increment: a.getBottomHeader().increment || 1,
            resolution: a.timeResolution.increment,
            resolutionUnit: a.timeResolution.unit,
            width: a.timeColumnWidth
        }
    },
    zoomLevelToPreset: function(c) {
        var b = Sch.preset.Manager.getPreset(c.preset).clone();
        var a = b.getBottomHeader();
        a.increment = c.increment;
        b.timeColumnWidth = c.width;
        if (c.resolutionUnit || c.resolution) {
            b.timeResolution = {
                unit: c.resolutionUnit || b.timeResolution.unit || a.unit,
                increment: c.resolution || b.timeResolution.increment || 1
            }
        }
        return b
    },
    calculateCurrentZoomLevel: function() {
        var g = this.presetToZoomLevel(this.viewPreset),
        d = Number.MAX_VALUE,
        b = this.timeAxisViewModel,
        f = b.timeColumnWidth;
        g.width = f;
        g.increment = b.getBottomHeader().increment || 1;
        for (var c = 0,
        a = this.zoomLevels.length; c < a; c++) {
            var e = this.zoomLevels[c];
            if (e.preset !== g.preset) {
                continue
            }
            var h = Math.abs(e.width - f);
            if (h < d) {
                d = h;
                g.actualWidth = e.actualWidth;
                g.width = e.width
            }
        }
        return g
    },
    getCurrentZoomLevelIndex: function() {
        var f = this.calculateCurrentZoomLevel();
        var b = this.getMilliSecondsPerPixelForZoomLevel(f);
        var e = this.zoomLevels;
        for (var c = 0; c < e.length; c++) {
            var d = this.getMilliSecondsPerPixelForZoomLevel(e[c]);
            if (d == b) {
                return c
            }
            if (c === 0 && b > d) {
                return - 0.5
            }
            if (c == e.length - 1 && b < d) {
                return e.length - 1 + 0.5
            }
            var a = this.getMilliSecondsPerPixelForZoomLevel(e[c + 1]);
            if (d > b && b > a) {
                return c + 0.5
            }
        }
        throw "Can't find current zoom level index"
    },
    setMaxZoomLevel: function(a) {
        if (a < 0 || a >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`")
        }
        this.maxZoomLevel = a
    },
    setMinZoomLevel: function(a) {
        if (a < 0 || a >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`")
        }
        this.minZoomLevel = a
    },
    getViewportCenterDateCached: function() {
        if (this.cachedCenterDate) {
            return this.cachedCenterDate
        }
        return this.cachedCenterDate = this.getViewportCenterDate()
    },
    clearCenterDateCache: function() {
        this.cachedCenterDate = null
    },
    zoomToLevel: function(b, r, e) {
        b = Ext.Number.constrain(b, this.minZoomLevel, this.maxZoomLevel);
        e = e || {};
        var q = this.calculateCurrentZoomLevel();
        var d = this.getMilliSecondsPerPixelForZoomLevel(q);
        var l = this.zoomLevels[b];
        var a = this.getMilliSecondsPerPixelForZoomLevel(l);
        if (d == a && !r) {
            return null
        }
        var t = this;
        var m = this.getSchedulingView();
        var h = m.getOuterEl();
        var s = m.getScrollEventSource();
        var i = this.mode == "vertical";
        var g = r ? new Date((r.start.getTime() + r.end.getTime()) / 2) : this.getViewportCenterDateCached();
        var n = i ? h.getHeight() : h.getWidth();
        var o = Sch.preset.Manager.getPreset(l.preset).clone();
        var p = o.getBottomHeader();
        var f = Boolean(r);
        r = this.calculateOptimalDateRange(g, n, l, r);
        o[i ? "timeRowHeight": "timeColumnWidth"] = e.customWidth || l.width;
        p.increment = l.increment;
        this.isZooming = true;
        this.viewPreset = l.preset;
        var c = this.timeAxis;
        o.increment = l.increment;
        o.timeResolution.unit = Sch.util.Date.getUnitByName(l.resolutionUnit || o.timeResolution.unit || p.unit);
        o.timeResolution.increment = l.resolution;
        this.setViewPreset(o, r.start || this.getStart(), r.end || this.getEnd(), false, true);
        l.actualWidth = this.timeAxisViewModel.getTickWidth();
        if (f) {
            g = e.centerDate || new Date((c.getStart().getTime() + c.getEnd().getTime()) / 2)
        }
        if (i) {
            var j = m.getYFromDate(g, true) - n / 2;
            s.on("scroll",
            function() {
                t.cachedCenterDate = g;
                m.scrollVerticallyTo(j)
            },
            this, {
                single: true
            });
            m.scrollVerticallyTo(j - 1);
            m.scrollVerticallyTo(j)
        } else {
            var k = m.getXFromDate(g, true) - n / 2;
            s.on("scroll",
            function() {
                t.cachedCenterDate = g;
                m.scrollHorizontallyTo(k)
            },
            this, {
                single: true
            });
            m.scrollHorizontallyTo(k - 1);
            m.scrollHorizontallyTo(k)
        }
        t.isZooming = false;
        this.fireEvent("zoomchange", this, b);
        return b
    },
    setZoomLevel: function() {
        this.zoomToLevel.apply(this, arguments)
    },
    zoomToSpan: function(p, s) {
        if (p.start && p.end && p.start < p.end) {
            s = s || {};
            if (s.leftMargin || s.rightMargin) {
                s.adjustStart = 0;
                s.adjustEnd = 0
            }
            Ext.applyIf(s, {
                leftMargin: 0,
                rightMargin: 0
            });
            var g = p.start,
            d = p.end,
            e = s.adjustStart >= 0 && s.adjustEnd >= 0;
            if (e) {
                g = Sch.util.Date.add(g, this.timeAxis.mainUnit, -s.adjustStart);
                d = Sch.util.Date.add(d, this.timeAxis.mainUnit, s.adjustEnd)
            }
            var a = this.getSchedulingView().getTimeAxisViewModel().getAvailableWidth();
            var m = Math.floor(this.getCurrentZoomLevelIndex());
            if (m == -1) {
                m = 0
            }
            var t = this.zoomLevels;
            var b = d - g,
            j = this.getMilliSecondsPerPixelForZoomLevel(t[m], true),
            l = b / j + s.leftMargin + s.rightMargin > a ? -1 : 1,
            f = m + l;
            var o, h = null;
            while (f >= 0 && f <= t.length - 1) {
                o = t[f];
                j = this.getMilliSecondsPerPixelForZoomLevel(o, true);
                var q = b / j + s.leftMargin + s.rightMargin;
                if (l == -1) {
                    if (q <= a) {
                        h = f;
                        break
                    }
                } else {
                    if (q <= a) {
                        if (m !== f - l) {
                            h = f
                        }
                    } else {
                        break
                    }
                }
                f += l
            }
            h = h !== null ? h: f - l;
            o = t[h];
            var c = Sch.preset.Manager.getPreset(o.preset).getBottomHeader().unit;
            if (s.leftMargin || s.rightMargin) {
                g = new Date(g.getTime() - j * s.leftMargin);
                d = new Date(d.getTime() + j * s.rightMargin)
            }
            var r = Sch.util.Date.getDurationInUnit(g, d, c, true) / o.increment;
            if (r === 0) {
                return
            }
            var i = Math.floor(a / r);
            var k = new Date((g.getTime() + d.getTime()) / 2);
            var n;
            if (e) {
                n = {
                    start: g,
                    end: d
                }
            } else {
                n = this.calculateOptimalDateRange(k, a, o)
            }
            return this.zoomToLevel(h, n, {
                customWidth: i,
                centerDate: k
            })
        }
        return null
    },
    zoomIn: function(a) {
        a = a || 1;
        var b = this.getCurrentZoomLevelIndex();
        if (b >= this.zoomLevels.length - 1) {
            return null
        }
        return this.zoomToLevel(Math.floor(b) + a)
    },
    zoomOut: function(a) {
        a = a || 1;
        var b = this.getCurrentZoomLevelIndex();
        if (b <= 0) {
            return null
        }
        return this.zoomToLevel(Math.ceil(b) - a)
    },
    zoomInFull: function() {
        return this.zoomToLevel(this.maxZoomLevel)
    },
    zoomOutFull: function() {
        return this.zoomToLevel(this.minZoomLevel)
    },
    calculateOptimalDateRange: function(c, h, e, j) {
        if (j) {
            return j
        }
        var g = this.timeAxis;
        if (this.zoomKeepsOriginalTimespan) {
            return {
                start: g.getStart(),
                end: g.getEnd()
            }
        }
        var b = Sch.util.Date;
        var i = this.getZoomLevelUnit(e);
        var d = Math.ceil(h / e.width * e.increment * this.visibleZoomFactor / 2);
        var a = b.add(c, i, -d);
        var f = b.add(c, i, d);
        return {
            start: g.floorDate(a, false, i, e.increment),
            end: g.ceilDate(f, false, i, e.increment)
        }
    }
});
Ext.define("Sch.mixin.AbstractTimelinePanel", {
    requires: ["Sch.data.TimeAxis", "Sch.view.model.TimeAxis", "Sch.feature.ColumnLines", "Sch.preset.Manager"],
    mixins: ["Sch.mixin.Zoomable"],
    orientation: "horizontal",
    weekStartDay: 1,
    snapToIncrement: false,
    readOnly: false,
    forceFit: false,
    eventResizeHandles: "both",
    timeAxis: null,
    autoAdjustTimeAxis: true,
    timeAxisViewModel: null,
    crudManager: null,
    viewPreset: "weekAndDay",
    calendarViewPreset: "week",
    trackHeaderOver: true,
    startDate: null,
    endDate: null,
    columnLines: true,
    getDateConstraints: Ext.emptyFn,
    snapRelativeToEventStartDate: false,
    trackMouseOver: false,
    readRowHeightFromPreset: true,
    eventBorderWidth: 1,
    getOrientation: function() {
        return this.getMode.apply(this, arguments)
    },
    getMode: function() {
        return this.mode
    },
    isHorizontal: function() {
        return this.getMode() === "horizontal"
    },
    isVertical: function() {
        return ! this.isHorizontal()
    },
    cellBorderWidth: 1,
    cellTopBorderWidth: 1,
    cellBottomBorderWidth: 1,
    renderers: null,
    _initializeTimelinePanel: function() {
        this.mode = this.mode || this.orientation || "horizontal";
        if (this.mode === "calendar") {
            this.oldViewPreset = this.viewPreset;
            this.viewPreset = this.calendarViewPreset
        }
        var c = this.viewPreset && Sch.preset.Manager.getPreset(this.viewPreset);
        if (!c) {
            throw "You must define a valid view preset object. See Sch.preset.Manager class for reference"
        }
        this.initializeZooming();
        this.renderers = [];
        if (this.readRowHeightFromPreset) {
            this.readRowHeightFromPreset = !this.rowHeight
        }
        if (!this.timeAxis) {
            this.timeAxis = new Sch.data.TimeAxis({
                autoAdjust: this.autoAdjustTimeAxis,
                mode: this.mode === "calendar" ? "calendar": "plain"
            })
        }
        if (!this.timeAxisViewModel || !(this.timeAxisViewModel instanceof Sch.view.model.TimeAxis)) {
            var a = Ext.apply({
                mode: this.mode,
                snapToIncrement: this.snapToIncrement,
                forceFit: this.forceFit,
                timeAxis: this.timeAxis,
                eventStore: this.getEventStore(),
                viewPreset: this.viewPreset
            },
            this.timeAxisViewModel || {});
            this.timeAxisViewModel = new Sch.view.model.TimeAxis(a)
        }
        this.timeAxisViewModel.on("update", this.onTimeAxisViewModelUpdate, this);
        this.timeAxisViewModel.refCount++;
        this.on("destroy", this.onPanelDestroyed, this);
        var b;
        switch (this.mode) {
        case "horizontal":
            b = ["sch-horizontal"];
            break;
        case "vertical":
            b = ["sch-vertical", "sch-vertical-resource"];
            break;
        case "calendar":
            b = ["sch-vertical", "sch-calendar"];
            break
        }
        this.addCls([].concat.apply(["sch-timelinepanel"], b))
    },
    onTimeAxisViewModelUpdate: function() {
        var a = this.getSchedulingView();
        if (a && a.viewReady) {
            a.refreshKeepingScroll();
            this.fireEvent("viewchange", this)
        }
    },
    onPanelDestroyed: function() {
        var a = this.timeAxisViewModel;
        a.un("update", this.onTimeAxisViewModelUpdate, this);
        a.refCount--;
        if (a.refCount <= 0) {
            a.destroy()
        }
    },
    getSchedulingView: function() {
        throw "Abstract method call"
    },
    setReadOnly: function(a) {
        this.getSchedulingView().setReadOnly(a)
    },
    isReadOnly: function() {
        return this.getSchedulingView().isReadOnly()
    },
    switchViewPreset: function() {
        this.setViewPreset.apply(this, arguments)
    },
    setViewPreset: function(i, a, d, f, b) {
        var e = this.timeAxis;
        if (this.fireEvent("beforeviewchange", this, i, a, d) !== false) {
            var h = this.getMode() === "horizontal";
            if (Ext.isString(i)) {
                this.viewPreset = i;
                i = Sch.preset.Manager.getPreset(i)
            }
            if (!i) {
                throw "View preset not found"
            }
            if (! (f && e.isConfigured)) {
                var c = {
                    weekStartDay: this.weekStartDay
                };
                if (f) {
                    if (e.getCount() === 0 || a) {
                        c.start = a || new Date()
                    }
                } else {
                    c.start = a || e.getStart()
                }
                c.end = d;
                e.consumeViewPreset(i);
                e.reconfigure(c, true);
                this.timeAxisViewModel.reconfigure({
                    headerConfig: i.headerConfig,
                    columnLinesFor: i.columnLinesFor || "middle",
                    rowHeightHorizontal: this.readRowHeightFromPreset ? i.rowHeight: (this.rowHeight || this.timeAxisViewModel.getViewRowHeight()),
                    tickWidth: h ? i.timeColumnWidth: i.timeRowHeight || i.timeColumnWidth || 60,
                    timeColumnWidth: i.timeColumnWidth,
                    rowHeightVertical: i.timeRowHeight || i.timeColumnWidth || 60,
                    timeAxisColumnWidth: i.timeAxisColumnWidth,
                    resourceColumnWidth: this.resourceColumnWidth || i.resourceColumnWidth || 100
                })
            }
            var g = this.getSchedulingView();
            g.setDisplayDateFormat(i.displayDateFormat);
            if (this.getMode() === "vertical") {
                g.setColumnWidth(this.resourceColumnWidth || i.resourceColumnWidth || 100, true)
            }
            if (!b) {
                if (h) {
                    g.scrollHorizontallyTo(0)
                } else {
                    g.scrollVerticallyTo(0)
                }
            }
        }
    },
    getViewPreset: function() {
        return this.viewPreset
    },
    getStart: function() {
        return this.getStartDate()
    },
    getStartDate: function() {
        return this.timeAxis.getStart()
    },
    getEnd: function() {
        return this.getEndDate()
    },
    getEndDate: function() {
        return this.timeAxis.getEnd()
    },
    setTimeColumnWidth: function(b, a) {
        this.timeAxisViewModel.setTickWidth(b, a)
    },
    getTimeColumnWidth: function() {
        return this.timeAxisViewModel.getTickWidth()
    },
    getRowHeight: function() {
        return this.timeAxisViewModel.getViewRowHeight()
    },
    shiftNext: function(a) {
        this.suspendLayouts && this.suspendLayouts();
        this.timeAxis.shiftNext(a);
        this.suspendLayouts && this.resumeLayouts(true)
    },
    shiftPrevious: function(a) {
        this.suspendLayouts && this.suspendLayouts();
        this.timeAxis.shiftPrevious(a);
        this.suspendLayouts && this.resumeLayouts(true)
    },
    goToNow: function() {
        this.setTimeSpan(new Date())
    },
    setTimeSpan: function(b, a) {
        if (this.timeAxis) {
            this.timeAxis.setTimeSpan(b, a)
        }
    },
    setStart: function(a) {
        this.setTimeSpan(a)
    },
    setEnd: function(a) {
        this.setTimeSpan(null, a)
    },
    getTimeAxis: function() {
        return this.timeAxis
    },
    scrollToDate: function(c, b) {
        var a = this.getSchedulingView();
        var d = a.getCoordinateFromDate(c, true);
        this.scrollToCoordinate(d, c, b, false)
    },
    scrollToDateCentered: function(c, b) {
        var a = this.getSchedulingView();
        var e = 0;
        if (this.mode === "horizontal") {
            e = a.getBox().width / 2
        } else {
            e = a.getBox().height / 2
        }
        var d = Math.round(a.getCoordinateFromDate(c, true) - e);
        this.scrollToCoordinate(d, c, b, true)
    },
    scrollToCoordinate: function(g, e, d, c) {
        var b = this.getSchedulingView();
        var f = this;
        if (g < 0) {
            if (this.infiniteScroll) {
                b.shiftToDate(e, c)
            } else {
                var a = (this.timeAxis.getEnd() - this.timeAxis.getStart()) / 2;
                this.setTimeSpan(new Date(e.getTime() - a), new Date(e.getTime() + a));
                if (c) {
                    f.scrollToDateCentered(e, d)
                } else {
                    f.scrollToDate(e, d)
                }
            }
            return
        }
        if (this.mode === "horizontal") {
            b.scrollHorizontallyTo(g, d)
        } else {
            b.scrollVerticallyTo(g, d)
        }
        b.fireEvent("scroll", this, g)
    },
    getViewportCenterDate: function() {
        return this.getSchedulingView().getViewportCenterDate()
    },
    addCls: function() {
        throw "Abstract method call"
    },
    removeCls: function() {
        throw "Abstract method call"
    },
    registerRenderer: function(b, a) {
        this.renderers.push({
            fn: b,
            scope: a
        })
    },
    deregisterRenderer: function(b, a) {
        Ext.each(this.renderers,
        function(c, d) {
            if (b === c) {
                Ext.Array.removeAt(this.renderers, d);
                return false
            }
        })
    }
});
if (!Ext.ClassManager.get("Sch.mixin.TimelinePanel")) {
    Ext.define("Sch.mixin.TimelinePanel", {
        extend: "Sch.mixin.AbstractTimelinePanel",
        requires: ["Sch.util.Patch", "Sch.column.timeAxis.Horizontal", "Sch.preset.Manager", "Sch.patches.NodeCache", "Sch.patches.BufferedRenderer", "Sch.patches.RowSynchronizer"],
        mixins: ["Sch.mixin.Zoomable"],
        bufferCoef: 5,
        bufferThreshold: 0.2,
        infiniteScroll: false,
        showCrudManagerMask: true,
        waitingForAutoTimeSpan: false,
        columnLinesFeature: null,
        renderWaitListener: null,
        schedulePinchThreshold: 30,
        pinchStartDistanceX: null,
        pinchStartDistanceY: null,
        pinchDistanceX: null,
        pinchDistanceY: null,
        tipCfg: {
            cls: "sch-tip",
            showDelay: 1000,
            hideDelay: 0,
            autoHide: true,
            anchor: "b"
        },
        inheritables: function() {
            return {
                columnLines: true,
                enableLocking: true,
                lockable: true,
                stateEvents: ["viewchange"],
                syncRowHeight: false,
                cellTopBorderWidth: 0,
                constructor: function(a) {
                    a = a || {};
                    if (this.layout === "border") {
                        a.layout = "border"
                    }
                    this.callParent([a])
                },
                initComponent: function() {
                    if (this.partnerTimelinePanel) {
                        this.timeAxisViewModel = this.partnerTimelinePanel.timeAxisViewModel;
                        this.timeAxis = this.partnerTimelinePanel.getTimeAxis();
                        this.startDate = this.timeAxis.getStart();
                        this.endDate = this.timeAxis.getEnd()
                    }
                    this._initializeTimelinePanel();
                    this.configureChildGrids();
                    this.forceFit = false;
                    this.configureColumns();
                    var c = this.normalViewConfig = this.normalViewConfig || {};
                    var d = this.getId();
                    Ext.apply(this.normalViewConfig, {
                        id: d + "-timelineview",
                        eventPrefix: this.autoGenId ? null: d,
                        timeAxisViewModel: this.timeAxisViewModel,
                        eventBorderWidth: this.eventBorderWidth,
                        timeAxis: this.timeAxis,
                        readOnly: this.readOnly,
                        mode: this.mode,
                        rtl: this.rtl,
                        cellBorderWidth: this.cellBorderWidth,
                        cellTopBorderWidth: this.cellTopBorderWidth,
                        cellBottomBorderWidth: this.cellBottomBorderWidth,
                        infiniteScroll: this.infiniteScroll,
                        bufferCoef: this.bufferCoef,
                        bufferThreshold: this.bufferThreshold
                    });
                    Ext.Array.forEach(["eventRendererScope", "eventRenderer", "dndValidatorFn", "resizeValidatorFn", "createValidatorFn", "tooltipTpl", "validatorFnScope", "eventResizeHandles", "enableEventDragDrop", "enableDragCreation", "resizeConfig", "createConfig", "tipCfg", "getDateConstraints"],
                    function(e) {
                        if (e in this) {
                            c[e] = this[e]
                        }
                    },
                    this);
                    this.callParent(arguments);
                    this.patchNavigationModel(this);
                    this.setViewPreset(this.viewPreset, this.startDate || this.timeAxis.getStart(), this.endDate || this.timeAxis.getEnd(), true);
                    if (!this.startDate) {
                        var a = this.getTimeSpanDefiningStore();
                        if (Ext.data.TreeStore && a instanceof Ext.data.TreeStore ? a.getRootNode().childNodes.length: a.getCount()) {
                            this.applyStartEndDatesFromStore()
                        } else {
                            this.bindAutoTimeSpanListeners()
                        }
                    }
                    var b = this.columnLines;
                    if (b) {
                        this.columnLinesFeature = new Sch.feature.ColumnLines(Ext.isObject(b) ? b: undefined);
                        this.columnLinesFeature.init(this);
                        this.columnLines = true
                    }
                    this.relayEvents(this.getSchedulingView(), ["beforetooltipshow", "scheduleclick", "scheduledblclick", "schedulecontextmenu", "schedulepinch", "schedulepinchstart", "schedulepinchend"]);
                    this.on("boxready", this.__onBoxReady, this);
                    this.on("zoomchange",
                    function() {
                        this.normalGrid.scrollTask.cancel()
                    });
                    if (this.crudManager && !this.crudManager.autoSync && this.showCrudManagerMask) {
                        this.mon(this.crudManager, {
                            beforesend: this.beforeCrudOperationStart,
                            synccanceled: this.onCrudOperationComplete,
                            loadcanceled: this.onCrudOperationComplete,
                            load: this.onCrudOperationComplete,
                            sync: this.onCrudOperationComplete,
                            loadfail: this.onCrudOperationComplete,
                            syncfail: this.onCrudOperationComplete,
                            scope: this
                        });
                        if (this.crudManager.isLoading()) {
                            this.beforeCrudOperationStart(this.crudManager, null, "load")
                        }
                    }
                    this.afterInitComponent()
                },
                getState: function() {
                    var a = this,
                    b = a.callParent(arguments);
                    Ext.apply(b, {
                        viewPreset: a.viewPreset,
                        startDate: a.getStart(),
                        endDate: a.getEnd(),
                        zoomMinLevel: a.zoomMinLevel,
                        zoomMaxLevel: a.zoomMaxLevel,
                        currentZoomLevel: a.currentZoomLevel
                    });
                    return b
                },
                applyState: function(b) {
                    var a = this;
                    a.callParent(arguments);
                    if (b && b.viewPreset) {
                        a.setViewPreset(b.viewPreset, b.startDate, b.endDate)
                    }
                    if (b && b.currentZoomLevel) {
                        a.zoomToLevel(b.currentZoomLevel)
                    }
                },
                setTimeSpan: function() {
                    if (this.waitingForAutoTimeSpan) {
                        this.unbindAutoTimeSpanListeners()
                    }
                    this.callParent(arguments);
                    if (!this.normalGrid.getView().viewReady) {
                        this.getView().refresh()
                    }
                }
            }
        },
        bindAutoTimeSpanListeners: function() {
            var a = this.getTimeSpanDefiningStore();
            this.waitingForAutoTimeSpan = true;
            this.normalGrid.getView().on("beforerefresh", this.refreshStopper, this);
            this.lockedGrid.getView().on("beforerefresh", this.refreshStopper, this);
            this.mon(a, "load", this.applyStartEndDatesFromStore, this);
            if (Ext.data.TreeStore && a instanceof Ext.data.TreeStore) {
                this.mon(a, "rootchange", this.applyStartEndDatesFromStore, this);
                this.mon(a, "nodeappend", this.applyStartEndDatesAfterTreeAppend, this)
            } else {
                this.mon(a, "add", this.applyStartEndDatesFromStore, this)
            }
        },
        refreshStopper: function(a) {
            return a.store.getCount() === 0
        },
        getTimeSpanDefiningStore: function() {
            throw "Abstract method called"
        },
        unbindAutoTimeSpanListeners: function() {
            this.waitingForAutoTimeSpan = false;
            var a = this.getTimeSpanDefiningStore();
            this.normalGrid.getView().un("beforerefresh", this.refreshStopper, this);
            this.lockedGrid.getView().un("beforerefresh", this.refreshStopper, this);
            a.un("load", this.applyStartEndDatesFromStore, this);
            if (Ext.data.TreeStore && a instanceof Ext.data.TreeStore) {
                a.un("rootchange", this.applyStartEndDatesFromStore, this);
                a.un("nodeappend", this.applyStartEndDatesAfterTreeAppend, this)
            } else {
                a.un("add", this.applyStartEndDatesFromStore, this)
            }
        },
        applyStartEndDatesAfterTreeAppend: function() {
            var a = this.getTimeSpanDefiningStore();
            if (!a.isSettingRoot && !a.__loading) {
                this.applyStartEndDatesFromStore()
            }
        },
        applyStartEndDatesFromStore: function() {
            var a = this.getTimeSpanDefiningStore();
            var b = a.getTotalTimeSpan();
            var c = this.lockedGridDependsOnSchedule;
            if (b.end && b.start && b.end - b.start === 0) {
                b.start = Sch.util.Date.add(b.start, this.timeAxis.mainUnit, -1);
                b.end = Sch.util.Date.add(b.end, this.timeAxis.mainUnit, 1)
            }
            this.lockedGridDependsOnSchedule = true;
            this.setTimeSpan(b.start || new Date(), b.end);
            this.lockedGridDependsOnSchedule = c
        },
        onLockedGridItemDblClick: function(b, a, c, e, d) {
            if (this.mode === "vertical" && a) {
                this.fireEvent("timeheaderdblclick", this, a.get("start"), a.get("end"), e, d)
            }
        },
        getSchedulingView: function() {
            return this.normalGrid.getView()
        },
        getHorizontalTimeAxisColumn: function() {
            return this.getSchedulingView().getHorizontalTimeAxisColumn()
        },
        configureColumns: function() {
            var a = this.columns || [];
            if (a.items) {
                a = a.items
            } else {
                a = this.columns = a.slice()
            }
            var c = [];
            var b = [];
            Ext.Array.each(a,
            function(d) {
                if (d.position === "right") {
                    if (!Ext.isNumber(d.width)) {
                        Ext.Error.raise('"Right" columns must have a fixed width')
                    }
                    d.locked = false;
                    b.push(d)
                } else {
                    d.locked = true;
                    c.push(d)
                }
                d.lockable = false
            });
            Ext.Array.erase(a, 0, a.length);
            Ext.Array.insert(a, 0, c.concat({
                xtype: "timeaxiscolumn",
                timeAxisViewModel: this.timeAxisViewModel,
                trackHeaderOver: this.trackHeaderOver,
                renderer: this.mainRenderer,
                scope: this
            }).concat(b));
            this.horizontalColumns = Ext.Array.clone(a);
            this.verticalColumns = [Ext.apply({
                xtype: "verticaltimeaxis",
                width: 100,
                timeAxis: this.timeAxis,
                timeAxisViewModel: this.timeAxisViewModel,
                cellTopBorderWidth: this.cellTopBorderWidth,
                cellBottomBorderWidth: this.cellBottomBorderWidth
            },
            this.timeAxisColumnCfg || {})];
            this.calendarColumns = [Ext.apply({
                xtype: "verticaltimeaxis",
                width: 60,
                timeAxis: this.timeAxis,
                timeAxisViewModel: this.timeAxisViewModel,
                cellTopBorderWidth: this.cellTopBorderWidth,
                cellBottomBorderWidth: this.cellBottomBorderWidth
            },
            this.calendarTimeAxisCfg || {})];
            if (this.mode === "vertical") {
                this.columns = this.verticalColumns.concat(this.createResourceColumns(this.resourceColumnWidth || this.timeAxisViewModel.resourceColumnWidth));
                this.store = this.timeAxis
            } else {
                if (this.mode === "calendar") {
                    this.columns = [];
                    this.store = null;
                    this.on("afterrender", this.refreshCalendarColumns, this)
                }
            }
        },
        mainRenderer: function(b, l, g, j, k) {
            var c = this.renderers,
            d = this.mode === "horizontal" || this.mode === "calendar" ? g: this.resourceStore.getAt(k),
            a = "&nbsp;";
            l.rowHeight = null;
            for (var e = 0; e < c.length; e++) {
                a += c[e].fn.call(c[e].scope || this, b, l, d, j, k) || ""
            }
            if (this.variableRowHeight) {
                var h = this.getSchedulingView();
                var f = this.timeAxisViewModel.getViewRowHeight();
                l.style = "height:" + ((l.rowHeight || f) - h.cellTopBorderWidth - h.cellBottomBorderWidth) + "px"
            }
            return a
        },
        __onBoxReady: function() {
            var a = this;
            a.normalGrid.on({
                collapse: a.onNormalGridCollapse,
                expand: a.onNormalGridExpand,
                scope: a
            });
            a.lockedGrid.on({
                collapse: a.onLockedGridCollapse,
                itemdblclick: a.onLockedGridItemDblClick,
                scope: a
            });
            if (a.lockedGridDependsOnSchedule) {
                a.normalGrid.getView().on("itemupdate", a.onNormalViewItemUpdate, a)
            }
            if (this.partnerTimelinePanel) {
                if (this.partnerTimelinePanel.rendered) {
                    this.setupPartnerTimelinePanel()
                } else {
                    this.partnerTimelinePanel.on("boxready", this.setupPartnerTimelinePanel, this)
                }
            }
            if (Ext.supports.Touch) {
                this.getSchedulingView().on({
                    schedulepinchstart: this.onSchedulePinchStart,
                    schedulepinch: this.onSchedulePinch,
                    schedulepinchend: this.onSchedulePinchEnd,
                    scope: this
                })
            }
        },
        onLockedGridCollapse: function() {
            if (this.normalGrid.collapsed) {
                this.normalGrid.expand()
            }
        },
        onNormalGridCollapse: function() {
            var a = this;
            if (!a.normalGrid.reExpander) {
                a.normalGrid.reExpander = a.normalGrid.placeholder
            }
            if (!a.lockedGrid.rendered) {
                a.lockedGrid.on("render", a.onNormalGridCollapse, a, {
                    delay: 1
                })
            } else {
                a.lockedGrid.flex = 1;
                a.lockedGrid.updateLayout();
                if (a.lockedGrid.collapsed) {
                    a.lockedGrid.expand()
                }
                a.addCls("sch-normalgrid-collapsed")
            }
        },
        onNormalGridExpand: function() {
            this.removeCls("sch-normalgrid-collapsed");
            delete this.lockedGrid.flex;
            this.lockedGrid.updateLayout()
        },
        onNormalViewItemUpdate: function(a, b, d) {
            if (this.lockedGridDependsOnSchedule) {
                var c = this.lockedGrid.getView();
                c.suspendEvents();
                c.refreshNode(c.indexOf(a));
                c.resumeEvents()
            }
        },
        onPartnerCollapseExpand: function(a) {
            if (a.getCollapsed()) {
                this.lockedGrid.collapse()
            } else {
                this.lockedGrid.expand()
            }
        },
        setupPartnerTimelinePanel: function() {
            var g = this.partnerTimelinePanel;
            var h = g.down("splitter");
            var a = this.down("splitter");
            if (h) {
                h.on("dragend",
                function() {
                    this.lockedGrid.setWidth(g.lockedGrid.getWidth())
                },
                this)
            }
            if (a) {
                a.on("dragend",
                function() {
                    g.lockedGrid.setWidth(this.lockedGrid.getWidth())
                },
                this)
            }
            var d = g.isVisible() ? g.lockedGrid.getWidth() : g.lockedGrid.width;
            if (g.lockedGrid.getCollapsed()) {
                g.lockedGrid.on("viewready",
                function(k) {
                    this.lockedGrid.setWidth(k.getWidth())
                },
                this)
            } else {
                this.lockedGrid.setWidth(d)
            }
            this.on("afterlayout",
            function() {
                if (g.lockedGrid.getCollapsed()) {
                    this.lockedGrid.collapse()
                } else {
                    this.lockedGrid.expand();
                    this.lockedGrid.setWidth(d)
                }
            },
            this, {
                single: true
            });
            g.lockedGrid.on({
                collapse: this.onPartnerCollapseExpand,
                expand: this.onPartnerCollapseExpand,
                scope: this
            });
            this.lockedGrid.on({
                collapse: this.onPartnerCollapseExpand,
                expand: this.onPartnerCollapseExpand,
                scope: g
            });
            var i = g.getSchedulingView(),
            e = i.getEl(),
            f = i.scrollManager ? i.scrollManager.scroller: e,
            b = this.getSchedulingView(),
            c = b.getEl(),
            j = b.scrollManager ? b.scrollManager.scroller: c;
            g.mon(j, "scroll",
            function(l, k) {
                i.setScrollX(b.getScroll().left)
            });
            this.mon(f, "scroll",
            function(l, k) {
                b.setScrollX(i.getScroll().left)
            });
            this.on("viewchange",
            function() {
                g.viewPreset = this.viewPreset
            },
            this);
            g.on("viewchange",
            function() {
                this.viewPreset = g.viewPreset
            },
            this)
        },
        beforeCrudOperationStart: function(a, c, b) {
            if (this.rendered) {
                this.setLoading({
                    msg: b === "load" ? this.L("loadingText") : this.L("savingText")
                })
            } else {
                Ext.destroy(this.renderWaitListener);
                this.renderWaitListener = this.on("render", Ext.Function.bind(this.beforeCrudOperationStart, this, Array.prototype.slice.apply(arguments)), this, {
                    delay: 1,
                    destroyable: true
                })
            }
        },
        onCrudOperationComplete: function() {
            Ext.destroy(this.renderWaitListener);
            this.setLoading(false)
        },
        onSchedulePinchStart: function(a, b) {
            this.pinchStartDistanceX = Math.abs(b.touches[0].pageX - b.touches[1].pageX);
            this.pinchStartDistanceY = Math.abs(b.touches[0].pageY - b.touches[1].pageY)
        },
        onSchedulePinch: function(a, b) {
            this.pinchDistanceX = Math.abs(b.touches[0].pageX - b.touches[1].pageX);
            this.pinchDistanceY = Math.abs(b.touches[0].pageY - b.touches[1].pageY)
        },
        onSchedulePinchEnd: function(a, g) {
            var f = this.pinchDistanceX;
            var d = this.pinchDistanceY;
            var h = this.getMode()[0] === "h";
            if (Math.abs(f - this.pinchStartDistanceX) > this.schedulePinchThreshold) {
                var c = Math.abs(f / this.pinchStartDistanceX);
                if (h) {
                    c > 1 ? this.zoomIn() : this.zoomOut()
                } else {
                    this.timeAxisViewModel.setViewColumnWidth(c * this.timeAxisViewModel.resourceColumnWidth)
                }
            }
            if (Math.abs(d - this.pinchStartDistanceY) > this.schedulePinchThreshold) {
                var b = Math.abs(d / this.pinchStartDistanceY);
                a.setRowHeight(a.getRowHeight() * b)
            }
            this.pinchStartDistanceX = this.pinchStartDistanceY = this.pinchDistanceX = this.pinchDistanceY = null
        },
        patchNavigationModel: function(a) {
            a.getView().getNavigationModel().focusItem = function(b) {
                b.addCls(this.focusCls);
                if ((Ext.isIE && !b.hasCls("sch-timetd")) || (!Ext.isIE && a.getOrientation() === "horizontal")) {
                    b.focus()
                }
            }
        },
        configureChildGrids: function() {
            var a = this;
            a.lockedGridConfig = Ext.apply({},
            a.lockedGridConfig || {});
            a.normalGridConfig = Ext.apply({},
            a.schedulerConfig || a.normalGridConfig || {});
            var c = a.lockedGridConfig,
            b = a.normalGridConfig;
            if (a.lockedXType) {
                c.xtype = a.lockedXType
            }
            if (a.normalXType) {
                b.xtype = a.normalXType
            }
            Ext.applyIf(c, {
                useArrows: true,
                split: true,
                animCollapse: false,
                collapseDirection: "left",
                trackMouseOver: false,
                region: "west"
            });
            Ext.applyIf(b, {
                viewType: a.viewType,
                layout: "fit",
                enableColumnMove: false,
                enableColumnResize: false,
                enableColumnHide: false,
                trackMouseOver: false,
                collapseDirection: "right",
                collapseMode: "placeholder",
                animCollapse: false,
                region: "center"
            });
            if (a.mode === "vertical") {
                c.store = b.store = a.timeAxis
            }
            if (c.width) {
                a.syncLockedWidth = Ext.emptyFn;
                c.scroll = Ext.supports.Touch ? "both": "horizontal";
                c.scrollerOwner = true
            }
        },
        afterInitComponent: function() {
            var d = this;
            var c = d.lockedGrid.getView();
            var b = d.normalGrid.getView();
            var a = Ext.data.TreeStore && d.store instanceof Ext.data.TreeStore;
            if (d.normalGrid.collapsed) {
                d.normalGrid.collapsed = false;
                b.on("boxready",
                function() {
                    d.normalGrid.collapse()
                },
                d, {
                    delay: 10
                })
            }
            if (d.lockedGrid.collapsed) {
                if (c.bufferedRenderer) {
                    c.bufferedRenderer.disabled = true
                }
            }
            if (Ext.getScrollbarSize().width === 0) {
                c.addCls("sch-ganttpanel-force-locked-scroll")
            }
            if (a) {
                this.setupLockableFilterableTree()
            }
            this.on("afterrender",
            function() {
                var e = this.lockedGrid.headerCt.showMenuBy;
                this.lockedGrid.headerCt.showMenuBy = function() {
                    e.apply(this, arguments);
                    d.showMenuBy.apply(this, arguments)
                }
            })
        },
        setupLockableFilterableTree: function() {
            var c = this;
            var b = c.lockedGrid.getView();
            var a = Sch.mixin.FilterableTreeView.prototype;
            b.initTreeFiltering = a.initTreeFiltering;
            b.onFilterChangeStart = a.onFilterChangeStart;
            b.onFilterChangeEnd = a.onFilterChangeEnd;
            b.onFilterCleared = a.onFilterCleared;
            b.onFilterSet = a.onFilterSet;
            b.initTreeFiltering()
        },
        showMenuBy: function(b, f) {
            var e = this.getMenu(),
            c = e.down("#unlockItem"),
            d = e.down("#lockItem"),
            a = c.prev();
            a.hide();
            c.hide();
            d.hide()
        }
    },
    function() {
        var a = "5.1.0";
        Ext.apply(Sch, {
            VERSION: "3.0.2"
        });
        if (Ext.versions.extjs.isLessThan(a)) {
            alert("The Ext JS version you are using needs to be updated to at least " + a)
        }
    })
}
Ext.define("Sch.panel.TimelineGridPanel", {
    extend: "Ext.grid.Panel",
    mixins: ["Sch.mixin.Localizable", "Sch.mixin.TimelinePanel"],
    subGridXType: "gridpanel",
    initComponent: function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeTimelineView()
    }
},
function() {
    this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {})
});
if (!Ext.ClassManager.get("Sch.panel.TimelineTreePanel")) {
    Ext.define("Sch.panel.TimelineTreePanel", {
        extend: "Ext.tree.Panel",
        requires: ["Ext.grid.Panel", "Ext.data.TreeStore", "Sch.mixin.FilterableTreeView", "Sch.patches.ColumnResizeTree"],
        mixins: ["Sch.mixin.Localizable", "Sch.mixin.TimelinePanel"],
        useArrows: true,
        rootVisible: false,
        lockedXType: "treepanel",
        initComponent: function() {
            this.callParent(arguments);
            this.getSchedulingView()._initializeTimelineView()
        }
    },
    function() {
        this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {})
    })
}
Ext.define("Sch.plugin.Printable", {
    extend: "Ext.AbstractPlugin",
    alias: "plugin.scheduler_printable",
    requires: ["Ext.XTemplate"],
    lockableScope: "top",
    docType: "<!DOCTYPE HTML>",
    beforePrint: Ext.emptyFn,
    afterPrint: Ext.emptyFn,
    autoPrintAndClose: true,
    fakeBackgroundColor: true,
    scheduler: null,
    mainTpl: null,
    constructor: function(a) {
        Ext.apply(this, a);
        if (!this.mainTpl) {
            this.mainTpl = new Ext.XTemplate('{docType}<html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type" /><title>{title}</title>{styles}</head><body class="sch-print-body {bodyClasses}"><div class="sch-print-ct {componentClasses}" style="width:{totalWidth}px"><div class="sch-print-headerbg" style="border-left-width:{totalWidth}px;height:{headerHeight}px;"></div><div class="sch-print-header-wrap">{[this.printLockedHeader(values)]}{[this.printNormalHeader(values)]}</div>{[this.printLockedGrid(values)]}{[this.printNormalGrid(values)]}</div><script type="text/javascript">{setupScript}<\/script></body></html>', {
                printLockedHeader: function(b) {
                    var c = "";
                    if (b.lockedGrid) {
                        c += '<div style="left:-' + b.lockedScroll + "px;margin-right:-" + b.lockedScroll + "px;width:" + (b.lockedWidth + b.lockedScroll) + 'px"';
                        c += 'class="sch-print-lockedheader ' + b.lockedGrid.headerCt.el.dom.className + '">';
                        c += b.lockedHeader;
                        c += "</div>"
                    }
                    return c
                },
                printNormalHeader: function(b) {
                    var c = "";
                    if (b.normalGrid) {
                        c += '<div style="left:' + (b.lockedGrid ? b.lockedWidth: "0") + "px;width:" + b.normalWidth + 'px;" class="sch-print-normalheader ' + b.normalGrid.headerCt.el.dom.className + '">';
                        c += '<div style="margin-left:-' + b.normalScroll + 'px">' + b.normalHeader + "</div>";
                        c += "</div>"
                    }
                    return c
                },
                printLockedGrid: function(b) {
                    var c = "";
                    if (b.lockedGrid) {
                        c += '<div id="lockedRowsCt" style="left:-' + b.lockedScroll + "px;margin-right:-" + b.lockedScroll + "px;width:" + (b.lockedWidth + b.lockedScroll) + "px;top:" + b.headerHeight + 'px;" class="sch-print-locked-rows-ct ' + b.innerLockedClasses + " " + Ext.baseCSSPrefix + 'grid-inner-locked">';
                        c += b.lockedRows;
                        c += "</div>"
                    }
                    return c
                },
                printNormalGrid: function(b) {
                    var c = "";
                    if (b.normalGrid) {
                        c += '<div id="normalRowsCt" style="left:' + (b.lockedGrid ? b.lockedWidth: "0") + "px;top:" + b.headerHeight + "px;width:" + b.normalWidth + 'px" class="sch-print-normal-rows-ct ' + b.innerNormalClasses + '">';
                        c += '<div style="position:relative;overflow:visible;margin-left:-' + b.normalScroll + 'px">' + b.normalRows + "</div>";
                        c += "</div>"
                    }
                    return c
                }
            })
        }
    },
    init: function(a) {
        this.scheduler = a;
        a.print = Ext.Function.bind(this.print, this)
    },
    getGridContent: function(n) {
        var m = n.normalGrid,
        e = n.lockedGrid,
        o = e.getView(),
        g = m.getView(),
        j,
        d,
        l,
        i,
        k,
        b,
        h;
        this.beforePrint(n);
        if (e.collapsed && !m.collapsed) {
            b = e.getWidth() + m.getWidth()
        } else {
            b = m.getWidth();
            h = e.getWidth()
        }
        var c = o.store.getRange();
        d = o.tpl.apply(o.collectData(c, 0));
        l = g.tpl.apply(g.collectData(c, 0));
        i = o.el.getScroll().left;
        k = g.el.getScroll().left;
        var a = document.createElement("div");
        a.innerHTML = d;
        a.firstChild.style.width = o.el.dom.style.width;
        d = a.innerHTML;
        if (Sch.feature && Sch.feature.AbstractTimeSpan) {
            var f = (n.plugins || []).concat(n.normalGrid.plugins || []).concat(n.columnLinesFeature || []);
            Ext.each(f,
            function(p) {
                if (p instanceof Sch.feature.AbstractTimeSpan && p.generateMarkup) {
                    l = p.generateMarkup(true) + l
                }
            })
        }
        this.afterPrint(n);
        return {
            normalHeader: m.headerCt.el.dom.innerHTML,
            lockedHeader: e.headerCt.el.dom.innerHTML,
            lockedGrid: e.collapsed ? false: e,
            normalGrid: m.collapsed ? false: m,
            lockedRows: d,
            normalRows: l,
            lockedScroll: i,
            normalScroll: k,
            lockedWidth: h - (Ext.isWebKit ? 1 : 0),
            normalWidth: b,
            headerHeight: m.headerCt.getHeight(),
            innerLockedClasses: e.view.el.dom.className,
            innerNormalClasses: m.view.el.dom.className + (this.fakeBackgroundColor ? " sch-print-fake-background": ""),
            width: n.getWidth()
        }
    },
    getStylesheets: function() {
        return Ext.getDoc().select('link[rel="stylesheet"]')
    },
    print: function() {
        var g = this.scheduler;
        if (! (this.mainTpl instanceof Ext.Template)) {
            var a = 22;
            this.mainTpl = new Ext.XTemplate(this.mainTpl, {
                compiled: true,
                disableFormats: true
            })
        }
        var h = g.getView(),
        i = this.getStylesheets(),
        e = Ext.get(Ext.core.DomHelper.createDom({
            tag: "div"
        })),
        b;
        i.each(function(j) {
            e.appendChild(j.dom.cloneNode(true))
        });
        b = e.dom.innerHTML + "";
        var f = this.getGridContent(g),
        c = this.mainTpl.apply(Ext.apply({
            waitText: this.waitText,
            docType: this.docType,
            htmlClasses: Ext.getBody().parent().dom.className,
            bodyClasses: Ext.getBody().dom.className,
            componentClasses: g.el.dom.className,
            title: (g.title || ""),
            styles: b,
            totalWidth: g.getWidth(),
            setupScript: ("window.onload = function(){ (" + this.setupScript.toString() + ")(" + g.syncRowHeight + ", " + this.autoPrintAndClose + ", " + Ext.isChrome + ", " + Ext.isIE + "); };")
        },
        f));
        var d = window.open("", "printgrid");
        if (!d || !d.document) {
            return false
        }
        this.printWindow = d;
        d.document.write(c);
        d.document.close()
    },
    setupScript: function(e, a, d, b) {
        var c = function() {
            if (e) {
                var f = document.getElementById("lockedRowsCt"),
                o = document.getElementById("normalRowsCt"),
                g = f && f.getElementsByTagName("tr"),
                m = o && o.getElementsByTagName("tr"),
                k = m && g ? m.length: 0;
                for (var j = 0; j < k; j++) {
                    var h = m[j].clientHeight;
                    var l = g[j].clientHeight;
                    var n = Math.max(h, l) + "px";
                    g[j].style.height = m[j].style.height = n
                }
            }
            document._loaded = true;
            if (a) {
                window.print();
                if (!d) {
                    window.close()
                }
            }
        };
        if (b) {
            setTimeout(c, 0)
        } else {
            c()
        }
    }
});
Ext.define("Sch.plugin.exporter.AbstractExporter", {
    extend: "Ext.util.Observable",
    requires: ["Ext.dom.Element", "Ext.core.DomHelper"],
    mixins: ["Sch.mixin.Localizable"],
    pageHeaderHeight: 41,
    pageFooterHeight: 0,
    bufferedHeightMargin: 25,
    paperWidth: 0,
    paperHeight: 0,
    printHeight: 0,
    lockedRowsHeight: 0,
    normalRowsHeight: 0,
    iterateTimeout: 10,
    tableSelector: undefined,
    currentPage: undefined,
    headerTplDataFn: null,
    footerTplDataFn: null,
    headerTplDataFnScope: null,
    footerTplDataFnScope: null,
    config: {
        exporterId: "abstractexporter",
        name: "",
        translateURLsToAbsolute: true,
        expandAllBeforeExport: false,
        headerTpl: '<div class="sch-export-header" style="height:{height}px; width:{width}px"><h2>{pageNo}/{totalPages}</h2></div>',
        tpl: '<!DOCTYPE html><html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type" /><title>{title}</title>{styles}</head><body class="' + Ext.baseCSSPrefix + 'webkit sch-export {bodyClasses}">{header}<div class="{componentClasses}" style="height:{bodyHeight}px; width:{totalWidth}px; position: relative !important">{HTML}</div>{footer}</body></html>',
        footerTpl: ""
    },
    callbacks: undefined,
    error: undefined,
    extractedPages: undefined,
    numberOfPages: 0,
    constructor: function(a) {
        var b = this;
        a = a || {};
        b.callParent(arguments);
        delete a.getUserHeaderTplData;
        delete a.getUserFooterTplData;
        b.initConfig(a);
        if (!a.tableSelector) {
            b.tableSelector = "." + Ext.baseCSSPrefix + "grid-item-container"
        }
        if (!a.name) {
            b.setName(b.L("name"))
        }
    },
    setHeaderTpl: function(a) {
        this.headerTpl = this.getTplInstance(a)
    },
    getHeaderTpl: function() {
        return this.headerTpl
    },
    setTpl: function(a) {
        this.tpl = this.getTplInstance(a)
    },
    getTpl: function() {
        return this.tpl
    },
    setFooterTpl: function(a) {
        this.footerTpl = this.getTplInstance(a)
    },
    getFooterTpl: function() {
        return this.footerTpl
    },
    getTplInstance: function(a) {
        return (a && !a.isTemplate) ? new Ext.XTemplate(a, {
            disableFormats: true
        }) : a
    },
    getBodyClasses: function() {
        var b = new RegExp(Ext.baseCSSPrefix + "ie\\d?|" + Ext.baseCSSPrefix + "gecko", "g"),
        a = Ext.getBody().dom.className.replace(b, "");
        if (Ext.isIE) {
            a += " sch-ie-export"
        }
        return a
    },
    getComponentClasses: function() {
        return this.getComponent().el.dom.className
    },
    setComponent: function(a) {
        var b = this;
        b.component = a;
        b.view = a.getSchedulingView();
        b.normalGrid = a.normalGrid;
        b.lockedGrid = a.lockedGrid;
        b.normalView = a.normalGrid.view;
        b.lockedView = a.lockedGrid.view;
        b.lockedBodySelector = "#" + b.lockedView.getId();
        b.normalBodySelector = "#" + b.normalView.getId();
        b.lockedHeader = b.lockedGrid.headerCt;
        b.normalHeader = b.normalGrid.headerCt;
        b.headerHeight = b.normalHeader.getHeight();
        b.printHeight = Math.floor(b.paperHeight) - b.headerHeight - (b.exportConfig.showHeader ? b.pageHeaderHeight: 0) - (b.exportConfig.showFooter ? b.pageFooterHeight: 0);
        b.saveComponentState(a)
    },
    getComponent: function() {
        return this.component
    },
    setPaperSize: function(a, b) {
        var c = this;
        if (b === "landscape") {
            c.paperWidth = a.height;
            c.paperHeight = a.width
        } else {
            c.paperWidth = a.width;
            c.paperHeight = a.height
        }
    },
    getPaperFormat: function() {
        return this.exportConfig.format
    },
    isBuffered: function() {
        return !! this.getBufferedRenderer()
    },
    getBufferedRenderer: function() {
        return this.view.bufferedRenderer
    },
    setComponentRange: function(d) {
        var f = this,
        c = f.getComponent(),
        b = f.view,
        a,
        e;
        if (d.range !== "complete") {
            switch (d.range) {
            case "date":
                a = new Date(d.dateFrom);
                e = new Date(d.dateTo);
                if (Sch.util.Date.getDurationInDays(a, e) < 1) {
                    e = Sch.util.Date.add(e, Sch.util.Date.DAY, 1)
                }
                a = Sch.util.Date.constrain(a, c.getStart(), c.getEnd());
                e = Sch.util.Date.constrain(e, c.getStart(), c.getEnd());
                break;
            case "current":
                var g = b.getVisibleDateRange();
                a = g.startDate;
                e = g.endDate || b.timeAxis.getEnd();
                if (d.cellSize) {
                    var h = d.cellSize;
                    f.timeColumnWidth = h[0];
                    if (f.timeColumnWidth) {
                        c.setTimeColumnWidth(f.timeColumnWidth)
                    }
                    if (h.length > 1) {
                        f.view.setRowHeight(h[1])
                    }
                }
                break
            }
            c.setTimeSpan(a, e)
        }
        f.ticks = c.timeAxis.getTicks()
    },
    getStylesheets: function() {
        var d = this.translateURLsToAbsolute,
        c = Ext.getDoc().select('link[rel="stylesheet"]'),
        a = Ext.get(Ext.core.DomHelper.createDom({
            tag: "div"
        })),
        b;
        c.each(function(e) {
            var f = e.dom.cloneNode(true);
            d && f.setAttribute("href", e.dom.href);
            a.appendChild(f)
        });
        b = a.dom.innerHTML + "";
        return b
    },
    forEachTimeSpanPlugin: function(c, f, e) {
        if (Sch.feature && Sch.feature.AbstractTimeSpan) {
            var h = this;
            var b = (c.plugins || []).concat(c.normalGrid.plugins || []).concat(c.columnLinesFeature || []);
            for (var d = 0,
            a = b.length; d < a; d++) {
                var g = b[d];
                if (g instanceof Sch.feature.AbstractTimeSpan) {
                    f.call(e || h, g)
                }
            }
        }
    },
    prepareComponent: function(b, a) {
        var c = this;
        b = b || c.getComponent();
        c.forEachTimeSpanPlugin(b,
        function(d) {
            d._renderDelay = d.renderDelay;
            d.renderDelay = 0
        });
        b.getSchedulingView().timeAxisViewModel.suppressFit = true;
        b.timeAxis.autoAdjust = false;
        b.normalGrid.expand();
        b.lockedGrid.expand();
        c.setComponentRange(a);
        if (c.expandAllBeforeExport && b.expandAll) {
            b.expandAll()
        }
        c.fitComponentIntoPage();
        if (c.isBuffered() && Ext.isIE8) {
            c.normalView.bufferedRenderer.variableRowHeight = false;
            c.lockedView.bufferedRenderer.variableRowHeight = false
        }
    },
    restoreComponent: function(a) {
        var b = this;
        a = a || b.getComponent();
        b.forEachTimeSpanPlugin(a,
        function(c) {
            c.renderDelay = c._renderDelay;
            delete c._renderDelay
        });
        b.restoreComponentState(a);
        b.exportConfig.afterExport && b.exportConfig.afterExport(a)
    },
    saveComponentState: function(b) {
        b = b || this.getComponent();
        var c = this,
        a = b.getSchedulingView(),
        d = b.normalGrid,
        e = b.lockedGrid;
        c.restoreSettings = {
            width: b.getWidth(),
            height: b.getHeight(),
            rowHeight: a.timeAxisViewModel.getViewRowHeight(),
            columnWidth: a.timeAxisViewModel.getTickWidth(),
            startDate: b.getStart(),
            endDate: b.getEnd(),
            normalWidth: d.getWidth(),
            normalLeft: d.getEl().getStyle("left"),
            lockedWidth: e.getWidth(),
            lockedCollapse: e.collapsed,
            normalCollapse: d.collapsed,
            autoAdjust: b.timeAxis.autoAdjust,
            suppressFit: a.timeAxisViewModel.suppressFit,
            restoreColumnWidth: false,
            startIndex: a.all ? a.all.startIndex: 0
        }
    },
    restoreComponentState: function(c) {
        var d = this;
        c = c || d.getComponent();
        var b = d.restoreSettings,
        a = c.getSchedulingView();
        c.timeAxis.autoAdjust = b.autoAdjust;
        c.normalGrid.show();
        c.setWidth(b.width);
        c.setHeight(b.height);
        c.setTimeSpan(b.startDate, b.endDate);
        c.setTimeColumnWidth(b.columnWidth, true);
        a.setRowHeight(b.rowHeight);
        c.lockedGrid.show();
        c.normalGrid.setWidth(b.normalWidth);
        c.normalGrid.getEl().setStyle("left", b.normalLeft);
        c.lockedGrid.setWidth(b.lockedWidth);
        a.timeAxisViewModel.suppressFit = b.suppressFit;
        a.timeAxisViewModel.setTickWidth(b.columnWidth);
        if (b.lockedCollapse) {
            c.lockedGrid.collapse()
        }
        if (b.normalCollapse) {
            c.normalGrid.collapse()
        }
        if (d.getBufferedRenderer()) {
            d.scrollTo(b.startIndex);
            if (Ext.isIE8) {
                d.normalView.bufferedRenderer.variableRowHeight = true;
                d.lockedView.bufferedRenderer.variableRowHeight = true
            }
        }
    },
    extractPages: function(b, a, e, c) {
        var d = this;
        d.exportConfig = a;
        d.normalRows = [];
        d.lockedRows = [];
        d.extractedPages = [];
        d.numberOfPages = 0;
        d.lockedRowsHeight = 0;
        d.normalRowsHeight = 0;
        d.setPaperSize(a.pageSize, a.orientation);
        d.setComponent(b, a);
        d.prepareComponent(b, a);
        a.beforeExport && a.beforeExport(b, d.ticks);
        d.callbacks = {
            success: e || Ext.emptyFn,
            scope: c || d
        };
        new Ext.util.DelayedTask(function() {
            d.collectRows(0, d.onRowsCollected, d)
        },
        d).delay(1)
    },
    onPagesExtracted: function(a) {
        var b = this;
        b.restoreComponent();
        b.submitPages(a)
    },
    submitPages: function(a) {
        var c = this,
        b = c.callbacks;
        b.success.call(b.scope, c.renderPages(a))
    },
    getCurrentPage: function() {
        return this.currentPage
    },
    setCurrentPage: function(a) {
        this.currentPage = a
    },
    getExpectedNumberOfPages: Ext.emptyFn,
    commitPage: function(a) {
        var b = this;
        b.numberOfPages++;
        var d = b.preparePageToCommit(a);
        var c = Ext.apply({
            html: d.dom.innerHTML,
            number: b.numberOfPages
        },
        a);
        b.extractedPages.push(c);
        b.fireEvent("commitpage", b, c, b.numberOfPages, b.getExpectedNumberOfPages())
    },
    collectLockedRow: function(d, c) {
        var b = Ext.fly(d).getHeight();
        this.lockedRowsHeight += b;
        var a = {
            height: b,
            row: d.cloneNode(true),
            record: this.lockedView.getRecord(c)
        };
        this.lockedRows.push(a);
        return a
    },
    collectNormalRow: function(d, c) {
        var b = Ext.fly(d).getHeight();
        this.normalRowsHeight += b;
        var a = {
            height: Ext.fly(d).getHeight(),
            row: d.cloneNode(true),
            record: this.normalView.getRecord(c)
        };
        this.normalRows.push(a);
        return a
    },
    onRowsCollected: function() {
        throw "Sch.plugin.exporter.AbstractExporter: [onRowsCollected] Abstract method called."
    },
    iterateAsync: function(c, b) {
        var d = this;
        b = b || d;
        var a = function() {
            var e = arguments;
            new Ext.util.DelayedTask(function() {
                c.apply(b, [].concat.apply([a], e))
            }).delay(d.iterateTimeout)
        };
        a.apply(d, Ext.Array.slice(arguments, 2))
    },
    collectRows: function(g, h, j) {
        var f = this;
        if (f.isBuffered() && !f.scrolledToStartIndex) {
            new Ext.util.DelayedTask(function() {
                f.scrollTo(g,
                function() {
                    f.scrolledToStartIndex = true;
                    f.collectRows(0, h, j)
                },
                f)
            },
            f).delay(f.iterateTimeout);
            return
        }
        var c = f.normalView.all.endIndex,
        d = f.component.store.getCount(),
        e = f.normalView.all.slice(g),
        a = f.lockedView.all.slice(g);
        for (var b = 0; b < a.length; b++) {
            f.collectLockedRow(a[b], g + b)
        }
        for (b = 0; b < e.length; b++) {
            f.collectNormalRow(e[b], g + b)
        }
        f.fireEvent("collectrows", f, g, c, d);
        if (f.isBuffered()) {
            if (c + 1 < d) {
                new Ext.util.DelayedTask(function() {
                    f.scrollTo(c + 1,
                    function() {
                        f.collectRows(c + 1, h, j)
                    },
                    f)
                },
                f).delay(50)
            } else {
                f.scrollTo(0,
                function() {
                    f.scrolledToStartIndex = false;
                    h.call(j || f, f.lockedRows, f.normalRows)
                })
            }
        } else {
            f.scrolledToStartIndex = false;
            h.call(j || f, f.lockedRows, f.normalRows)
        }
    },
    renderPages: function(a) {
        var d = this;
        a = a || d.extractedPages;
        for (var c = 0,
        b = a.length; c < b; c++) {
            var e = a[c];
            e.html = d.applyPageTpl(e)
        }
        return a
    },
    applyPageTpl: function(a) {
        var b = this;
        return b.getTpl().apply(b.getPageTplData(a))
    },
    applyHeaderTpl: function(b) {
        var c = this,
        e = c.getHeaderTpl();
        if (c.exportConfig.showHeader && e) {
            var a = c.headerTplDataFn;
            var d = a && a.call(c.headerTplDataFnScope || c, b);
            return e.apply(Ext.apply(c.getHeaderTplData(b), d))
        }
        return ""
    },
    applyFooterTpl: function(b) {
        var c = this,
        e = c.getFooterTpl();
        if (c.exportConfig.showFooter && e) {
            var a = c.footerTplDataFn;
            var d = a && a.call(c.footerTplDataFnScope || c, b);
            return e.apply(Ext.apply(c.getFooterTplData(b), d))
        }
        return ""
    },
    getHeaderTplData: function(a) {
        var b = this;
        return {
            width: b.paperWidth,
            height: b.pageHeaderHeight,
            totalPages: b.numberOfPages,
            pageNo: a.number
        }
    },
    getFooterTplData: function(a) {
        var b = this;
        return {
            width: b.paperWidth,
            height: b.pageFooterHeight,
            totalPages: b.numberOfPages,
            pageNo: a.number
        }
    },
    getPageTplData: function(a) {
        var b = this;
        return {
            bodyClasses: b.getBodyClasses(),
            bodyHeight: b.printHeight + b.headerHeight,
            componentClasses: b.getComponentClasses(),
            styles: b.getStylesheets(),
            showHeader: b.exportConfig.showHeader,
            showFooter: b.exportConfig.showFooter,
            header: b.applyHeaderTpl(a),
            HTML: a.html,
            footer: b.applyFooterTpl(a),
            totalWidth: b.paperWidth,
            title: a.number + " of " + b.numberOfPages
        }
    },
    fitComponentIntoPage: Ext.emptyFn,
    getLockedGridBody: function(a) {
        a = a || this.getCurrentPage();
        return a.select(this.lockedBodySelector + " > " + this.tableSelector).first()
    },
    getNormalGridBody: function(a) {
        a = a || this.getCurrentPage();
        return a.select(this.normalBodySelector + " > " + this.tableSelector).first()
    },
    emptyLockedGrid: function(a) {
        this.getLockedGridBody(a).select(this.lockedView.getItemSelector()).remove()
    },
    fillGrids: function(c, b, e, a) {
        var d = this;
        d.fillLockedGrid(c, e, a);
        d.fillNormalGrid(b, e, a)
    },
    fillLockedGrid: function(c, d, a) {
        var b = this;
        if (!a) {
            b.emptyLockedGrid()
        }
        b.appendRows(b.getLockedGridBody(), c || b.lockedRows, d)
    },
    fillNormalGrid: function(c, d, a) {
        var b = this;
        if (!a) {
            b.emptyNormalGrid()
        }
        b.appendRows(b.getNormalGridBody(), c || b.normalRows, d)
    },
    appendRows: function(d, c, f) {
        var e = d.dom;
        for (var b = 0,
        a = c.length; b < a; b++) {
            e.appendChild(f ? c[b].row.cloneNode(true) : c[b].row)
        }
    },
    emptyNormalGrid: function(a) {
        this.getNormalGridBody(a).select(this.normalView.getItemSelector()).remove()
    },
    getRowHeight: function() {
        return this.view.timeAxisViewModel.getViewRowHeight()
    },
    getTotalSize: function() {
        return {
            width: this.getTotalWidth(),
            height: this.getTotalHeight()
        }
    },
    getTotalHeight: function() {
        var b = this,
        a;
        if (b.isBuffered()) {
            a = b.bufferedHeightMargin + b.normalRowsHeight
        } else {
            a = b.lockedView.getEl().down(b.tableSelector).getHeight()
        }
        return b.headerHeight + a
    },
    getTotalWidth: function() {
        return this.getLockedGridWidth() + this.normalGrid.body.down(this.tableSelector).getWidth()
    },
    getLockedGridWidth: function() {
        return this.lockedHeader.getEl().first().getWidth()
    },
    getNormalGridWidth: function() {
        return this.normalHeader.getEl().first().getWidth()
    },
    preparePageToCommit: function() {
        var i = this.getCurrentPage(),
        g = this.component,
        c = g.lockedGrid,
        f = g.normalGrid;
        i.el.select(".sch-remove").remove();
        var b = function(l) {
            var k = i.select("#" + l).first();
            return k && k.dom
        },
        j = function(k) {
            if (k) {
                k.style.width = "100%"
            }
        },
        e = function(k) {
            if (k) {
                k.style.height = "100%"
            }
        };
        var a = i.select(this.normalBodySelector).first();
        a.dom.style.top = "0px";
        var h = i.select(this.lockedBodySelector).first();
        h.dom.style.top = "0px";
        var d = [b(g.id + "-targetEl"), b(g.id + "-innerCt"), b(c.id), b(c.body.id), b(c.view.el.id)];
        Ext.Array.each(d, e);
        j(d[0]);
        j(d[1]);
        j(b(f.headerCt.id));
        Ext.Array.each([b(f.id), b(f.body.id), b(f.getView().id)],
        function(k) {
            if (k) {
                k.style.height = "100%";
                k.style.width = "100%"
            }
        });
        return i
    },
    cloneElement: function(a) {
        return new Ext.dom.Element(Ext.core.DomHelper.createDom({
            tag: "div",
            html: a.dom.innerHTML
        }))
    },
    startPage: function(b) {
        var a = this;
        var c = a.cloneElement(b || a.getComponent().body);
        a.setCurrentPage(c)
    },
    scrollTo: function(a, d) {
        var c = this;
        if (c.component.ensureVisible) {
            var b = c.component.store.getAt(a);
            c.component.ensureVisible(b, {
                callback: function() {
                    if (d && this.isLocked === false) {
                        d.apply(c)
                    }
                },
                select: false,
                focus: false,
                animate: false
            })
        } else {
            c.lockedView.bufferedRenderer.scrollTo(a, false,
            function() {
                c.normalView.bufferedRenderer.scrollTo(a, false, d)
            })
        }
    },
    removeNode: function(b) {
        if (b && b.parentNode) {
            b.parentNode.removeChild(b)
        } else {
            if (b.elements) {
                for (var a = 0; a < b.elements.length; a++) {
                    var c = b.elements[a];
                    c.parentNode.removeChild(c)
                }
            }
        }
    }
});
Ext.define("Sch.plugin.exporter.SinglePage", {
    extend: "Sch.plugin.exporter.AbstractExporter",
    config: {
        exporterId: "singlepage"
    },
    getPaperFormat: function() {
        var e = this,
        c = e.getTotalSize(),
        b = e.exportConfig.DPI,
        d = Ext.Number.toFixed(c.width / b, 1),
        a = Ext.Number.toFixed(c.height / b, 1);
        return d + "in*" + a + "in"
    },
    onRowsCollected: function() {
        var a = this;
        a.startPage();
        a.fillGrids();
        a.commitPage();
        a.onPagesExtracted()
    },
    getPageTplData: function() {
        var b = this,
        a = b.getTotalSize();
        return Ext.apply(b.callParent(arguments), {
            bodyHeight: a.height,
            showHeader: false,
            totalWidth: a.width
        })
    },
    fitComponentIntoPage: function() {
        var a = this,
        b = a.lockedGrid;
        b.setWidth(b.headerCt.getEl().first().getWidth())
    }
});
Ext.define("Sch.plugin.exporter.MultiPage", {
    extend: "Sch.plugin.exporter.AbstractExporter",
    config: {
        exporterId: "multipage"
    },
    rowPageIndex: 0,
    columnPageIndex: 0,
    pagesPerColumn: 0,
    onRowsCollected: function(b, a) {
        var c = this;
        c.rowPageIndex = 0;
        c.columnPageIndex = 0;
        c.pagesPerColumn = 0;
        c.buildPageFrames(function() {
            c.buildPages(c.onPagesExtracted, c, b, a)
        })
    },
    buildPages: function(f, c, b, a) {
        var d = this,
        e = d.pageFrames[0];
        d.startPage(e, true);
        this.iterateAsync(d.rowIteratorStep, d, {
            rowIndex: 0,
            pageFrame: e,
            rowsHeight: 0,
            leftHeight: this.printHeight,
            lockeds: [],
            normals: [],
            lockedRows: b,
            normalRows: a,
            callback: f,
            scope: c || d
        })
    },
    rowIteratorStep: function(g, a) {
        var j = this,
        k = a.rowIndex,
        b = a.lockedRows,
        h = a.normalRows,
        i = a.leftHeight,
        d = a.lockeds,
        l = a.normals,
        c = true;
        if (k < b.length) {
            var f = b[k],
            e = h[k];
            if (f.height <= i) {
                d.push(f);
                l.push(e);
                a.leftHeight -= f.height;
                a.rowsHeight += f.height;
                c = false
            } else {
                j.fillGrids(d, l, a.pageFrame);
                j.commitPage({
                    rowsHeight: a.rowsHeight
                });
                j.startPage(a.pageFrame);
                a.lockeds = [f];
                a.normals = [e];
                a.leftHeight = j.printHeight - f.height;
                a.rowsHeight = f.height
            }
            a.rowIndex++
        } else {
            if (j.columnPageIndex < j.pageFrames.length) {
                j.fillGrids(d, l, a.pageFrame);
                j.commitPage({
                    rowsHeight: a.rowsHeight
                });
                a.pageFrame = j.pageFrames[j.columnPageIndex];
                j.startPage(a.pageFrame, true);
                a.leftHeight = j.printHeight;
                a.rowsHeight = 0;
                a.lockeds = [];
                a.normals = [];
                a.rowIndex = 0
            } else {
                j.fillGrids(d, l, a.pageFrame);
                j.commitPage({
                    rowsHeight: a.rowsHeight
                });
                a.callback.call(a.scope);
                return
            }
        }
        if (c) {
            g(a)
        } else {
            j.rowIteratorStep(g, a)
        }
    },
    fillGrids: function(e, d, f) {
        var c = this,
        b = c.lockedColumnPages[c.columnPageIndex - 1],
        a = !b || (b && b.leftWidth);
        if (b) {
            c.fillLockedGrid(e, true);
            c.removeHiddenLockedColumns(b)
        }
        if (a) {
            c.fillNormalGrid(d, true);
            c.removeInvisibleEvents( - f.normalGridOffset, -f.normalGridOffset + f.normalGridWidth)
        }
    },
    buildPageFrame: function(h, b) {
        var f = this,
        j = f.lockedColumnPages[h];
        if (j) {
            f.lockedGrid.setWidth(f.showLockedColumns(j.start, j.end) + (j.startOffset || 0));
            if (j.leftWidth) {
                f.normalGrid.show()
            } else {
                f.normalGrid.hide()
            }
        } else {
            f.lockedGrid.setWidth(0);
            f.lockedGrid.hide();
            f.normalGrid.show()
        }
        var a = f.cloneElement(f.getComponent().body);
        a.normalGridOffset = b;
        a.lockedGridOffset = j && j.startOffset || 0;
        a.normalGridWidth = f.normalGrid.getWidth();
        a.lockedGridWidth = f.lockedGrid.getWidth();
        a.select(f.lockedBodySelector).first().dom.style.position = "";
        a.select("#" + f.lockedView.id).first().dom.style.overflow = "visible";
        if (!f.normalGrid.hidden) {
            var i = a.select(f.normalBodySelector).first();
            i.dom.style.position = "";
            i.dom.style.top = "0px";
            var d = f.getNormalGridBody(a);
            var c = a.select("#" + f.normalView.headerCt.id).first();
            var e = a.select(".sch-secondary-canvas").first();
            var g = a.select("#" + f.normalView.id).first();
            d.dom.style.left = b + "px";
            c.dom.style.left = b + "px";
            c.dom.style.overflow = "visible";
            e.dom.style.left = b + "px";
            g.dom.style.overflow = "visible"
        }
        return a
    },
    buildPageFrames: function(e, c) {
        var d = this;
        c = c || d;
        d.lockedColumnPages = d.calculateLockedColumnPages();
        var a = Math.ceil(d.getTotalWidth() / d.paperWidth),
        b = d.pageFrames = [];
        d.iterateAsync(function(h, g, i) {
            if (g >= a) {
                e.call(c, b);
                return
            }
            b.push(d.buildPageFrame(g, i));
            var f = d.lockedColumnPages[g];
            if (f) {
                i -= f.leftWidth || 0
            } else {
                i -= d.paperWidth
            }
            h(g + 1, i)
        },
        d, 0, 0)
    },
    startPage: function(c, a) {
        var b = this;
        if (a) {
            if (b.columnPageIndex == 1) {
                b.pagesPerColumn = b.extractedPages.length
            }
            b.rowPageIndex = 0;
            b.columnPageIndex++
        }
        b.rowPageIndex++;
        b.callParent(arguments);
        b.emptyNormalGrid();
        b.emptyLockedGrid()
    },
    commitPage: function(a) {
        var b = this;
        b.callParent([Ext.apply({
            row: b.rowPageIndex,
            column: b.columnPageIndex
        },
        a)])
    },
    getExpectedPagesPerColumn: function() {
        return this.pagesPerColumn || Math.ceil(this.lockedRowsHeight / this.printHeight)
    },
    getExpectedNumberOfPages: function() {
        return this.pageFrames.length * this.getExpectedPagesPerColumn()
    },
    calculateLockedColumnPages: function() {
        var h = this,
        j = [],
        c = h.lockedColumns,
        e = h.paperWidth,
        g;
        for (var f = 0,
        d = c.length; f < d; f++) {
            var b = c[f],
            a = b.width;
            g = g || {
                start: f,
                end: f
            };
            e -= a;
            if (e < 0) {
                j.push(g);
                if (e) {
                    g = {
                        start: f,
                        end: f
                    }
                }
                e = h.paperWidth - a + e
            } else {
                g.end = f
            }
        }
        if (g) {
            g.leftWidth = e;
            j.push(g)
        }
        return j
    },
    getPageTplData: function(a) {
        return Ext.apply(this.callParent(arguments), {
            title: a.number + " of " + this.numberOfPages + " (column: " + a.column + ", row: " + a.row + ")"
        })
    },
    showLockedColumns: function(e, g) {
        var f = this,
        b = f.lockedColumns,
        d = 0;
        e = e || 0;
        g = g || b.length - 1;
        for (var a = 0; a < b.length; a++) {
            var c = b[a];
            if (a >= e && a <= g) {
                c.column.show();
                d += c.width
            } else {
                c.column.hide()
            }
        }
        return d
    },
    removeInvisibleEvents: function(b, h) {
        var j = this,
        d = j.getNormalGridBody(),
        e = j.normalView.eventCls;
        var a = d.select("." + e).elements;
        for (var g = 0; g < a.length; g++) {
            var c = parseInt(a[g].style.left, 10),
            f = c + parseInt(a[g].style.width, 10);
            if (f < b || c > h) {
                j.removeNode(a[g])
            }
        }
    },
    removeHiddenLockedColumns: function(b) {
        var j = this,
        h = j.getCurrentPage(),
        a = j.getLockedGridBody();
        for (var f = 0; f < j.lockedColumns.length; f++) {
            var c = j.lockedColumns[f].column;
            if (f < b.start || f > b.end) {
                var d = "#" + c.getId();
                var g = h.select(d);
                j.removeNode(g);
                var e = c.getCellSelector();
                var k = a.select(e);
                j.removeNode(k)
            }
        }
    },
    fitComponentIntoPage: function() {
        var a = this;
        a.getComponent().setWidth(a.paperWidth)
    },
    restoreComponentState: function() {
        this.callParent(arguments);
        this.showLockedColumns()
    },
    setComponent: function() {
        var b = this,
        a = b.lockedColumns = [];
        b.callParent(arguments);
        b.lockedGrid.headerCt.items.each(function(c) {
            if (!c.hidden) {
                a.push({
                    column: c,
                    width: c.getWidth()
                })
            }
        })
    }
});
Ext.define("Sch.plugin.exporter.MultiPageVertical", {
    extend: "Sch.plugin.exporter.AbstractExporter",
    config: {
        exporterId: "multipagevertical"
    },
    minRowHeight: 20,
    visibleColumns: null,
    visibleColumnsWidth: 0,
    onRowsCollected: function(b, a) {
        var c = this;
        c.iterateAsync(function(g, j) {
            if (j === b.length) {
                c.onPagesExtracted();
                return
            }
            var h = j,
            f = c.printHeight,
            l = 0,
            e = [],
            k = [],
            i,
            d = false;
            c.startPage();
            while (!d && h < b.length) {
                i = a[h];
                f -= i.height;
                if (f > 0) {
                    l += i.height;
                    e.push(b[h]);
                    k.push(i);
                    h++
                } else {
                    d = true
                }
            }
            c.fillGrids(e, k);
            c.commitPage({
                rowIndex: h,
                rowsHeight: l
            });
            g(h)
        },
        c, 0)
    },
    startPage: function() {
        var b = this;
        b.callParent(arguments);
        var a = b.getCurrentPage().select("#" + b.lockedView.id).first();
        a.dom.style.overflow = "visible"
    },
    getExpectedNumberOfPages: function() {
        return Math.ceil(this.lockedRowsHeight / this.printHeight)
    },
    setComponent: function() {
        var b = this,
        a = b.visibleColumns = [];
        b.callParent(arguments);
        b.visibleColumnsWidth = 0;
        b.lockedGrid.headerCt.items.each(function(c) {
            if (!c.hidden) {
                a.push({
                    column: c,
                    width: c.getWidth()
                });
                b.visibleColumnsWidth += c.getWidth()
            }
        })
    },
    fitComponentIntoPage: function() {
        var i = this,
        j = i.getComponent(),
        h = j.normalGrid,
        c = j.lockedGrid,
        f = i.getTotalWidth(),
        k = i.ticks,
        e = i.timeColumnWidth || i.restoreSettings.columnWidth;
        var d = Math.floor((i.visibleColumnsWidth / f) * i.paperWidth);
        var b = Math.floor((k.length * e / f) * i.paperWidth);
        var g = Math.floor(b / k.length);
        var a = (g / e) * i.getRowHeight();
        i.view.setRowHeight(a < i.minRowHeight ? i.minRowHeight: a);
        j.setWidth(i.paperWidth);
        h.setWidth(b);
        c.setWidth(d);
        i.fitLockedColumnWidth(d);
        j.setTimeColumnWidth(g)
    },
    fitLockedColumnWidth: function(a) {
        var b = this.visibleColumns;
        if (b.length) {
            var d = a / b.length;
            for (var c = 0; c < b.length; c++) {
                b[c].column.setWidth(d)
            }
            this._restoreColumnWidth = true
        }
    },
    restoreComponentState: function() {
        this.callParent(arguments);
        if (this._restoreColumnWidth) {
            var b = this.visibleColumns;
            for (var c = 0; c < b.length; c++) {
                var a = b[c];
                a.column.setWidth(a.width);
                a.column.show()
            }
        }
    }
});
Ext.define("Sch.plugin.Export", {
    extend: "Ext.util.Observable",
    alternateClassName: "Sch.plugin.PdfExport",
    alias: "plugin.scheduler_export",
    mixins: ["Ext.AbstractPlugin", "Sch.mixin.Localizable"],
    requires: ["Ext.XTemplate", "Sch.plugin.exporter.SinglePage", "Sch.plugin.exporter.MultiPage", "Sch.plugin.exporter.MultiPageVertical"],
    lockableScope: "top",
    pageSizes: {
        A5: {
            width: 5.8,
            height: 8.3
        },
        A4: {
            width: 8.3,
            height: 11.7
        },
        A3: {
            width: 11.7,
            height: 16.5
        },
        Letter: {
            width: 8.5,
            height: 11
        },
        Legal: {
            width: 8.5,
            height: 14
        }
    },
    DPI: 72,
    printServer: undefined,
    timeout: 60000,
    headerTpl: null,
    headerTplDataFn: null,
    headerTplDataFnScope: null,
    tpl: null,
    footerTpl: null,
    footerTplDataFn: null,
    footerTplDataFnScope: null,
    exportDialogClassName: "Sch.widget.ExportDialog",
    exportDialogConfig: {},
    exporterConfig: null,
    exportConfig: {
        format: "A4",
        orientation: "portrait",
        range: "complete",
        showHeader: true,
        showFooter: false
    },
    expandAllBeforeExport: false,
    translateURLsToAbsolute: true,
    openAfterExport: true,
    beforeExport: Ext.emptyFn,
    afterExport: Ext.emptyFn,
    fileFormat: "pdf",
    defaultExporter: "multipage",
    exporters: undefined,
    callbacks: undefined,
    constructor: function(a) {
        var b = this;
        a = a || {};
        b.exportersIndex = {};
        if (a.exportDialogConfig) {
            Ext.Object.each(this.exportConfig,
            function(d, c, f) {
                var e = a.exportDialogConfig[d];
                if (e) {
                    f[d] = e
                }
            })
        }
        b.callParent([a]);
        b.setFileFormat(b.fileFormat);
        if (!b.exporters) {
            b.exporters = b.buildExporters()
        }
        b.initExporters();
        b.bindExporters()
    },
    init: function(a) {
        var b = this;
        a.showExportDialog = Ext.Function.bind(b.showExportDialog, b);
        a.doExport = Ext.Function.bind(b.doExport, b);
        b.scheduler = a
    },
    initExporters: function() {
        var c = this,
        b = c.exporters;
        for (var a = 0; a < b.length; a++) {
            if (! (b[a] instanceof Sch.plugin.exporter.AbstractExporter)) {
                b[a] = c.createExporter(b[a])
            }
        }
    },
    bindExporters: function() {
        var b = this.exporters;
        for (var a = 0; a < b.length; a++) {
            this.bindExporter(b[a])
        }
    },
    bindExporter: function(b) {
        var a = this;
        a.mon(b, {
            commitpage: a.onPageCommit,
            collectrows: a.onRowCollected,
            scope: a
        })
    },
    unbindExporter: function(b) {
        var a = this;
        a.mun(b, {
            commitpage: a.onPageCommit,
            collectrows: a.onRowCollected,
            scope: a
        })
    },
    buildExporters: function() {
        return ["Sch.plugin.exporter.SinglePage", "Sch.plugin.exporter.MultiPage", "Sch.plugin.exporter.MultiPageVertical"]
    },
    getExporterConfig: function(c, b) {
        var d = this;
        var a = Ext.apply({
            translateURLsToAbsolute: d.translateURLsToAbsolute,
            expandAllBeforeExport: d.expandAllBeforeExport,
            DPI: d.DPI
        },
        d.exporterConfig);
        if (d.headerTpl) {
            a.headerTpl = d.headerTpl
        }
        if (d.headerTplDataFn) {
            a.headerTplDataFn = d.headerTplDataFn;
            a.headerTplDataFnScope = d.headerTplDataFnScope
        }
        if (d.tpl) {
            a.tpl = d.tpl
        }
        if (d.footerTpl) {
            a.footerTpl = d.footerTpl
        }
        if (d.footerTplDataFn) {
            a.footerTplDataFn = d.footerTplDataFn;
            a.footerTplDataFnScope = d.footerTplDataFnScope
        }
        return a
    },
    createExporter: function(b, a) {
        var c = this,
        d = c.getExporterConfig(b, a);
        if (Ext.isObject(b)) {
            return Ext.create(Ext.apply(d, b))
        } else {
            return Ext.create(b, Ext.apply(d, a))
        }
    },
    registerExporter: function(b, a) {
        if (! (b instanceof Sch.plugin.exporter.AbstractExporter)) {
            b = this.createExporter.apply(this, arguments)
        }
        this.exporters.push(b);
        this.bindExporter(b)
    },
    getExporter: function(b) {
        if (!b) {
            return
        }
        var a = this.exportersIndex[b];
        if (a) {
            return a
        }
        a = this.exportersIndex[b] = Ext.Array.findBy(this.exporters,
        function(c) {
            return c.getExporterId() == b
        });
        return a
    },
    getExporters: function() {
        return this.exporters
    },
    setFileFormat: function(a) {
        if (typeof a !== "string") {
            this.fileFormat = "pdf"
        } else {
            a = a.toLowerCase();
            if (a === "png") {
                this.fileFormat = a
            } else {
                this.fileFormat = "pdf"
            }
        }
    },
    showExportDialog: function() {
        var b = this,
        a = b.scheduler.getSchedulingView();
        if (b.win) {
            b.win.destroy();
            b.win = null
        }
        b.win = Ext.create(b.exportDialogClassName, {
            plugin: b,
            exportDialogConfig: Ext.apply({
                startDate: b.scheduler.getStart(),
                endDate: b.scheduler.getEnd(),
                rowHeight: a.timeAxisViewModel.getViewRowHeight(),
                columnWidth: a.timeAxisViewModel.getTickWidth(),
                defaultExporter: b.defaultExporter,
                exporters: b.exporters,
                exportConfig: b.exportConfig
            },
            b.exportDialogConfig)
        });
        b.win.show()
    },
    getExportConfig: function(b) {
        var c = this;
        var a = Ext.apply({
            fileFormat: c.fileFormat,
            exporterId: c.defaultExporter,
            beforeExport: Ext.Function.bind(c.beforeExport, c),
            afterExport: Ext.Function.bind(c.afterExport, c)
        },
        b, c.exportConfig);
        a.DPI = a.DPI || c.DPI;
        a.pageSize = Ext.apply({},
        c.pageSizes[a.format]);
        a.pageSize.width *= a.DPI;
        a.pageSize.height *= a.DPI;
        return a
    },
    doExport: function(d, h, a, e) {
        var f = this,
        c = f.scheduler,
        b = f.getExportConfig(d);
        f.callbacks = {
            success: h || Ext.emptyFn,
            failure: a || Ext.emptyFn,
            scope: e || f
        };
        var g = f.exporter = f.getExporter(b.exporterId);
        if (g && f.fireEvent("beforeexport", c, g, b) !== false) {
            f.mask();
            f.exporter.extractPages(c, b,
            function(i) {
                f.fireEvent("updateprogressbar", 0.8, this.L("requestingPrintServer"));
                f.doRequest(i, b)
            },
            f)
        }
    },
    onRowCollected: function(c, d, b, a) {
        this.fireEvent("updateprogressbar", 0.2 * (b + 1) / a, Ext.String.format(this.L("fetchingRows"), b + 1, a))
    },
    onPageCommit: function(d, c, b, a) {
        a = Math.max(b, a);
        this.fireEvent("updateprogressbar", 0.2 + 0.6 * b / a, Ext.String.format(this.L("builtPage"), b, a))
    },
    onExportSuccess: function(a) {
        var e = this,
        f = e.getWin(),
        d = e.callbacks,
        c = d && d.success,
        b = d && d.scope || e;
        e.fireEvent("updateprogressbar", 1);
        e.unmask();
        c && c.apply(b, arguments);
        setTimeout(function() {
            e.fireEvent("hidedialogwindow", a);
            if (e.openAfterExport) {
                window.open(a.url, "ExportedPanel")
            }
        },
        f ? f.hideTime: 3000)
    },
    onExportFailure: function(f, a) {
        var e = this,
        g = this.getWin(),
        d = e.callbacks,
        c = d && d.failure,
        b = d && d.scope || e;
        c && c.call(b, f);
        e.fireEvent("showdialogerror", g, f, a);
        e.unmask()
    },
    doRequest: function(a, b) {
        var f = this,
        g = f.scheduler;
        if (!f.test && !f.debug) {
            if (f.printServer) {
                var j = {
                    type: "POST",
                    url: f.printServer,
                    timeout: f.timeout,
                    params: Ext.apply({
                        html: {
                            array: Ext.JSON.encode(a)
                        },
                        startDate: g.getStartDate(),
                        endDate: g.getEndDate(),
                        format: f.exporter.getPaperFormat(),
                        orientation: b.orientation,
                        range: b.range,
                        fileFormat: f.fileFormat
                    },
                    this.getParameters()),
                    success: f.onRequestSuccess,
                    failure: f.onRequestFailure,
                    scope: f
                };
                Ext.apply(j, this.getAjaxConfig(j));
                Ext.Ajax.request(j)
            } else {
                f.onExportFailure("Print server URL is not defined, please specify printServer config")
            }
        } else {
            if (f.debug) {
                var c = a || [];
                for (var e = 0,
                d = c.length; e < d; e++) {
                    var h = window.open();
                    h.document.write(c[e].html);
                    h.document.close()
                }
            }
            f.onExportSuccess(f.testResponse || {
                success: true,
                url: "foo",
                htmlArray: a
            })
        }
    },
    onRequestSuccess: function(b) {
        var c = this,
        a;
        try {
            a = Ext.JSON.decode(b.responseText)
        } catch(d) {
            c.onExportFailure("Wrong server response received");
            return
        }
        if (a.success) {
            c.onExportSuccess(a)
        } else {
            c.onExportFailure(a.msg, a)
        }
    },
    onRequestFailure: function(a) {
        var b = this,
        c = a.status === 200 ? a.responseText: a.statusText;
        b.onExportFailure(c, a)
    },
    getParameters: function() {
        return {}
    },
    getAjaxConfig: function(a) {
        return {}
    },
    getWin: function() {
        return this.win || null
    },
    mask: function() {
        var a = Ext.getBody().mask();
        a.addCls("sch-export-mask")
    },
    unmask: function() {
        Ext.getBody().unmask()
    },
    destroy: function() {
        this.callParent(arguments);
        if (this.win) {
            this.win.destroy()
        }
    }
});
Ext.define("Sch.plugin.HeaderZoom", {
    extend: "Sch.util.DragTracker",
    mixins: ["Ext.AbstractPlugin"],
    alias: "plugin.scheduler_headerzoom",
    lockableScope: "top",
    scheduler: null,
    proxy: null,
    headerRegion: null,
    init: function(a) {
        this.scheduler = a;
        this.onModeChange();
        a.on("modechange", this.onModeChange, this)
    },
    onOrientationChange: function() {
        return this.onModeChange.apply(this, arguments)
    },
    onModeChange: function() {
        var a = this.scheduler.down("timeaxiscolumn");
        if (a) {
            if (a.rendered) {
                this.onTimeAxisColumnRender(a)
            } else {
                a.on({
                    afterrender: this.onTimeAxisColumnRender,
                    scope: this
                })
            }
        }
    },
    onTimeAxisColumnRender: function(a) {
        this.proxy = a.el.createChild({
            cls: "sch-drag-selector"
        });
        this.initEl(a.el)
    },
    onStart: function(a) {
        this.proxy.show();
        this.headerRegion = this.scheduler.normalGrid.headerCt.getRegion()
    },
    onDrag: function(b) {
        var c = this.headerRegion;
        var a = this.getRegion().constrainTo(c);
        a.top = c.top;
        a.bottom = c.bottom;
        this.proxy.setBox(a)
    },
    onEnd: function(g) {
        if (this.proxy) {
            this.proxy.setDisplayed(false);
            var b = this.scheduler;
            var d = b.timeAxis;
            var f = this.getRegion();
            var c = b.getSchedulingView().timeAxisViewModel.getBottomHeader().unit;
            var a = b.getSchedulingView().getStartEndDatesFromRegion(f);
            b.zoomToSpan({
                start: d.floorDate(a.start, false, c, 1),
                end: d.ceilDate(a.end, false, c, 1)
            })
        }
    },
    destroy: function() {
        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null
        }
        this.callParent(arguments)
    }
});
Ext.define("Sch.widget.ResizePicker", {
    extend: "Ext.Panel",
    alias: "widget.dualrangepicker",
    width: 200,
    height: 200,
    border: true,
    collapsible: false,
    bodyStyle: "position:absolute; margin:5px",
    verticalCfg: {
        height: 120,
        value: 24,
        increment: 2,
        minValue: 20,
        maxValue: 80,
        reverse: true,
        disabled: true
    },
    horizontalCfg: {
        width: 120,
        value: 100,
        minValue: 25,
        increment: 5,
        maxValue: 200,
        disable: true
    },
    initComponent: function() {
        var a = this;
        a.horizontalCfg.value = a.dialogConfig.columnWidth;
        a.verticalCfg.value = a.dialogConfig.rowHeight;
        a.verticalCfg.disabled = a.dialogConfig.scrollerDisabled || false;
        a.dockedItems = [a.vertical = new Ext.slider.Single(Ext.apply({
            dock: "left",
            style: "margin-top:10px",
            vertical: true,
            listeners: {
                change: a.onSliderChange,
                changecomplete: a.onSliderChangeComplete,
                scope: a
            }
        },
        a.verticalCfg)), a.horizontal = new Ext.slider.Single(Ext.apply({
            dock: "top",
            style: "margin-left:28px",
            listeners: {
                change: a.onSliderChange,
                changecomplete: a.onSliderChangeComplete,
                scope: a
            }
        },
        a.horizontalCfg))];
        a.callParent(arguments)
    },
    afterRender: function() {
        var b = this;
        b.addCls("sch-ux-range-picker");
        b.valueHandle = this.body.createChild({
            cls: "sch-ux-range-value",
            cn: {
                tag: "span"
            }
        });
        b.valueSpan = this.valueHandle.down("span");
        var a = new Ext.dd.DD(this.valueHandle);
        Ext.apply(a, {
            startDrag: function() {
                b.dragging = true;
                this.constrainTo(b.body)
            },
            onDrag: function() {
                b.onHandleDrag.apply(b, arguments)
            },
            endDrag: function() {
                b.onHandleEndDrag.apply(b, arguments);
                b.dragging = false
            },
            scope: this
        });
        this.setValues(this.getValues());
        this.callParent(arguments);
        this.body.on("click", this.onBodyClick, this)
    },
    onBodyClick: function(c, a) {
        var b = [c.getXY()[0] - 8 - this.body.getX(), c.getXY()[1] - 8 - this.body.getY()];
        this.valueHandle.setLeft(Ext.Number.constrain(b[0], 0, this.getAvailableWidth()));
        this.valueHandle.setTop(Ext.Number.constrain(b[1], 0, this.getAvailableHeight()));
        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]));
        this.onSliderChangeComplete()
    },
    getAvailableWidth: function() {
        return this.body.getWidth() - 18
    },
    getAvailableHeight: function() {
        return this.body.getHeight() - 18
    },
    onHandleDrag: function() {
        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]))
    },
    onHandleEndDrag: function() {
        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]))
    },
    getValuesFromXY: function(d) {
        var c = d[0] / this.getAvailableWidth();
        var a = d[1] / this.getAvailableHeight();
        var e = Math.round((this.horizontalCfg.maxValue - this.horizontalCfg.minValue) * c);
        var b = Math.round((this.verticalCfg.maxValue - this.verticalCfg.minValue) * a) + this.verticalCfg.minValue;
        return [e + this.horizontalCfg.minValue, b]
    },
    getXYFromValues: function(d) {
        var b = this.horizontalCfg.maxValue - this.horizontalCfg.minValue;
        var f = this.verticalCfg.maxValue - this.verticalCfg.minValue;
        var a = Math.round((d[0] - this.horizontalCfg.minValue) * this.getAvailableWidth() / b);
        var c = d[1] - this.verticalCfg.minValue;
        var e = Math.round(c * this.getAvailableHeight() / f);
        return [a, e]
    },
    updatePosition: function() {
        var a = this.getValues();
        var b = this.getXYFromValues(a);
        this.valueHandle.setLeft(Ext.Number.constrain(b[0], 0, this.getAvailableWidth()));
        if (this.verticalCfg.disabled) {
            this.valueHandle.setTop(this.dialogConfig.rowHeight)
        } else {
            this.valueHandle.setTop(Ext.Number.constrain(b[1], 0, this.getAvailableHeight()))
        }
        this.positionValueText();
        this.setValueText(a)
    },
    positionValueText: function() {
        var a = this.valueHandle.getTop(true);
        var b = this.valueHandle.getLeft(true);
        this.valueSpan.setLeft(b > 30 ? -30 : 10);
        this.valueSpan.setTop(a > 10 ? -20 : 20)
    },
    setValueText: function(a) {
        if (this.verticalCfg.disabled) {
            a[1] = this.dialogConfig.rowHeight
        }
        this.valueSpan.update("[" + a.toString() + "]")
    },
    setValues: function(a) {
        this.horizontal.setValue(a[0]);
        if (this.verticalCfg.reverse) {
            if (!this.verticalCfg.disabled) {
                this.vertical.setValue(this.verticalCfg.maxValue + this.verticalCfg.minValue - a[1])
            }
        } else {
            if (!this.verticalCfg.disabled) {
                this.vertical.setValue(a[1])
            }
        }
        if (!this.dragging) {
            this.updatePosition()
        }
        this.positionValueText();
        this.setValueText(a)
    },
    getValues: function() {
        if (!this.verticalCfg.disabled) {
            var a = this.vertical.getValue();
            if (this.verticalCfg.reverse) {
                a = this.verticalCfg.maxValue - a + this.verticalCfg.minValue
            }
            return [this.horizontal.getValue(), a]
        }
        return [this.horizontal.getValue()]
    },
    onSliderChange: function() {
        this.fireEvent("change", this, this.getValues());
        if (!this.dragging) {
            this.updatePosition()
        }
    },
    onSliderChangeComplete: function() {
        this.fireEvent("changecomplete", this, this.getValues())
    },
    afterLayout: function() {
        this.callParent(arguments);
        this.updatePosition()
    }
});
Ext.define("Sch.widget.ExportDialogForm", {
    extend: "Ext.form.Panel",
    requires: ["Ext.data.Store", "Ext.ProgressBar", "Ext.form.field.ComboBox", "Ext.form.field.Date", "Ext.form.FieldContainer", "Ext.form.field.Checkbox", "Sch.widget.ResizePicker"],
    border: false,
    bodyPadding: "10 10 0 10",
    autoHeight: true,
    initComponent: function() {
        var a = this;
        a.fieldDefaults = Ext.applyIf(a.fieldDefaults || {},
        {
            labelAlign: "left",
            labelWidth: 120,
            anchor: "99%"
        });
        a.items = a.createFields();
        a.items.push(a.progressBar || a.createProgressBar());
        a.callParent(arguments);
        a.onRangeChange(null, a.dialogConfig.exportConfig.range);
        a.onExporterChange(a.exportersField, a.exportersField.getValue());
        a.on({
            hideprogressbar: a.hideProgressBar,
            showprogressbar: a.showProgressBar,
            updateprogressbar: a.updateProgressBar,
            scope: a
        })
    },
    isValid: function() {
        var a = this;
        if (a.rangeField.getValue() === "date") {
            return a.dateFromField.isValid() && a.dateToField.isValid()
        }
        return true
    },
    getValues: function(e, c, d, b) {
        var a = this.callParent(arguments);
        var f = this.resizePicker.getValues();
        if (!e) {
            a.cellSize = f
        } else {
            a += "&cellSize[0]=" + f[0] + "&cellSize[1]=" + f[1]
        }
        return a
    },
    createFields: function() {
        var d = this,
        a = d.dialogConfig,
        f = '<table class="sch-fieldcontainer-label-wrap"><td width="1" class="sch-fieldcontainer-label">',
        e = '<td><div class="sch-fieldcontainer-separator"></div></table>';
        d.rangeField = new Ext.form.field.ComboBox({
            value: a.exportConfig.range,
            triggerAction: "all",
            cls: "sch-export-dialog-range",
            forceSelection: true,
            editable: false,
            fieldLabel: a.rangeFieldLabel,
            name: "range",
            queryMode: "local",
            displayField: "name",
            valueField: "value",
            store: new Ext.data.Store({
                fields: ["name", "value"],
                data: [{
                    name: a.completeViewText,
                    value: "complete"
                },
                {
                    name: a.dateRangeText,
                    value: "date"
                },
                {
                    name: a.currentViewText,
                    value: "current"
                }]
            }),
            listeners: {
                change: d.onRangeChange,
                scope: d
            }
        });
        d.resizePicker = new Sch.widget.ResizePicker({
            dialogConfig: a,
            margin: "10 20"
        });
        d.resizerHolder = new Ext.form.FieldContainer({
            fieldLabel: a.scrollerDisabled ? a.adjustCols: a.adjustColsAndRows,
            labelAlign: "top",
            hidden: true,
            labelSeparator: "",
            beforeLabelTextTpl: f,
            afterLabelTextTpl: e,
            layout: "vbox",
            defaults: {
                flex: 1,
                allowBlank: false
            },
            items: [d.resizePicker]
        });
        d.dateFromField = new Ext.form.field.Date({
            fieldLabel: a.dateRangeFromText,
            baseBodyCls: "sch-exportdialogform-date",
            name: "dateFrom",
            format: a.dateRangeFormat || Ext.Date.defaultFormat,
            allowBlank: false,
            maxValue: a.endDate,
            minValue: a.startDate,
            value: a.startDate
        });
        d.dateToField = new Ext.form.field.Date({
            fieldLabel: a.dateRangeToText,
            name: "dateTo",
            format: a.dateRangeFormat || Ext.Date.defaultFormat,
            baseBodyCls: "sch-exportdialogform-date",
            allowBlank: false,
            maxValue: a.endDate,
            minValue: a.startDate,
            value: a.endDate
        });
        d.datesHolder = new Ext.form.FieldContainer({
            fieldLabel: a.specifyDateRange,
            labelAlign: "top",
            hidden: true,
            labelSeparator: "",
            beforeLabelTextTpl: f,
            afterLabelTextTpl: e,
            layout: "vbox",
            defaults: {
                flex: 1,
                allowBlank: false
            },
            items: [d.dateFromField, d.dateToField]
        });
        d.showHeaderField = new Ext.form.field.Checkbox({
            xtype: "checkboxfield",
            fieldLabel: d.dialogConfig.showHeaderLabel,
            name: "showHeader",
            checked: !!a.exportConfig.showHeader,
            checkedValue: true,
            uncheckedValue: false
        });
        d.exportersField = new Ext.form.field.ComboBox({
            value: a.defaultExporter,
            triggerAction: "all",
            cls: "sch-export-dialog-exporter",
            forceSelection: true,
            editable: false,
            fieldLabel: a.exportersFieldLabel,
            name: "exporterId",
            queryMode: "local",
            displayField: "name",
            valueField: "value",
            store: d.buildExporterStore(a.exporters),
            listeners: {
                change: d.onExporterChange,
                scope: d
            }
        });
        d.formatField = new Ext.form.field.ComboBox({
            value: a.exportConfig.format,
            triggerAction: "all",
            forceSelection: true,
            editable: false,
            fieldLabel: a.formatFieldLabel,
            name: "format",
            queryMode: "local",
            store: a.pageFormats || ["A5", "A4", "A3", "Letter", "Legal"]
        });
        var c = a.exportConfig.orientation === "portrait" ? 'class="sch-none"': "",
        b = a.exportConfig.orientation === "landscape" ? 'class="sch-none"': "";
        d.orientationField = new Ext.form.field.ComboBox({
            value: a.exportConfig.orientation,
            triggerAction: "all",
            componentCls: "sch-exportdialogform-orientation",
            forceSelection: true,
            editable: false,
            fieldLabel: d.dialogConfig.orientationFieldLabel,
            afterSubTpl: new Ext.XTemplate('<span id="sch-exportdialog-imagePortrait" ' + b + '></span><span id="sch-exportdialog-imageLandscape" ' + c + "></span>"),
            name: "orientation",
            displayField: "name",
            valueField: "value",
            queryMode: "local",
            store: new Ext.data.Store({
                fields: ["name", "value"],
                data: [{
                    name: a.orientationPortraitText,
                    value: "portrait"
                },
                {
                    name: a.orientationLandscapeText,
                    value: "landscape"
                }]
            }),
            listeners: {
                change: function(h, g) {
                    switch (g) {
                    case "landscape":
                        Ext.fly("sch-exportdialog-imagePortrait").toggleCls("sch-none");
                        Ext.fly("sch-exportdialog-imageLandscape").toggleCls("sch-none");
                        break;
                    case "portrait":
                        Ext.fly("sch-exportdialog-imagePortrait").toggleCls("sch-none");
                        Ext.fly("sch-exportdialog-imageLandscape").toggleCls("sch-none");
                        break
                    }
                }
            }
        });
        return [d.rangeField, d.resizerHolder, d.datesHolder, d.exportersField, d.formatField, d.orientationField, d.showHeaderField]
    },
    buildExporterStore: function(c) {
        var e = [];
        for (var b = 0,
        a = c.length; b < a; b++) {
            var d = c[b];
            e.push({
                name: d.getName(),
                value: d.getExporterId()
            })
        }
        return Ext.create("Ext.data.Store", {
            fields: ["name", "value"],
            data: e
        })
    },
    createProgressBar: function() {
        return this.progressBar = new Ext.ProgressBar({
            text: this.config.progressBarText,
            animate: true,
            hidden: true,
            margin: "4px 0 10px 0"
        })
    },
    onRangeChange: function(b, a) {
        switch (a) {
        case "complete":
            this.datesHolder.hide();
            this.resizerHolder.hide();
            break;
        case "date":
            this.datesHolder.show();
            this.resizerHolder.hide();
            break;
        case "current":
            this.datesHolder.hide();
            this.resizerHolder.show();
            this.resizePicker.expand(true);
            break
        }
    },
    onExporterChange: function(b, a) {
        switch (a) {
        case "singlepage":
            this.disableFields(true);
            break;
        default:
            this.disableFields(false)
        }
    },
    disableFields: function(b) {
        var a = this;
        a.showHeaderField.setDisabled(b);
        a.formatField.setDisabled(b);
        a.orientationField.setDisabled(b)
    },
    showProgressBar: function() {
        if (this.progressBar) {
            this.progressBar.show()
        }
    },
    hideProgressBar: function() {
        if (this.progressBar) {
            this.progressBar.hide()
        }
    },
    updateProgressBar: function(a, b) {
        if (this.progressBar) {
            this.progressBar.updateProgress(a);
            if (b) {
                this.progressBar.updateText(b)
            }
        }
    }
});
Ext.define("Sch.widget.ExportDialog", {
    alternateClassName: "Sch.widget.PdfExportDialog",
    extend: "Ext.window.Window",
    requires: ["Sch.widget.ExportDialogForm"],
    mixins: ["Sch.mixin.Localizable"],
    alias: "widget.exportdialog",
    modal: false,
    width: 350,
    cls: "sch-exportdialog",
    frame: false,
    layout: "fit",
    draggable: true,
    padding: 0,
    myConfig: null,
    plugin: null,
    buttonsPanel: null,
    buttonsPanelScope: null,
    progressBar: null,
    dateRangeFormat: "",
    constructor: function(a) {
        Ext.apply(this, a.exportDialogConfig);
        this.plugin = a.plugin;
        this.title = this.L("title");
        this.myConfig = Ext.apply({
            progressBarText: this.L("progressBarText"),
            dateRangeToText: this.L("dateRangeToText"),
            pickerText: this.L("pickerText"),
            dateRangeFromText: this.L("dateRangeFromText"),
            dateRangeText: this.L("dateRangeText"),
            currentViewText: this.L("currentViewText"),
            formatFieldLabel: this.L("formatFieldLabel"),
            orientationFieldLabel: this.L("orientationFieldLabel"),
            rangeFieldLabel: this.L("rangeFieldLabel"),
            showHeaderLabel: this.L("showHeaderLabel"),
            exportersFieldLabel: this.L("exportersFieldLabel"),
            orientationPortraitText: this.L("orientationPortraitText"),
            orientationLandscapeText: this.L("orientationLandscapeText"),
            completeViewText: this.L("completeViewText"),
            adjustCols: this.L("adjustCols"),
            adjustColsAndRows: this.L("adjustColsAndRows"),
            specifyDateRange: this.L("specifyDateRange"),
            dateRangeFormat: this.dateRangeFormat,
            exportConfig: this.exportConfig,
            pageFormats: this.getPageFormats()
        },
        a.exportDialogConfig);
        this.callParent(arguments)
    },
    getPageFormats: function() {
        var b = this.plugin.pageSizes,
        d = [];
        Ext.Object.each(b,
        function(e, f) {
            d.push({
                width: f.width,
                height: f.height,
                name: e
            })
        });
        d.sort(function(f, e) {
            return f.width - e.width
        });
        var a = [];
        for (var c = 0; c < d.length; c++) {
            a.push(d[c].name)
        }
        return a
    },
    initComponent: function() {
        var b = this,
        a = {
            hidedialogwindow: b.destroy,
            showdialogerror: b.showError,
            updateprogressbar: function(c, d) {
                if (arguments.length == 2) {
                    b.fireEvent("updateprogressbar", c, undefined)
                } else {
                    b.fireEvent("updateprogressbar", c, d)
                }
            },
            scope: this
        };
        b.form = b.buildForm(b.myConfig);
        Ext.apply(this, {
            items: b.form,
            fbar: b.buildButtons(b.buttonsPanelScope || b)
        });
        b.callParent(arguments);
        b.plugin.on(a)
    },
    afterRender: function() {
        var a = this;
        a.relayEvents(a.form.resizePicker, ["change", "changecomplete", "select"]);
        a.form.relayEvents(a, ["updateprogressbar", "hideprogressbar", "showprogressbar"]);
        a.callParent(arguments)
    },
    buildButtons: function(a) {
        return [{
            xtype: "button",
            scale: "medium",
            text: this.L("exportButtonText"),
            handler: function() {
                if (this.form.isValid()) {
                    this.fireEvent("showprogressbar");
                    var c = this.form.getValues();
                    c.exporterId = c.exporterId;
                    var b = this.dateRangeFormat || Ext.Date.defaultFormat;
                    if (c.dateFrom && !Ext.isDate(c.dateFrom)) {
                        c.dateFrom = Ext.Date.parse(c.dateFrom, b)
                    }
                    if (c.dateTo && !Ext.isDate(c.dateTo)) {
                        c.dateTo = Ext.Date.parse(c.dateTo, b)
                    }
                    this.plugin.doExport(c)
                }
            },
            scope: a
        },
        {
            xtype: "button",
            scale: "medium",
            text: this.L("cancelButtonText"),
            handler: function() {
                this.destroy()
            },
            scope: a
        }]
    },
    buildForm: function(a) {
        return new Sch.widget.ExportDialogForm({
            progressBar: this.progressBar,
            dialogConfig: a
        })
    },
    showError: function(b, a) {
        var c = b,
        d = a || c.L("generalError");
        c.fireEvent("hideprogressbar");
        Ext.Msg.alert("", d)
    }
});
Ext.define("Gnt.locale.En", {
    extend: "Sch.locale.Locale",
    requires: "Sch.locale.En",
    singleton: true,
    constructor: function(a) {
        Ext.apply(this, {
            l10n: {
                "Gnt.util.DurationParser": {
                    unitsRegex: {
                        MILLI: /^ms$|^mil/i,
                        SECOND: /^s$|^sec/i,
                        MINUTE: /^m$|^min/i,
                        HOUR: /^h$|^hr$|^hour/i,
                        DAY: /^d$|^day/i,
                        WEEK: /^w$|^wk|^week/i,
                        MONTH: /^mo|^mnt/i,
                        QUARTER: /^q$|^quar|^qrt/i,
                        YEAR: /^y$|^yr|^year/i
                    }
                },
                "Gnt.util.DependencyParser": {
                    typeText: {
                        SS: "SS",
                        SF: "SF",
                        FS: "FS",
                        FF: "FF"
                    }
                },
                "Gnt.field.ConstraintType": {
                    none: "None"
                },
                "Gnt.field.Duration": {
                    invalidText: "Invalid value"
                },
                "Gnt.field.Effort": {
                    invalidText: "Invalid value"
                },
                "Gnt.field.Percent": {
                    invalidText: "Invalid value"
                },
                "Gnt.feature.DependencyDragDrop": {
                    fromText: "From",
                    toText: "To",
                    startText: "Start",
                    endText: "End"
                },
                "Gnt.Tooltip": {
                    startText: "Starts: ",
                    endText: "Ends: ",
                    durationText: "Duration: "
                },
                "Gnt.plugin.TaskContextMenu": {
                    taskInformation: "Task information...",
                    newTaskText: "New task",
                    deleteTask: "Delete task(s)",
                    editLeftLabel: "Edit left label",
                    editRightLabel: "Edit right label",
                    add: "Add...",
                    deleteDependency: "Delete dependency...",
                    addTaskAbove: "Task above",
                    addTaskBelow: "Task below",
                    addMilestone: "Milestone",
                    addSubtask: "Sub-task",
                    addSuccessor: "Successor",
                    addPredecessor: "Predecessor",
                    convertToMilestone: "Convert to milestone",
                    convertToRegular: "Convert to regular task",
                    splitTask: "Split task"
                },
                "Gnt.plugin.DependencyEditor": {
                    fromText: "From",
                    toText: "To",
                    typeText: "Type",
                    lagText: "Lag",
                    endToStartText: "Finish-To-Start",
                    startToStartText: "Start-To-Start",
                    endToEndText: "Finish-To-Finish",
                    startToEndText: "Start-To-Finish"
                },
                "Gnt.widget.calendar.Calendar": {
                    dayOverrideNameHeaderText: "Name",
                    overrideName: "Name",
                    startDate: "Start Date",
                    endDate: "End Date",
                    error: "Error",
                    dateText: "Date",
                    addText: "Add",
                    editText: "Edit",
                    removeText: "Remove",
                    workingDayText: "Working day",
                    weekendsText: "Weekends",
                    overriddenDayText: "Overridden day",
                    overriddenWeekText: "Overridden week",
                    workingTimeText: "Working time",
                    nonworkingTimeText: "Non-working time",
                    dayOverridesText: "Day overrides",
                    weekOverridesText: "Week overrides",
                    okText: "OK",
                    cancelText: "Cancel",
                    parentCalendarText: "Parent calendar",
                    noParentText: "No parent",
                    selectParentText: "Select parent",
                    newDayName: "[Without name]",
                    calendarNameText: "Calendar name",
                    tplTexts: {
                        tplWorkingHours: "Working hours for",
                        tplIsNonWorking: "is non-working",
                        tplOverride: "override",
                        tplInCalendar: "in calendar",
                        tplDayInCalendar: "standard day in calendar",
                        tplBasedOn: "Based on"
                    },
                    overrideErrorText: "There is already an override for this day",
                    overrideDateError: "There is already a week override on this date: {0}",
                    startAfterEndError: "Start date should be less than end date",
                    weeksIntersectError: "Week overrides should not intersect"
                },
                "Gnt.widget.calendar.AvailabilityGrid": {
                    startText: "Start",
                    endText: "End",
                    addText: "Add",
                    removeText: "Remove",
                    error: "Error"
                },
                "Gnt.widget.calendar.DayEditor": {
                    workingTimeText: "Working time",
                    nonworkingTimeText: "Non-working time"
                },
                "Gnt.widget.calendar.WeekEditor": {
                    defaultTimeText: "Default time",
                    workingTimeText: "Working time",
                    nonworkingTimeText: "Non-working time",
                    error: "Error",
                    noOverrideError: "Week override contains only 'default' days - can't save it"
                },
                "Gnt.widget.calendar.ResourceCalendarGrid": {
                    name: "Name",
                    calendar: "Calendar"
                },
                "Gnt.widget.calendar.CalendarWindow": {
                    ok: "Ok",
                    cancel: "Cancel"
                },
                "Gnt.widget.calendar.CalendarManager": {
                    addText: "Add",
                    removeText: "Remove",
                    add_child: "Add child",
                    add_node: "Add calendar",
                    add_sibling: "Add sibling",
                    remove: "Remove",
                    calendarName: "Calendar",
                    confirm_action: "Confirm action",
                    confirm_message: "Calendar has unsaved changes. Would you like to save your changes?"
                },
                "Gnt.widget.calendar.CalendarManagerWindow": {
                    ok: "Apply changes",
                    cancel: "Close"
                },
                "Gnt.field.Assignment": {
                    cancelText: "Cancel",
                    closeText: "Save and Close"
                },
                "Gnt.column.AssignmentUnits": {
                    text: "Units"
                },
                "Gnt.column.Duration": {
                    text: "Duration"
                },
                "Gnt.column.Effort": {
                    text: "Effort"
                },
                "Gnt.column.EndDate": {
                    text: "Finish"
                },
                "Gnt.column.PercentDone": {
                    text: "% Done"
                },
                "Gnt.column.ResourceAssignment": {
                    text: "Assigned Resources"
                },
                "Gnt.column.ResourceName": {
                    text: "Resource Name"
                },
                "Gnt.column.Rollup": {
                    text: "Rollup task",
                    no: "No",
                    yes: "Yes"
                },
                "Gnt.column.SchedulingMode": {
                    text: "Mode"
                },
                "Gnt.column.Predecessor": {
                    text: "Predecessors"
                },
                "Gnt.column.Successor": {
                    text: "Successors"
                },
                "Gnt.column.StartDate": {
                    text: "Start"
                },
                "Gnt.column.WBS": {
                    text: "WBS"
                },
                "Gnt.column.Sequence": {
                    text: "#"
                },
                "Gnt.column.Calendar": {
                    text: "Calendar"
                },
                "Gnt.widget.taskeditor.TaskForm": {
                    taskNameText: "Name",
                    durationText: "Duration",
                    datesText: "Dates",
                    baselineText: "Baseline",
                    startText: "Start",
                    finishText: "Finish",
                    percentDoneText: "Percent Complete",
                    baselineStartText: "Start",
                    baselineFinishText: "Finish",
                    baselinePercentDoneText: "Percent Complete",
                    effortText: "Effort",
                    invalidEffortText: "Invalid effort value",
                    calendarText: "Calendar",
                    schedulingModeText: "Scheduling Mode",
                    rollupText: "Rollup",
                    wbsCodeText: "WBS code",
                    "Constraint Type": "Constraint Type",
                    "Constraint Date": "Constraint Date"
                },
                "Gnt.widget.DependencyGrid": {
                    idText: "ID",
                    snText: "SN",
                    taskText: "Task Name",
                    blankTaskText: "Please select task",
                    invalidDependencyText: "Invalid dependency",
                    parentChildDependencyText: "Dependency between child and parent found",
                    duplicatingDependencyText: "Duplicate dependency found",
                    transitiveDependencyText: "Transitive dependency",
                    cyclicDependencyText: "Cyclic dependency",
                    typeText: "Type",
                    lagText: "Lag",
                    clsText: "CSS class",
                    endToStartText: "Finish-To-Start",
                    startToStartText: "Start-To-Start",
                    endToEndText: "Finish-To-Finish",
                    startToEndText: "Start-To-Finish"
                },
                "Gnt.widget.AssignmentEditGrid": {
                    confirmAddResourceTitle: "Confirm",
                    confirmAddResourceText: "Resource &quot;{0}&quot; not found in list. Would you like to add it?",
                    noValueText: "Please select resource to assign",
                    noResourceText: "No resource &quot;{0}&quot; found in the list"
                },
                "Gnt.widget.taskeditor.TaskEditor": {
                    generalText: "General",
                    resourcesText: "Resources",
                    dependencyText: "Predecessors",
                    addDependencyText: "Add new",
                    dropDependencyText: "Remove",
                    notesText: "Notes",
                    advancedText: "Advanced",
                    addAssignmentText: "Add new",
                    dropAssignmentText: "Remove"
                },
                "Gnt.plugin.TaskEditor": {
                    title: "Task Information",
                    alertCaption: "Information",
                    alertText: "Please correct marked errors to save changes",
                    okText: "Ok",
                    cancelText: "Cancel"
                },
                "Gnt.field.EndDate": {
                    endBeforeStartText: "End date is before start date"
                },
                "Gnt.column.Note": {
                    text: "Note"
                },
                "Gnt.column.AddNew": {
                    text: "Add new column..."
                },
                "Gnt.column.EarlyStartDate": {
                    text: "Early Start"
                },
                "Gnt.column.EarlyEndDate": {
                    text: "Early Finish"
                },
                "Gnt.column.LateStartDate": {
                    text: "Late Start"
                },
                "Gnt.column.LateEndDate": {
                    text: "Late Finish"
                },
                "Gnt.field.Calendar": {
                    calendarNotApplicable: "Task calendar has no overlapping with assigned resources calendars"
                },
                "Gnt.column.Slack": {
                    text: "Slack"
                },
                "Gnt.column.Name": {
                    text: "Task Name"
                },
                "Gnt.column.BaselineStartDate": {
                    text: "Baseline Start Date"
                },
                "Gnt.column.BaselineEndDate": {
                    text: "Baseline End Date"
                },
                "Gnt.column.Milestone": {
                    text: "Milestone"
                },
                "Gnt.field.Milestone": {
                    yes: "Yes",
                    no: "No"
                },
                "Gnt.field.Dependency": {
                    invalidFormatText: "Invalid dependency format",
                    invalidDependencyText: "Invalid dependency found, please make sure you have no cyclic paths between your tasks",
                    invalidDependencyType: "Invalid dependency type {0}. Allowed values are: {1}."
                },
                "Gnt.constraint.Base": {
                    name: "A constraint",
                    "Remove the constraint": "Remove the constraint",
                    "Cancel the change and do nothing": "Cancel the change and do nothing"
                },
                "Gnt.constraint.FinishNoEarlierThan": {
                    name: "Finish no earlier than",
                    "Move the task to finish on {0}": "Move the task to finish on {0}"
                },
                "Gnt.constraint.FinishNoLaterThan": {
                    name: "Finish no later than",
                    "Move the task to finish on {0}": "Move the task to finish on {0}"
                },
                "Gnt.constraint.MustFinishOn": {
                    name: "Must finish on",
                    "Move the task to finish on {0}": "Move the task to finish on {0}"
                },
                "Gnt.constraint.MustStartOn": {
                    name: "Must start on",
                    "Move the task to start at {0}": "Move the task to start at {0}"
                },
                "Gnt.constraint.StartNoEarlierThan": {
                    name: "Start no earlier than",
                    "Move the task to start at {0}": "Move the task to start at {0}"
                },
                "Gnt.constraint.StartNoLaterThan": {
                    name: "Start no later than",
                    "Move the task to start at {0}": "Move the task to start at {0}"
                },
                "Gnt.column.ConstraintDate": {
                    text: "Constraint date"
                },
                "Gnt.column.ConstraintType": {
                    text: "Constraint"
                },
                "Gnt.widget.ConstraintResolutionForm": {
                    dateFormat: "m/d/Y",
                    OK: "OK",
                    Cancel: "Cancel",
                    "Resolution options": "Resolution options",
                    "Don't ask again": "Don't ask again",
                    "Task {0} violates constraint {1}": 'Task "{0}" violates constraint {1}',
                    "Task {0} violates constraint {1} {2}": 'Task "{0}" violates constraint {1} {2}'
                },
                "Gnt.widget.ConstraintResolutionWindow": {
                    "Constraint violation": "Constraint violation"
                }
            }
        });
        this.callParent(arguments)
    }
});
Ext.define("Gnt.mixin.Localizable", {
    extend: "Sch.mixin.Localizable",
    requires: ["Gnt.locale.En"]
});
Ext.define("Gnt.constraint.Base", {
    mixins: ["Gnt.mixin.Localizable"],
    l10n: {
        name: "A constraint",
        "Remove the constraint": "Remove the constraint",
        "Cancel the change and do nothing": "Cancel the change and do nothing"
    },
    isSatisfied: function(b, c, a) {
        throw "Abstract method"
    },
    getResolution: function(f, a, b) {
        var e = this,
        d = false;
        b = b || a.getConstraintDate();
        var c = function() {
            if (!d) {
                d = true;
                f.apply(this, arguments)
            }
        };
        return {
            title: e.L("name"),
            task: a,
            date: b,
            resolutions: [{
                id: "cancel",
                title: e.L("Cancel the change and do nothing"),
                resolve: function() {
                    c(true)
                }
            }].concat(this.getResolutionOptions(c, a, b)),
            getCancelActionOption: function() {
                return this.resolutions[0]
            },
            cancelAction: function() {
                return this.getCancelActionOption().resolve()
            },
            proceedAction: function() {
                c()
            },
            getResolution: function(g) {
                return Ext.Array.findBy(this.resolutions,
                function(h) {
                    return h.id == g
                })
            }
        }
    },
    getResolutionOptions: function(d, b, c, a) {
        return []
    },
    hasThisConstraintApplied: function(a) {
        return a.getConstraintClass() === this
    },
    getInitialConstraintDate: function(a) {
        return a.getConstraintDate()
    },
    getDisplayableConstraintDateForFormat: function(b, c, a) {
        return b
    },
    adjustConstraintDateFromDisplayableWithFormat: function(b, c, a) {
        return b
    },
    shiftToNearestValidConstraintDate: function(b, c, a) {
        return b
    },
    statics: {
        getConstraintClass: function(b) {
            var a = !Ext.isEmpty(b) && Ext.ClassManager.getByAlias("gntconstraint." + b);
            return a || null
        }
    }
});
Ext.define("Gnt.constraint.StartNoEarlierThan", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.startnoearlierthan",
    singleton: true,
    requires: ["Sch.util.Date"],
    l10n: {
        name: "Start no earlier than",
        "Move the task to start at {0}": "Move the task to start at {0}"
    },
    isSatisfied: function(c, d, b) {
        var a = c.getStartDate();
        d = d || c.getConstraintDate();
        return ! d || !a || (Sch.util.Date.compareWithPrecision(a, d, b) !== -1)
    },
    getResolutionOptions: function(f, c, d, b) {
        var e = this,
        a = [];
        d = d || c.getConstraintDate();
        e.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function() {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task",
            title: e.L("Move the task to start at {0}"),
            resolve: function() {
                c.setStartDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function(a) {
        return a.getStartDate()
    }
});
Ext.define("Gnt.constraint.StartNoLaterThan", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.startnolaterthan",
    singleton: true,
    requires: ["Sch.util.Date"],
    l10n: {
        name: "Start no later than",
        "Move the task to start at {0}": "Move the task to start at {0}"
    },
    isSatisfied: function(c, d, b) {
        var a = c.getStartDate();
        d = d || c.getConstraintDate();
        return ! d || !a || (Sch.util.Date.compareWithPrecision(a, d, b) !== 1)
    },
    getResolutionOptions: function(f, c, d, b) {
        var e = this,
        a = [];
        d = d || c.getConstraintDate();
        e.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function() {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task",
            title: e.L("Move the task to start at {0}"),
            resolve: function() {
                c.setStartDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function(a) {
        return a.getStartDate()
    }
});
Ext.define("Gnt.constraint.FinishNoEarlierThan", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.finishnoearlierthan",
    singleton: true,
    requires: ["Sch.util.Date"],
    isSatisfied: function(a, b) {
        var c = a.getEndDate();
        b = b || a.getConstraintDate();
        return ! b || !c || c >= b
    },
    getResolutionOptions: function(f, c, d, b) {
        var e = this,
        a = [];
        d = d || c.getConstraintDate();
        e.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function() {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task",
            title: e.L("Move the task to finish on {0}"),
            resolve: function() {
                c.setEndDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function(a) {
        return a.getEndDate()
    },
    getDisplayableConstraintDateForFormat: function(b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, -1)
        }
        return b
    },
    adjustConstraintDateFromDisplayableWithFormat: function(b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, 1)
        }
        return b
    }
});
Ext.define("Gnt.constraint.FinishNoLaterThan", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.finishnolaterthan",
    singleton: true,
    requires: ["Sch.util.Date"],
    isSatisfied: function(b, c, a) {
        var d = b.getEndDate();
        c = c || b.getConstraintDate();
        return ! c || !d || (Sch.util.Date.compareWithPrecision(d, c, a) !== 1)
    },
    getResolutionOptions: function(f, c, d, b) {
        var e = this,
        a = [];
        d = d || c.getConstraintDate();
        e.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function() {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task",
            title: e.L("Move the task to finish on {0}"),
            resolve: function() {
                c.setEndDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function(a) {
        return a.getEndDate()
    },
    getDisplayableConstraintDateForFormat: function(b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, -1)
        }
        return b
    },
    adjustConstraintDateFromDisplayableWithFormat: function(b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, 1)
        }
        return b
    }
});
Ext.define("Gnt.constraint.MustStartOn", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.muststarton",
    singleton: true,
    requires: ["Sch.util.Date"],
    l10n: {
        name: "Must start on",
        "Move the task to start at {0}": "Move the task to start at {0}"
    },
    isSatisfied: function(c, d, b) {
        var a = c.getStartDate();
        d = d || c.getConstraintDate();
        return ! d || !a || (Sch.util.Date.compareWithPrecision(a, d, b) === 0)
    },
    getResolutionOptions: function(f, c, d, b) {
        var e = this,
        a = [];
        d = d || c.getConstraintDate();
        this.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function() {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task",
            title: e.L("Move the task to start at {0}"),
            resolve: function() {
                c.setStartDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function(a) {
        return a.getStartDate()
    }
});
Ext.define("Gnt.constraint.MustFinishOn", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.mustfinishon",
    singleton: true,
    requires: ["Sch.util.Date"],
    l10n: {
        name: "Must finish on",
        "Move the task to finish on {0}": "Move the task to finish on {0}"
    },
    isSatisfied: function(b, c, a) {
        var d = b.getEndDate();
        c = c || b.getConstraintDate();
        return ! c || !d || (Sch.util.Date.compareWithPrecision(d, c, a) === 0)
    },
    getResolutionOptions: function(f, c, d, b) {
        var e = this,
        a = [];
        d = d || c.getConstraintDate();
        e.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function() {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task",
            title: e.L("Move the task to finish on {0}"),
            resolve: function() {
                c.setEndDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function(a) {
        return a.getEndDate()
    },
    getDisplayableConstraintDateForFormat: function(b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, -1)
        }
        return b
    },
    adjustConstraintDateFromDisplayableWithFormat: function(b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, 1)
        }
        return b
    }
});
Ext.define("Gnt.model.mixin.ProjectableModel",
function() {
    var e = {};
    function c() {
        Ext.override(this, e)
    }
    function a(g) {
        return this.data[g]
    }
    function d() {
        var i = this,
        h = i.getTreeStore && i.getTreeStore() || i.store,
        g = h && h.getProjection && h.getProjection();
        return g && g.hasOwnProperty(i.internalId) ? true: false
    }
    e.get = function b(m) {
        var j = this,
        i = j.getTreeStore && j.getTreeStore() || j.store,
        g = i && i.getProjection && i.getProjection(),
        h = j.internalId,
        l,
        k;
        if (g && g.hasOwnProperty(h)) {
            l = g[h];
            if (m in l) {
                k = l[m]
            } else {
                k = j.callParent([m])
            }
        } else {
            k = j.callParent([m])
        }
        return k
    };
    e.set = function f(q, n) {
        var m = this,
        o = m.getTreeStore && m.getTreeStore() || m.store,
        j = o && o.getProjection && o.getProjection(),
        k = m.internalId,
        i,
        g,
        r,
        p,
        h,
        l;
        if (j) {
            r = [];
            if (arguments.length == 1) {
                for (g in q) {
                    if (q.hasOwnProperty(g)) {
                        n = q[g];
                        p = m.get(g);
                        l = (n !== undefined && n !== null) ? (n).valueOf() : n;
                        h = (p !== undefined && p !== null) ? (p).valueOf() : p;
                        if (((l === undefined || l === null) && l !== h) || l != h) {
                            i = j[k] = j.hasOwnProperty(k) && j[k] || {};
                            i[g] = n;
                            r.push(g)
                        }
                    }
                }
            } else {
                if (arguments.length == 2) {
                    p = m.get(q);
                    l = (n !== undefined && n !== null) ? (n).valueOf() : n;
                    h = (p !== undefined && p !== null) ? (p).valueOf() : p;
                    if (((l === undefined || l === null) && l !== h) || l != h) {
                        i = j[k] = j.hasOwnProperty(k) && j[k] || {};
                        i[q] = n;
                        r.push(q)
                    }
                }
            }
        } else {
            r = m.callParent(arguments)
        }
        return r
    };
    return {
        initProjectable: c,
        getUnprojected: a,
        isProjected: d
    }
});
Ext.define("Gnt.data.mixin.ProjectableStore",
function() {
    function b(h, i) {
        return h.byInternalIdMap && h.byInternalIdMap[i] || h.getByInternalId(i)
    }
    function d() {
        var i = this,
        h = i.projectionStack;
        return h && h[h.length - 1]
    }
    function c() {
        var i = this,
        h = i.projectionStack;
        return h && h.length || 0
    }
    function g(k) {
        var l, h, j;
        k = [].concat(k);
        for (j = false, l = 0, h = k.length; ! j && l < h; l++) {
            j = k[l].isProjected()
        }
        return j
    }
    function a() {
        var j = this,
        i = j.projectionStack,
        k, h;
        if (!i) {
            j.projectionStack = [{}]
        } else {
            h = i[i.length - 1];
            k = {};
            Ext.Object.each(h,
            function(n, m) {
                var l = function() {};
                l.prototype = m;
                k[n] = new l()
            });
            i.push(k)
        }
    }
    function e() {
        var p = this,
        i = p.projectionStack,
        m, l, h, j, n, o, k;
        if (i.length === 1) {
            l = i[0];
            p.projectionStack = null;
            for (o in l) {
                if (l.hasOwnProperty(o)) {
                    k = b(p, o);
                    if (k) {
                        j = l[o];
                        n = false;
                        for (h in j) {
                            if (j.hasOwnProperty(h)) {
                                n = true;
                                break
                            }
                        }
                        n && k.set(j)
                    }
                }
            }
        } else {
            l = i.pop();
            m = i[i.length - 1];
            for (o in l) {
                if (l.hasOwnProperty(o)) {
                    if (!m.hasOwnProperty(o)) {
                        m[o] = l[o]
                    } else {
                        m[o] = Ext.apply(m[o], l[o])
                    }
                }
            }
        }
        this.fireEvent("projectioncommit", this, i && i[i.length - 1], l)
    }
    function f() {
        var j = this,
        i = j.projectionStack,
        h = i.pop();
        if (i.length === 0) {
            j.projectionStack = null
        }
        this.fireEvent("projectionreject", this, i && i[i.length - 1], h)
    }
    return {
        projectionStack: null,
        getProjection: d,
        areProjected: g,
        getProjectionLevel: c,
        startProjection: a,
        commitProjection: e,
        rejectProjection: f
    }
});
Ext.define("Gnt.model.Calendar", {
    extend: "Sch.model.Customizable",
    requires: ["Ext.data.NodeInterface"],
    idProperty: "Id",
    calendar: null,
    phantomIdField: "PhantomId",
    phantomParentIdField: "PhantomParentId",
    daysField: "Days",
    customizableFields: [{
        name: "Name"
    },
    {
        name: "DaysPerMonth"
    },
    {
        name: "DaysPerWeek"
    },
    {
        name: "HoursPerDay"
    },
    {
        name: "WeekendsAreWorkdays"
    },
    {
        name: "WeekendFirstDay"
    },
    {
        name: "WeekendSecondDay"
    },
    {
        name: "DefaultAvailability"
    },
    {
        name: "Days"
    },
    {
        name: "CalendarClass"
    },
    {
        name: "PhantomId",
        type: "string"
    },
    {
        name: "PhantomParentId",
        type: "string"
    }],
    constructor: function(b, e, c) {
        var a = b || c || {};
        var d = a.calendar || a.Days;
        b && delete b.calendar;
        c && delete c.calendar;
        this.callParent(arguments);
        this.setDays(d);
        this.data[this.phantomIdField] = this.getId()
    },
    get: function(a) {
        if (a === "Days") {
            return this.getCalendar() || this.data[this.daysField]
        } else {
            return this.callParent(arguments)
        }
    },
    set: function(b, a) {
        if (b === "Days") {
            if (a instanceof Gnt.data.Calendar) {
                this.setCalendar(a)
            } else {
                this.data[this.daysField] = a
            }
        } else {
            return this.callParent(arguments)
        }
    },
    getCalendar: function() {
        return this.calendar
    },
    setCalendar: function(a) {
        this.calendar = a
    },
    getCalendarConfig: function() {
        return {
            calendarId: this.getId() || this.internalId,
            daysPerMonth: this.getDaysPerMonth(),
            daysPerWeek: this.getDaysPerWeek(),
            defaultAvailability: this.getDefaultAvailability(),
            hoursPerDay: this.getHoursPerDay(),
            name: this.getName(),
            parent: this.parentNode && this.parentNode.getCalendar(),
            weekendFirstDay: this.getWeekendFirstDay(),
            weekendSecondDay: this.getWeekendSecondDay(),
            weekendsAreWorkdays: this.getWeekendsAreWorkdays()
        }
    },
    getModelConfig: function(a) {
        return {
            DaysPerMonth: a.daysPerMonth,
            DaysPerWeek: a.daysPerWeek,
            DefaultAvailability: a.defaultAvailability,
            HoursPerDay: a.hoursPerDay,
            Name: a.name,
            parentId: a.parent && a.parent.calendarId,
            WeekendFirstDay: a.weekendFirstDay,
            WeekendSecondDay: a.weekendSecondDay,
            WeekendsAreWorkdays: a.weekendsAreWorkdays,
            ClassName: Ext.getClassName(a),
            Days: a
        }
    },
    setCalendarManager: function(a) {
        this.calendarManager = a
    },
    getCalendarManager: function() {
        return this.calendarManager
    },
    getInternalId: function() {
        return this.getId() || this.internalId
    }
},
function() {
    Ext.data.NodeInterface.decorate(this);
    this.override({
        insertBefore: function(a) {
            if (a instanceof Gnt.data.Calendar) {
                a = this.getModelConfig(a)
            }
            if (this.phantom) { (a.data || a)[this.phantomParentIdField] = this.getInternalId()
            }
            return this.callParent(arguments)
        },
        appendChild: function(c) {
            if (c instanceof Gnt.data.Calendar) {
                c = this.getModelConfig(c)
            }
            if (this.phantom) {
                var a = c instanceof Array ? c: [c];
                for (var b = 0; b < a.length; b++) {
                    var d = a[b].data || a[b];
                    d[this.phantomParentIdField] = this.getInternalId()
                }
            }
            return this.callParent(arguments)
        }
    })
});
Ext.define("Gnt.model.CalendarDay", {
    requires: ["Ext.data.Types"],
    extend: "Sch.model.Customizable",
    idProperty: "Id",
    customizableFields: [{
        name: "Date",
        type: "date",
        dateFormat: "c",
        persist: true,
        convert: function(b, a) {
            if (!b) {
                return
            }
            var c = Ext.data.Types.DATE.convert.call(this, b);
            if (c) {
                Ext.Date.clearTime(c)
            }
            return c
        }
    },
    {
        name: "Weekday",
        type: "int"
    },
    {
        name: "OverrideStartDate",
        type: "date",
        dateFormat: "c"
    },
    {
        name: "OverrideEndDate",
        type: "date",
        dateFormat: "c"
    },
    {
        name: "Type",
        defaultValue: "DAY"
    },
    {
        name: "IsWorkingDay",
        type: "boolean",
        defaultValue: false
    },
    {
        name: "Cls",
        defaultValue: "gnt-holiday"
    },
    "Name", {
        name: "Availability",
        persist: true,
        convert: function(b, a) {
            if (b) {
                return Ext.typeOf(b) === "string" ? [b] : b
            } else {
                return []
            }
        }
    }],
    availabilityCache: null,
    weekDayField: "Weekday",
    overrideStartDateField: "OverrideStartDate",
    overrideEndDateField: "OverrideEndDate",
    typeField: "Type",
    dateField: "Date",
    isWorkingDayField: "IsWorkingDay",
    clsField: "Cls",
    nameField: "Name",
    availabilityField: "Availability",
    setDate: function(a) {
        if (a) {
            a = Ext.Date.clearTime(a, true)
        }
        this.set(this.dateField, a)
    },
    clearDate: function() {
        this.set(this.dateField, null)
    },
    getAvailability: function(b) {
        var c = this;
        if (b) {
            return this.get(this.availabilityField)
        }
        if (this.availabilityCache) {
            return this.availabilityCache
        }
        var a = [];
        Ext.Array.each(this.get(this.availabilityField),
        function(d) {
            a.push(Ext.typeOf(d) === "string" ? c.parseInterval(d) : d)
        });
        this.verifyAvailability(a);
        return this.availabilityCache = a
    },
    setAvailability: function(a) {
        this.availabilityCache = null;
        this.set(this.availabilityField, this.stringifyIntervals(a));
        this.getAvailability()
    },
    verifyAvailability: function(b) {
        b.sort(function(f, e) {
            return f.startTime - e.startTime
        });
        Ext.Array.each(b,
        function(e) {
            if (e.startTime > e.endTime) {
                throw new Error("Start time " + Ext.Date.format(e.startTime, "H:i") + " is greater than end time " + Ext.Date.format(e.endTime, "H:i"))
            }
        });
        for (var a = 1; a < b.length; a++) {
            var c = b[a - 1];
            var d = b[a];
            if (c.endTime > d.startTime) {
                throw new Error("Availability intervals should not intersect: [" + this.stringifyInterval(c) + "] and [" + this.stringifyInterval(d) + "]")
            }
        }
    },
    prependZero: function(a) {
        return a < 10 ? "0" + a: a
    },
    stringifyInterval: function(b) {
        var c = b.startTime;
        var a = b.endTime;
        return this.prependZero(c.getHours()) + ":" + this.prependZero(c.getMinutes()) + "-" + (a.getDate() == 1 ? 24 : this.prependZero(a.getHours())) + ":" + this.prependZero(a.getMinutes())
    },
    stringifyIntervals: function(b) {
        var c = this;
        var a = [];
        Ext.Array.each(b,
        function(d) {
            if (Ext.typeOf(d) === "string") {
                a.push(d)
            } else {
                a.push(c.stringifyInterval(d))
            }
        });
        return a
    },
    parseInterval: function(b) {
        var a = /(\d\d):(\d\d)-(\d\d):(\d\d)/.exec(b);
        if (!a) {
            throw "Invalid format for availability string: " + b + ". It should have exact format: hh:mm-hh:mm"
        }
        return {
            startTime: new Date(0, 0, 0, a[1], a[2]),
            endTime: new Date(0, 0, 0, a[3], a[4])
        }
    },
    getTotalHours: function() {
        return this.getTotalMS() / 1000 / 60 / 60
    },
    getTotalMS: function() {
        var a = 0;
        Ext.Array.each(this.getAvailability(),
        function(b) {
            a += b.endTime - b.startTime
        });
        return a
    },
    addAvailabilityInterval: function(d, b) {
        var a;
        if (d instanceof Date) {
            a = {
                startTime: d,
                endTime: b
            }
        } else {
            a = this.parseInterval(d + (b ? "-" + b: ""))
        }
        var c = this.getAvailability().concat(a);
        this.verifyAvailability(c);
        this.setAvailability(c)
    },
    removeAvailbilityInterval: function(a) {
        var b = this.getAvailability();
        b.splice(a, 1);
        this.setAvailability(b)
    },
    getAvailabilityIntervalsFor: function(d) {
        d = typeof d == "number" ? new Date(d) : d;
        var c = d.getFullYear();
        var e = d.getMonth();
        var b = d.getDate();
        var a = [];
        Ext.Array.each(this.getAvailability(),
        function(f) {
            var g = f.endTime.getDate();
            a.push({
                startDate: new Date(c, e, b, f.startTime.getHours(), f.startTime.getMinutes()),
                endDate: new Date(c, e, b + (g == 1 ? 1 : 0), f.endTime.getHours(), f.endTime.getMinutes())
            })
        });
        return a
    },
    getAvailabilityStartFor: function(b) {
        var a = this.getAvailabilityIntervalsFor(b);
        if (!a.length) {
            return null
        }
        return a[0].startDate
    },
    getAvailabilityEndFor: function(b) {
        var a = this.getAvailabilityIntervalsFor(b);
        if (!a.length) {
            return null
        }
        return a[a.length - 1].endDate
    }
});
Ext.define("Gnt.model.Week", {
    extend: "Ext.data.Model",
    idProperty: "Id",
    fields: [{
        name: "Id"
    },
    {
        name: "name",
        type: "string"
    },
    {
        name: "startDate",
        type: "date"
    },
    {
        name: "endDate",
        type: "date"
    },
    {
        name: "mainDay"
    },
    {
        name: "weekAvailability"
    }],
    set: function(b, a) {
        if (b == "name") {
            Ext.Array.each(this.get("weekAvailability").concat(this.get("mainDay")),
            function(c) {
                if (c) {
                    c.setName(a)
                }
            })
        }
        this.callParent(arguments)
    }
});
Ext.define("Gnt.model.Assignment", {
    extend: "Sch.model.Customizable",
    idProperty: "Id",
    customizableFields: [{
        name: "ResourceId"
    },
    {
        name: "TaskId"
    },
    {
        name: "Units",
        type: "float",
        defaultValue: 100
    }],
    resourceIdField: "ResourceId",
    taskIdField: "TaskId",
    unitsField: "Units",
    isPersistable: function() {
        var a = this.getTask(),
        b = this.getResource();
        return a && !a.phantom && b && !b.phantom
    },
    getUnits: function() {
        return Math.max(0, this.get(this.unitsField))
    },
    setUnits: function(a) {
        if (a < 0) {
            throw "`Units` value for an assignment can't be less than 0"
        }
        this.set(this.unitsField, a)
    },
    getResourceName: function() {
        var a = this.getResource();
        if (a) {
            return a.getName()
        }
        return ""
    },
    getTask: function(a) {
        a = a || this.joined && this.joined[0].getTaskStore();
        return a && a.getByInternalModelId(this.getTaskId())
    },
    getResource: function() {
        return this.joined && this.joined[0] && this.joined[0].getResourceStore().getByInternalId(this.getResourceId())
    },
    getInternalId: function() {
        return this.getId() || this.internalId
    },
    getEffort: function(b) {
        var a = this.getTask();
        var c = 0;
        a.forEachAvailabilityIntervalWithResources({
            startDate: a.getStartDate(),
            endDate: a.getEndDate(),
            resources: [this.getResource()]
        },
        function(g, f, e) {
            var h;
            for (var d in e) {
                h = e[d].units
            }
            c += (f - g) * h / 100
        });
        return a.getProjectCalendar().convertMSDurationToUnit(c, b || a.getEffortUnit())
    }
});
Ext.define("Gnt.model.AssignmentEditing", {
    extend: "Gnt.model.Assignment",
    fields: ["ResourceName"]
});
Ext.define("Gnt.model.Dependency", {
    extend: "Sch.model.Customizable",
    inheritableStatics: {
        Type: {
            StartToStart: 0,
            StartToEnd: 1,
            EndToStart: 2,
            EndToEnd: 3
        }
    },
    idProperty: "Id",
    customizableFields: [{
        name: "From"
    },
    {
        name: "To"
    },
    {
        name: "Type",
        type: "int",
        defaultValue: 2
    },
    {
        name: "Lag",
        type: "number",
        defaultValue: 0
    },
    {
        name: "LagUnit",
        type: "string",
        defaultValue: "d",
        convert: function(a) {
            return a || "d"
        }
    },
    {
        name: "Cls",
        defaultValue: ""
    }],
    fromField: "From",
    toField: "To",
    typeField: "Type",
    lagField: "Lag",
    lagUnitField: "LagUnit",
    clsField: "Cls",
    isHighlighted: false,
    constructor: function(a) {
        this.callParent(arguments);
        if (a) {
            if (a[this.fromField] && a[this.fromField] instanceof Gnt.model.Task) {
                this.setSourceTask(a[this.fromField]);
                delete a.fromField
            }
            if (a[this.toField] && a[this.toField] instanceof Gnt.model.Task) {
                this.setTargetTask(a[this.toField]);
                delete a.toField
            }
        }
    },
    getTaskStore: function() {
        return this.joined[0].taskStore
    },
    getSourceTask: function(a) {
        return (a || this.getTaskStore()).getNodeById(this.getSourceId())
    },
    setSourceTask: function(a) {
        this.setSourceId(a.getId() || a.internalId)
    },
    getTargetTask: function(a) {
        return (a || this.getTaskStore()).getNodeById(this.getTargetId())
    },
    setTargetTask: function(a) {
        this.setTargetId(a.getId() || a.internalId)
    },
    getSourceId: function() {
        return this.get(this.fromField)
    },
    setSourceId: function(a) {
        this.set(this.fromField, a)
    },
    getTargetId: function() {
        return this.get(this.toField)
    },
    setTargetId: function(a) {
        this.set(this.toField, a)
    },
    getLagUnit: function() {
        return this.get(this.lagUnitField) || "d"
    },
    isPersistable: function() {
        var a = this.getSourceTask(),
        b = this.getTargetTask();
        return a && !a.phantom && b && !b.phantom
    },
    isValid: function(b) {
        var d = this.callParent(arguments),
        e = this.getSourceId(),
        a = this.getTargetId(),
        c = this.getType();
        if (d) {
            d = Ext.isNumber(c) && !Ext.isEmpty(e) && !Ext.isEmpty(a) && e != a
        }
        if (d && b !== false && this.joined && this.joined[0]) {
            d = this.joined[0].isValidDependency(e, a, c, null, null, this)
        }
        return d
    },
    getInternalId: function() {
        return this.getId() || this.internalId
    }
});
Ext.define("Gnt.model.Resource", {
    extend: "Sch.model.Resource",
    customizableFields: ["CalendarId"],
    calendarIdField: "CalendarId",
    normalized: false,
    calendarWaitingListener: null,
    constructor: function() {
        this.callParent(arguments);
        if (this.phantom) {
            this._phantomId = this.getInternalId()
        }
    },
    getTaskStore: function() {
        return this.joined[0].getTaskStore()
    },
    getEventStore: function() {
        return this.getTaskStore()
    },
    getEvents: function() {
        return this.getTasks()
    },
    getTasks: function() {
        var a = [];
        this.forEachAssignment(function(b) {
            var c = b.getTask();
            if (c) {
                a.push(c)
            }
        });
        return a
    },
    getCalendar: function(a) {
        return a ? this.getOwnCalendar() : this.getOwnCalendar() || this.getProjectCalendar()
    },
    getOwnCalendar: function() {
        var a = this.getCalendarId();
        return a ? Gnt.data.Calendar.getCalendar(a) : null
    },
    getProjectCalendar: function() {
        return this.joined[0].getTaskStore().getCalendar()
    },
    setCalendar: function(b) {
        var a = b instanceof Gnt.data.Calendar;
        if (a && !b.calendarId) {
            throw new Error("Can't set calendar w/o `calendarId` property")
        }
        this.setCalendarId(a ? b.calendarId: b)
    },
    setCalendarId: function(c, d) {
        if (c instanceof Gnt.data.Calendar) {
            c = c.calendarId
        }
        var b = this.getCalendarId();
        if (b != c || d) {
            if (this.calendarWaitingListener) {
                this.calendarWaitingListener.destroy();
                this.calendarWaitingListener = null
            }
            var a = {
                calendarchange: this.adjustToCalendar,
                scope: this
            };
            var f = this.calendar || Gnt.data.Calendar.getCalendar(b);
            this.calendar = null;
            f && f.un(a);
            this.set(this.calendarIdField, c);
            var e = Gnt.data.Calendar.getCalendar(c);
            if (e) {
                e.on(a);
                if (!d) {
                    this.adjustToCalendar()
                }
            } else {
                this.calendarWaitingListener = Ext.data.StoreManager.on("add",
                function(g, i, h) {
                    e = Gnt.data.Calendar.getCalendar(c);
                    if (e) {
                        this.calendarWaitingListener.destroy();
                        this.calendarWaitingListener = null;
                        e.on(a);
                        this.adjustToCalendar()
                    }
                },
                this, {
                    destroyable: true
                })
            }
        }
    },
    adjustToCalendar: function() {
        this.getTaskStore() && this.forEachTask(function(a) {
            a.adjustToCalendar()
        })
    },
    getInternalId: function() {
        return this.getId() || this.internalId
    },
    assignTo: function(a, c, d) {
        var b = a instanceof Gnt.model.Task ? a: this.getTaskStore().getNodeById(a);
        return b.assign(this, c, d)
    },
    unAssignFrom: function(a, c) {
        var b = a instanceof Gnt.model.Task ? a: this.getTaskStore().getNodeById(a);
        return b.unAssign(this, c)
    },
    unassignFrom: function() {
        return this.unAssignFrom.apply(this, arguments)
    },
    forEachAssignment: function(b, a) {
        a = a || this;
        var c = this.getInternalId();
        this.getTaskStore().getAssignmentStore().each(function(d) {
            if (d.getResourceId() == c) {
                return b.call(a, d)
            }
        })
    },
    forEachTask: function(b, a) {
        a = a || this;
        var c = this.getInternalId();
        this.getTaskStore().getAssignmentStore().each(function(e) {
            if (e.getResourceId() == c) {
                var d = e.getTask();
                if (d) {
                    return b.call(a, d)
                }
            }
        })
    },
    collectAvailabilityIntervalPoints: function(h, i, b, m, e) {
        var d = Ext.isFunction(i) ?
        function(k) {
            m[k].push(i(k))
        }: function(k) {
            m[k].push(i)
        };
        var g = Ext.isFunction(b) ?
        function(k) {
            m[k].push(b(k))
        }: function(k) {
            m[k].push(b)
        };
        for (var f = 0,
        c = h.length; f < c; f++) {
            var a = h[f];
            var j = a.startDate - 0;
            var n = a.endDate - 0;
            if (!m[j]) {
                m[j] = [];
                e.push(j)
            }
            d(j);
            if (!m[n]) {
                m[n] = [];
                e.push(n)
            }
            g(n)
        }
    },
    forEachAvailabilityIntervalWithTasks: function(f, h, b) {
        b = b || this;
        var e = f.startDate;
        var B = f.endDate;
        if (!e || !B) {
            throw "Both `startDate` and `endDate` are required for `forEachAvailabilityIntervalWithTasks`"
        }
        var m = new Date(e);
        var D = f.includeAllIntervals;
        var C = f.includeResCalIntervals;
        var t = this.getCalendar();
        var q = [];
        var r = [];
        var c = [];
        var H = [e - 0, B - 0];
        var o = {};
        o[e - 0] = [{
            type: "00-intervalStart"
        }];
        o[B - 0] = [{
            type: "00-intervalEnd"
        }];
        this.forEachAssignment(function(I) {
            var j = I.getTask();
            if (!j) {
                return
            }
            var i = j.getStartDate();
            var l = j.getEndDate();
            var k = j.getInternalId();
            if (i > B || l < e) {
                return
            }
            r.push(j);
            c.push(j.getOwnCalendar() || this.getCalendar());
            this.collectAvailabilityIntervalPoints([{
                startDate: i,
                endDate: l
            }], {
                type: "05-taskStart",
                assignment: I,
                taskId: k,
                units: I.getUnits()
            },
            {
                type: "04-taskEnd",
                taskId: k
            },
            o, H);
            q.push(I)
        });
        if (!r.length && !D && !C) {
            return
        }
        var g = Sch.util.Date;
        var A, u, d;
        while (m < B) {
            this.collectAvailabilityIntervalPoints(t.getAvailabilityIntervalsFor(m), {
                type: "00-resourceAvailabilityStart"
            },
            {
                type: "01-resourceAvailabilityEnd"
            },
            o, H);
            for (A = 0, u = c.length; A < u; A++) {
                d = r[A].getInternalId();
                this.collectAvailabilityIntervalPoints(c[A].getAvailabilityIntervalsFor(m), {
                    type: "02-taskAvailabilityStart",
                    taskId: d
                },
                {
                    type: "03-taskAvailabilityEnd",
                    taskId: d
                },
                o, H)
            }
            m = g.getStartOfNextDay(m)
        }
        H.sort(function(j, i) {
            return j - i
        });
        var x = false,
        F = false,
        E = {},
        a = 0,
        z = 0;
        for (A = 0, u = H.length - 1; A < u; A++) {
            var y = o[H[A]];
            y.sort(function(j, i) {
                return j.type < i.type ? 1 : -1
            });
            for (var v = 0,
            w = y.length; v < w; v++) {
                var s = y[v];
                switch (s.type) {
                case "00-resourceAvailabilityStart":
                    F = true;
                    break;
                case "01-resourceAvailabilityEnd":
                    F = false;
                    break;
                case "02-taskAvailabilityStart":
                    a++;
                    break;
                case "03-taskAvailabilityEnd":
                    a--;
                    break;
                case "05-taskStart":
                    E[s.taskId] = s;
                    z++;
                    break;
                case "04-taskEnd":
                    delete E[s.taskId];
                    z--;
                    break;
                case "00-intervalStart":
                    x = true;
                    break;
                case "00-intervalEnd":
                    return
                }
            }
            if (x && (D || C && F || F && a && z)) {
                var p = {
                    inResourceCalendar: !!F,
                    inTasksCalendar: !!a,
                    inTask: z
                };
                var G = H[A];
                var n = H[A + 1];
                if (G > B || n < e) {
                    continue
                }
                if (G < e) {
                    G = e - 0
                }
                if (n > B) {
                    n = B - 0
                }
                if (h.call(b, G, n, E, p) === false) {
                    return false
                }
            }
        }
    },
    getAllocationInfo: function(a) {
        var b = [];
        this.forEachAvailabilityIntervalWithTasks(a,
        function(j, h, g, k) {
            var f = 0,
            d = [],
            c = {};
            if (k.inResourceCalendar && k.inTasksCalendar && k.inTask) {
                for (var e in g) {
                    f += g[e].units;
                    d.push(g[e].assignment);
                    c[e] = g[e].assignment
                }
            }
            b.push(Ext.apply({
                startDate: new Date(j),
                endDate: new Date(h),
                totalAllocation: f,
                assignments: d,
                assignmentsHash: c
            },
            k))
        });
        return b
    }
});
Ext.define("Gnt.model.task.More", {
    propagating: false,
    indent: function(d) {
        var c = this,
        b = c.previousSibling,
        a;
        if (b) {
            c.propagateChanges(function() {
                return c.indentWithoutPropagation(function(e) {
                    a = e
                })
            },
            function(f, e) {
                if (f) {
                    a && a()
                } else {
                    b.expand()
                }
                d && d(f, e)
            })
        } else {
            d && d(false, {})
        }
    },
    indentWithoutPropagation: function(b) {
        var h = this,
        a = h.previousSibling,
        i, d, g, c, f, e;
        e = {
            parentNode: h.parentNode,
            previousSibling: h.previousSibling,
            nextSibling: h.nextSibling
        };
        i = h.getTaskStore();
        d = h.parentNode;
        g = d.indexOf(h);
        i.suspendEvents(true);
        c = a.get("leaf");
        if (c) {
            f = a.getSegments();
            a.markAsParent()
        }
        a.appendChild(h);
        h.removeContext = e;
        a.removeInvalidDependencies();
        b && b(function() {
            d.insertChild(g, h);
            c && a.set("leaf", true);
            c && f && a.setSegmentsWithoutPropagation(f)
        });
        i.resumeEvents();
        return h
    },
    outdent: function(d) {
        var c = this,
        a = c.parentNode,
        b;
        if (a && !a.isRoot()) {
            c.propagateChanges(function() {
                return c.outdentWithoutPropagation(function(e) {
                    b = e
                })
            },
            function(f, e) {
                f && b && b();
                d && d(f, e)
            })
        } else {
            d && d(false, {})
        }
    },
    outdentWithoutPropagation: function(d) {
        var e = this,
        b, f, c, a;
        a = {
            parentNode: e.parentNode,
            previousSibling: e.previousSibling,
            nextSibling: e.nextSibling
        };
        c = e.getTaskStore();
        b = e.parentNode;
        f = b.indexOf(e);
        c.suspendEvents(true);
        if (b.nextSibling) {
            b.parentNode.insertBefore(e, b.nextSibling)
        } else {
            b.parentNode.appendChild(e)
        }
        e.convertEmptyParentToLeaf && b.set("leaf", b.childNodes.length === 0);
        e.removeContext = a;
        b.parentNode.removeInvalidDependencies();
        c.resumeEvents();
        d && d(function() {
            b.insertChild(f, e)
        });
        return b
    },
    removeInvalidDependencies: function() {
        var a = this.getDependencyStore(),
        c = this.getAllDependencies();
        for (var b = 0; b < c.length; b++) {
            if (!c[b].isValid(true)) {
                a.remove(c[b])
            }
        }
    },
    getAllDependencies: function() {
        return this.predecessors.concat(this.successors)
    },
    hasIncomingDependencies: function() {
        return this.predecessors.length > 0
    },
    hasOutgoingDependencies: function() {
        return this.successors.length > 0
    },
    getIncomingDependencies: function(a) {
        return a ? this.predecessors: this.predecessors.slice()
    },
    getOutgoingDependencies: function(a) {
        return a ? this.successors: this.successors.slice()
    },
    constrain: function(c, b, d) {
        var a = this.constrainWithoutPropagation(c, b);
        this.propagateChanges(null, d, true);
        return a
    },
    constrainWithoutPropagation: function(e, d, c) {
        if (this.isManuallyScheduled()) {
            return false
        }
        var g = false;
        e = e || this.getTaskStore();
        var b = this.getConstrainContext(e, c);
        if (b) {
            var a = b.startDate;
            var f = b.endDate;
            if (a && f) {
                var h = this.calculateStartDate(f, this.getDuration(), this.getDurationUnit());
                if (h > a) {
                    a = h
                }
                f = null
            }
            if (a && a - this.getStartDate() !== 0) {
                d && d.addAffected(this);
                this.setStartDateWithoutPropagation(a, true, e.skipWeekendsDuringDragDrop);
                g = true
            } else {
                if (f && f - this.getEndDate() !== 0) {
                    d && d.addAffected(this);
                    this.setEndDateWithoutPropagation(f, true, e.skipWeekendsDuringDragDrop);
                    g = true
                }
            }
        }
        return g
    },
    getConstrainContext: function(f, h) {
        var g = this.getIncomingDependencies(true);
        if (!g.length || this.isUnscheduled()) {
            return null
        }
        var a = Gnt.model.Dependency.Type,
        c = new Date(0),
        b = new Date(0),
        j = this.getProjectCalendar(),
        i = this.getCalendar(),
        d;
        var e = (f || this.getTaskStore()).dependenciesCalendar;
        Ext.each(g,
        function(m) {
            var l = m.getSourceTask(f);
            if (l && (!h || l.isAncestor(h))) {
                var o;
                if (e == "project") {
                    o = j
                } else {
                    if (e == "source") {
                        o = l.getCalendar()
                    } else {
                        if (e == "target") {
                            o = i
                        } else {
                            throw "Unsupported value for `dependenciesCalendar` config option"
                        }
                    }
                }
                var q = m.getLag() || 0,
                n = m.getLagUnit(),
                p = l.getStartDate(),
                k = l.getEndDate();
                switch (m.getType()) {
                case a.StartToEnd:
                    p = o.skipWorkingTime(p, q, n);
                    if (b < p) {
                        b = p;
                        d = l
                    }
                    break;
                case a.StartToStart:
                    p = o.skipWorkingTime(p, q, n);
                    if (c < p) {
                        c = p;
                        d = l
                    }
                    break;
                case a.EndToStart:
                    k = o.skipWorkingTime(k, q, n);
                    if (c < k) {
                        c = k;
                        d = l
                    }
                    break;
                case a.EndToEnd:
                    k = o.skipWorkingTime(k, q, n);
                    if (b < k) {
                        b = k;
                        d = l
                    }
                    break;
                default:
                    throw "Invalid dependency type: " + m.getType()
                }
            }
        });
        return {
            startDate: c > 0 ? c: null,
            endDate: b > 0 ? b: null,
            constrainingTask: d
        }
    },
    getCriticalPaths: function() {
        var b = [this],
        a = this.getConstrainContext();
        while (a) {
            b.push(a.constrainingTask);
            a = a.constrainingTask.getConstrainContext()
        }
        return b
    },
    cascadeChanges: function(a, b, c) {},
    addSubtask: function(d, f) {
        var c = this,
        a, b;
        c.propagateChanges(function() {
            return c.addSubtaskWithoutPropagation(d,
            function g(i, h) {
                b = i;
                a = h
            })
        },
        function e(h, g) {
            h && b && b();
            f && f(h, g)
        });
        return a
    },
    addSubtaskWithoutPropagation: function(h, g) {
        var d = this,
        a, e, f, c, b;
        a = h.parentNode;
        e = a && a.indexOf(d);
        c = d.get("leaf");
        if (c) {
            d.markAsParent();
            b = d.getSegments()
        }
        h = d.appendChild(h);
        d.expand();
        g && g(function() {
            if (a) {
                a.insertChild(e, h)
            } else {
                d.removeChild(h)
            }
            c && d.set("leaf", true);
            c && b && d.setSegmentsWithoutPropagation(b)
        },
        h);
        if (!a) {
            f = h
        } else {
            if (d !== a && d.getTaskStore(true) === a.getTaskStore(true)) {
                f = [h, a]
            }
        }
        return f
    },
    insertSubtask: function(b, e, g) {
        var d = this,
        a, c;
        d.propagateChanges(function() {
            return d.insertSubtaskWithoutPropagation(b, e,
            function h(j, i) {
                c = j;
                a = i
            })
        },
        function f(i, h) {
            i && c && c();
            g && g(i, h)
        });
        return a
    },
    insertSubtaskWithoutPropagation: function(g, a, h) {
        var i = this,
        d, f, c, b, e;
        d = a.parentNode;
        f = d && d.indexOf(i);
        b = i.get("leaf");
        if (b) {
            i.markAsParent();
            e = i.getSegments()
        }
        a = i.insertChild(g, a);
        i.expand();
        h && h(function() {
            if (d) {
                d.insertChild(f, a)
            } else {
                i.removeChild(a)
            }
            b && i.set("leaf", true);
            b && e && i.setSegmentsWithoutPropagation(e)
        },
        a);
        if (!d) {
            c = a
        } else {
            if (i !== d && i.getTaskStore(true) === d.getTaskStore(true)) {
                c = [a, d]
            }
        }
        return c
    },
    removeSubtask: function(c, e) {
        var b = this,
        a;
        b.propagateChanges(function() {
            return b.removeSubtaskWithoutPropagation(c,
            function f(g) {
                a = g
            })
        },
        function d(g, f) {
            g && a && a();
            e && e(g, f)
        })
    },
    removeSubtaskWithoutPropagation: function(c, d) {
        var n = this,
        e = n.indexOf(c),
        p,
        o,
        f,
        j,
        m,
        b,
        l,
        g,
        h,
        k,
        a;
        o = n.getTaskStore();
        f = n.getDependencyStore();
        j = n.getAssignmentStore();
        m = f && f.getDependenciesForTask(c);
        b = j && c.getAssignments();
        p = [];
        l = [];
        g = [];
        c.cascadeBy(function(i) {
            i !== c && p.push(i)
        });
        for (h = 0, k = p.length; (f || j) && h < k; h++) {
            a = p[h];
            f && (m = m.concat(f.getDependenciesForTask(a)));
            j && (b = b.concat(a.getAssignments()))
        }
        m = f && Ext.Array.unique(m);
        m = f && Ext.Array.sort(m,
        function(q, i) {
            return f.indexOf(q) < f.indexOf(i) ? -1 : 1
        });
        for (h = 0, k = m && m.length; f && h < k; h++) {
            l.push(f.indexOf(m[h]))
        }
        b = j && Ext.Array.sort(b,
        function(q, i) {
            return j.indexOf(q) < j.indexOf(i) ? -1 : 1
        });
        for (h = 0, k = b && b.length; j && h < k; h++) {
            g.push(j.indexOf(b[h]))
        }
        j && j.remove(b);
        f && f.remove(m);
        c = n.removeChild(c);
        if (n.childNodes.length === 0 && n.convertEmptyParentToLeaf) {
            n.set("leaf", true)
        }
        d && d(function() {
            n.insertChild(e, c);
            for (h = 0, k = b && b.length; j && h < k; h++) {
                j.insert(g[h], b[h])
            }
            for (h = 0, k = m && m.length; f && h < k; h++) {
                f.insert(l[h], m[h])
            }
        });
        return n
    },
    addSuccessor: function(b, f) {
        var d = this,
        a, c;
        d.propagateChanges(function() {
            return d.addSuccessorWithoutPropagation(b,
            function g(i, h) {
                c = i;
                a = h
            })
        },
        function e(h, g) {
            h && c && c();
            f && f(h, g)
        });
        return a
    },
    addSuccessorWithoutPropagation: function(d, h) {
        var i = this,
        e = i.parentNode,
        g = e.indexOf(i),
        a = i.getDependencyStore(),
        j = i.getTaskStore(true),
        f,
        c,
        b;
        d = d || new i.self();
        d.calendar = d.calendar || i.getCalendar();
        d.taskStore = d.taskStore || i.getTaskStore(true);
        if (i.getEndDate()) {
            d.beginEdit();
            d.set(i.startDateField, i.getEndDate());
            d.set(i.endDateField, d.calculateEndDate(i.getEndDate(), 1, Sch.util.Date.DAY));
            d.set(i.durationField, 1);
            d.set(i.durationUnitField, Sch.util.Date.DAY);
            d.endEdit()
        }
        e.insertSubtaskWithoutPropagation(g + 1, d,
        function(l, k) {
            f = l;
            d = k
        });
        i.linkToWithoutPropagation(d, Gnt.model.Dependency.Type.EndToStart,
        function(k) {
            c = k
        });
        h && h(function() {
            c();
            f()
        },
        d);
        return i
    },
    addMilestone: function(d, e) {
        var c = this,
        b = c.getTaskStore(),
        a = c.getEndDate();
        if (!d) {
            d = new c.self()
        } else {
            if (Ext.isObject(d) && !(d instanceof Gnt.model.Task)) {
                d = new c.self(d)
            }
        }
        if (a && !d.isMilestone()) {
            d.calendar = d.calendar || c.getCalendar();
            d.setStartEndDate(a, a)
        }
        return c.addTaskBelow(d, e)
    },
    addPredecessor: function(c, f) {
        var d = this,
        a, b;
        d.propagateChanges(function() {
            return d.addPredecessorWithoutPropagation(c,
            function g(i, h) {
                b = i;
                a = h
            })
        },
        function e(h, g) {
            h && b();
            f && f(h, g)
        });
        return a
    },
    addPredecessorWithoutPropagation: function(b, h) {
        var i = this,
        e = i.parentNode,
        g = e.indexOf(i),
        a = i.getDependencyStore(),
        j = i.getTaskStore(true),
        f,
        d,
        c;
        b = b || new i.self();
        b.calendar = b.calendar || i.getCalendar();
        b.taskStore = b.taskStore || i.getTaskStore(true);
        if (i.getStartDate()) {
            b.beginEdit();
            b.set(i.startDateField, b.calculateStartDate(i.getStartDate(), 1, Sch.util.Date.DAY));
            b.set(i.endDateField, i.getStartDate());
            b.set(i.durationField, 1);
            b.set(i.durationUnitField, Sch.util.Date.DAY);
            b.endEdit()
        }
        e.insertSubtaskWithoutPropagation(g, b,
        function(l, k) {
            f = l;
            b = k
        });
        b.linkToWithoutPropagation(i, Gnt.model.Dependency.Type.EndToStart,
        function(k) {
            d = k
        });
        h && h(function() {
            d();
            f()
        },
        b);
        return b
    },
    getSuccessors: function() {
        var e = this.successors,
        d = [];
        for (var c = 0,
        a = e.length; c < a; c++) {
            var b = e[c].getTargetTask();
            if (b) {
                d.push(b)
            }
        }
        return d
    },
    getPredecessors: function() {
        var e = this.predecessors,
        d = [];
        for (var c = 0,
        a = e.length; c < a; c++) {
            var b = e[c].getSourceTask();
            if (b) {
                d.push(b)
            }
        }
        return d
    },
    addTaskAbove: function(c, h) {
        var f = this,
        a = f.parentNode,
        d = a.indexOf(f),
        b,
        e;
        c = c || new f.self();
        f.propagateChanges(function() {
            return a.insertSubtaskWithoutPropagation(d, c,
            function i(k, j) {
                e = k;
                b = j
            })
        },
        function g(j, i) {
            j && e();
            h && h(j, i)
        });
        return b
    },
    addTaskBelow: function(c, h) {
        var f = this,
        a = f.parentNode,
        d = a.indexOf(f) + 1,
        b,
        e;
        c = c || new f.self();
        f.propagateChanges(function() {
            return a.insertSubtaskWithoutPropagation(d, c,
            function i(k, j) {
                e = k;
                b = j
            })
        },
        function g(j, i) {
            j && e();
            h && h(j, i)
        });
        return b
    },
    isAbove: function(a) {
        var b = this,
        d = Math.min(b.data.depth, a.data.depth);
        var c = this;
        while (c.data.depth > d) {
            c = c.parentNode;
            if (c == a) {
                return false
            }
        }
        while (a.data.depth > d) {
            a = a.parentNode;
            if (a == b) {
                return true
            }
        }
        while (a.parentNode !== c.parentNode) {
            a = a.parentNode;
            c = c.parentNode
        }
        return a.data.index > c.data.index
    },
    cascadeChildren: function(d, c) {
        var e = this;
        if (e.isLeaf()) {
            return
        }
        var f = this.childNodes;
        for (var b = 0,
        a = f.length; b < a; b++) {
            f[b].cascadeBy(d, c)
        }
    },
    getViolatedConstraints: function() {
        if (!this.get("leaf") || this.isManuallyScheduled()) {
            return false
        }
        var a = this.getEarlyStartDate();
        if (this.getStartDate() < a) {
            return [{
                task: this,
                startDate: a
            }]
        }
        return null
    },
    resolveViolatedConstraints: function(e) {
        e = e || this.getViolatedConstraints();
        if (!e) {
            return
        }
        if (!Ext.isArray(e)) {
            e = [e]
        }
        var b = this.getTaskStore();
        for (var c, d = 0,
        a = e.length; d < a; d++) {
            c = e[d];
            if (c.startDate) {
                c.task.setStartDate(c.startDate, true, b.skipWeekendsDuringDragDrop)
            } else {
                if (c.endDate) {
                    c.task.setEndDate(c.endDate, true, b.skipWeekendsDuringDragDrop)
                }
            }
        }
    },
    getSlack: function(b) {
        b = b || Sch.util.Date.DAY;
        var c = this.getEarlyStartDate(),
        a = this.getLateStartDate();
        if (!c || !a) {
            return null
        }
        return this.getCalendar().calculateDuration(c, a, b)
    },
    getEarlyStartDate: function() {
        var k = this.getTaskStore();
        if (!k) {
            return this.getStartDate()
        }
        var h = this.internalId;
        if (k.earlyStartDates[h]) {
            return k.earlyStartDates[h]
        }
        var b, n = 0,
        f, e;
        if (this.childNodes.length) {
            for (f = 0, e = this.childNodes.length; f < e; f++) {
                b = this.childNodes[f].getEarlyStartDate();
                if (b < n || !n) {
                    n = b
                }
            }
            k.earlyStartDates[h] = n;
            return n
        }
        if (this.isManuallyScheduled()) {
            n = k.earlyStartDates[h] = this.getStartDate();
            return n
        }
        var m = this.getIncomingDependencies(true),
        j;
        if (!m.length) {
            n = k.earlyStartDates[h] = this.getStartDate();
            return n
        }
        var g = Gnt.model.Dependency.Type,
        a = this.getCalendar(),
        d = this.getProjectCalendar(),
        c;
        for (f = 0, e = m.length; f < e; f++) {
            j = m[f].getSourceTask();
            if (j) {
                switch (m[f].getType()) {
                case g.StartToStart:
                    b = j.getEarlyStartDate();
                    break;
                case g.StartToEnd:
                    b = j.getEarlyStartDate();
                    b = a.calculateStartDate(b, this.getDuration(), this.getDurationUnit());
                    break;
                case g.EndToStart:
                    b = j.getEarlyEndDate();
                    break;
                case g.EndToEnd:
                    b = j.getEarlyEndDate();
                    b = a.calculateStartDate(b, this.getDuration(), this.getDurationUnit());
                    break
                }
                c = m[f].getLag();
                if (c) {
                    b = d.skipWorkingTime(b, c, m[f].getLagUnit())
                }
                b = d.skipNonWorkingTime(b, true)
            }
            if (b > n) {
                n = b
            }
        }
        k.earlyStartDates[h] = n;
        return n
    },
    getEarlyEndDate: function() {
        var d = this.getTaskStore();
        if (!d) {
            return this.getEndDate()
        }
        var c = this.internalId;
        if (d.earlyEndDates[c]) {
            return d.earlyEndDates[c]
        }
        var a = 0;
        if (this.childNodes.length) {
            var f, e, b;
            for (e = 0, b = this.childNodes.length; e < b; e++) {
                f = this.childNodes[e].getEarlyEndDate();
                if (f > a) {
                    a = f
                }
            }
            d.earlyEndDates[c] = a;
            return a
        }
        if (this.isManuallyScheduled()) {
            a = d.earlyEndDates[c] = this.getEndDate();
            return a
        }
        var g = this.getEarlyStartDate();
        if (!g) {
            return null
        }
        a = d.earlyEndDates[c] = this.getCalendar().calculateEndDate(g, this.getDuration(), this.getDurationUnit());
        return a
    },
    getLateEndDate: function() {
        var k = this.getTaskStore();
        if (!k) {
            return this.getEndDate()
        }
        var j = this.internalId;
        if (k.lateEndDates[j]) {
            return k.lateEndDates[j]
        }
        var b, n = 0,
        g, e;
        if (this.childNodes.length) {
            for (g = 0, e = this.childNodes.length; g < e; g++) {
                b = this.childNodes[g].getLateEndDate();
                if (b > n) {
                    n = b
                }
            }
            k.lateEndDates[j] = n;
            return n
        }
        if (this.isManuallyScheduled()) {
            n = k.lateEndDates[j] = this.getEndDate();
            return n
        }
        var m = this.getOutgoingDependencies(true);
        if (!m.length) {
            n = k.lateEndDates[j] = k.getProjectEndDate();
            return n
        }
        var h = Gnt.model.Dependency.Type,
        a = this.getCalendar(),
        d = this.getProjectCalendar(),
        f,
        c;
        for (g = 0, e = m.length; g < e; g++) {
            f = m[g].getTargetTask();
            if (f) {
                switch (m[g].getType()) {
                case h.StartToStart:
                    b = f.getLateStartDate();
                    b = a.calculateEndDate(b, this.getDuration(), this.getDurationUnit());
                    break;
                case h.StartToEnd:
                    b = f.getLateEndDate();
                    b = a.calculateEndDate(b, this.getDuration(), this.getDurationUnit());
                    break;
                case h.EndToStart:
                    b = f.getLateStartDate();
                    break;
                case h.EndToEnd:
                    b = f.getLateEndDate();
                    break
                }
                c = m[g].getLag();
                if (c) {
                    b = d.skipWorkingTime(b, -c, m[g].getLagUnit())
                }
                b = d.skipNonWorkingTime(b, false);
                if (b < n || !n) {
                    n = b
                }
            }
        }
        k.lateEndDates[j] = n || k.getProjectEndDate();
        return k.lateEndDates[j]
    },
    getLateStartDate: function() {
        var d = this.getTaskStore();
        if (!d) {
            return this.getStartDate()
        }
        var c = this.internalId;
        if (d.lateStartDates[c]) {
            return d.lateStartDates[c]
        }
        var a;
        if (this.childNodes.length) {
            var f, e, b;
            for (e = 0, b = this.childNodes.length; e < b; e++) {
                f = this.childNodes[e].getLateStartDate();
                if (f < a || !a) {
                    a = f
                }
            }
            d.lateStartDates[c] = a;
            return a
        }
        if (this.isManuallyScheduled()) {
            a = d.lateStartDates[c] = this.getStartDate();
            return a
        }
        var g = this.getLateEndDate();
        if (!g) {
            return null
        }
        a = d.lateStartDates[c] = this.getCalendar().calculateStartDate(g, this.getDuration(), this.getDurationUnit());
        return a
    },
    resetEarlyDates: function() {
        var b = this.getTaskStore();
        if (!b) {
            return
        }
        var a = this.internalId;
        b.earlyStartDates[a] = null;
        b.earlyEndDates[a] = null
    },
    resetLateDates: function() {
        var b = this.getTaskStore();
        if (!b) {
            return
        }
        var a = this.internalId;
        b.lateStartDates[a] = null;
        b.lateEndDates[a] = null
    },
    getTopParent: function(c) {
        var b = this.getTaskStore().getRootNode(),
        e = this,
        d = [this],
        a;
        while (e) {
            if (e === b) {
                return c ? d: a
            }
            d.push(e);
            a = e;
            e = e.parentNode
        }
    },
    getInDepthWalker: function(a) {
        var e = a ? this: this.childNodes && this.childNodes[0];
        var b = this;
        var f = {};
        var d = null;
        var c = function(i) {
            var h = i;
            var g = h.internalId;
            if (h.isLeaf() || !h.childNodes.length) {
                h = h.nextSibling
            } else {
                if (f[g] === true) {
                    f[g] = false;
                    h = h.nextSibling
                } else {
                    f[g] = true;
                    h = h.childNodes[0]
                }
            }
            if (!h) {
                h = i;
                do {
                    if (h === b) {
                        return null
                    }
                    h = h.parentNode;
                    if (h === b) {
                        return null
                    }
                } while ( f [ h . internalId ] === false);
                return c(h)
            }
            return h
        };
        return function() {
            var g = e;
            if (e) {
                e = c(e)
            }
            return g
        }
    },
    propagateChanges: function(i, k, g) {
        var d = this,
        a, h, f, b;
        f = d.getTaskStore(true);
        g = arguments.length == 3 ? g: f && f.cascadeChanges;
        if (!d.propagating && f) {
            d.propagating = true;
            h = {};
            f.suspendAutoSync();
            b = f.startBatchCascade();
            f.startProjection();
            try {
                a = (i && i !== Ext.emptyFn) ? i(d) : [d]
            } catch(c) {
                f.rejectProjection();
                f.endBatchCascade();
                f.resumeAutoSync(f.autoSync);
                d.propagating = false;
                throw c
            }
            if (a === true) {
                a = d.isProjected() && [d] || false
            } else {
                if (a) {
                    a = [].concat(a)
                }
            }
            if (a) {
                d.propagateChangesThroughDependentTasks(f.getLinearWalkingSequenceForDependentTasks(a, {
                    self: true,
                    ancestors: f.recalculateParents,
                    descendants: f.moveParentAsGroup,
                    successors: g,
                    cycles: f.cycleResolutionStrategy
                }), f, b, a, g, h,
                function j(l, e) {
                    if (l) {
                        f.rejectProjection();
                        e = {}
                    } else {
                        f.commitProjection()
                    }
                    f.endBatchCascade();
                    d.propagating = false;
                    k && k(l, e);
                    f.resumeAutoSync(f.autoSync && !l && !Ext.Object.isEmpty(e))
                })
            } else {
                f.rejectProjection();
                f.endBatchCascade();
                d.propagating = false;
                k && k(false, {});
                f.resumeAutoSync(f.autoSync)
            }
        } else {
            if (!d.propagating) {
                d.propagating = true;
                try {
                    i && i(d)
                } catch(c) {
                    d.propagating = false;
                    throw c
                }
                d.verifyConstraint(function(e, l) {
                    h = {};
                    l = !!l;
                    if (!l) {
                        h[d.getInternalId()] = d
                    }
                    d.propagating = false;
                    k && k(l, h)
                })
            } else {
                k && k(true, {})
            }
        }
    },
    propagateChangesThroughDependentTasks: function(g, h, b, a, j, k, m, d) {
        var f = this,
        c, e, l;
        d = d || 0;
        l = true;
        for (c = d, e = g.length; l && c < e; ++c) {
            l = f.processTaskConstraints(g, c, h, b, a, j, k,
            function(n, o, p, i) {
                if (p || (n == e - 1)) {
                    m(p, i)
                } else {
                    if (!o) {
                        f.propagateChangesThroughDependentTasks(g, h, b, a, j, i, m, n + 1)
                    }
                }
            })
        }
    },
    processTaskConstraints: function(r, p, k, b, t, f, i, e) {
        var x = this,
        g = r[p],
        u = g[0],
        q = g[1],
        w = u.hasChildNodes(),
        v = !w,
        a = u.internalId,
        m = !(u.isManuallyScheduled() || Ext.Array.contains(t, u)),
        y = f || k.cascadeChanges,
        o = k.recalculateParents,
        d = k.moveParentAsGroup,
        j = u.parentNode,
        c = j && (j.getStartDate()),
        s = j && (j.getUnprojected(j.startDateField)),
        n = j && (c - s),
        h;
        function l(z, G, A) {
            var B = z.getIncomingDependencies(true),
            H = false,
            C,
            D,
            F,
            E;
            for (C = 0, D = B.length; ! H && C < D; ++C) {
                F = B[C];
                E = F.getSourceTask();
                H = E && G.hasOwnProperty(E.getInternalId()) || Ext.Array.contains(A, E)
            }
            return H
        }
        switch (true) {
        case m && v && q == "green" && n && d: case m && w && q == "yellow" && n && d: h = u.calculateDuration(s, u.getStartDate());
            u.setStartDateWithoutPropagation(u.calculateEndDate(c, h), true, k.skipWeekendsDuringDragDrop);
            l(u, i, t) && u.constrainWithoutPropagation(k, null, j);
            break;
        case m && v && q == "green" && y: case m && w && q == "yellow" && y: l(u, i, t) && u.constrainWithoutPropagation(k, null);
            break;
        case w && q == "green" && o: u.refreshCalculatedParentNodeData();
            break
        }
        if (u.isProjected()) {
            b.addAffected(u);
            i[u.getInternalId()] = u
        }
        return u.verifyConstraint(function(A, C) {
            var z, B;
            if (!A && w && m && k.recalculateParents && q == "green") {
                z = Ext.Array.findBy(r,
                function(F, D) {
                    var G = F[0],
                    E = F[1];
                    B = D;
                    return u === G && E == "yellow"
                });
                e(B, A, !!C, i)
            } else {
                e(p, A, !!C, i)
            }
        })
    }
});
Ext.define("Gnt.model.task.Constraints", {
    requires: ["Gnt.constraint.Base", "Gnt.constraint.StartNoEarlierThan", "Gnt.constraint.StartNoLaterThan", "Gnt.constraint.FinishNoEarlierThan", "Gnt.constraint.FinishNoLaterThan", "Gnt.constraint.MustStartOn", "Gnt.constraint.MustFinishOn"],
    setConstraint: function(c, b, g) {
        var e = this,
        a = e.getTaskStore(true),
        f;
        if (c) {
            f = Gnt.constraint.Base.getConstraintClass(c)
        }
        if (!b && f) {
            b = f.getInitialConstraintDate(e)
        }
        function d() {
            e.beginEdit();
            e.set(e.constraintTypeField, c || "");
            e.set(e.constraintDateField, b);
            e.endEdit();
            return true
        }
        if (c) {
            e.propagateChanges(d, g)
        } else {
            d();
            g && g(false, {})
        }
    },
    setConstraintType: function(a, b) {
        this.setConstraint(a, this.getConstraintDate(), b)
    },
    setConstraintDate: function(a, b) {
        this.setConstraint(this.getConstraintType(), a, b)
    },
    hasConstraint: function() {
        return !! this.getConstraintType()
    },
    getConstraintClass: function() {
        return Gnt.constraint.Base.getConstraintClass(this.getConstraintType())
    },
    isConstraintSatisfied: function() {
        var b = this,
        a = b.getTaskStore(true);
        return ! b.hasConstraint() || b.getConstraintClass().isSatisfied(b, b.getConstraintDate())
    },
    verifyConstraint: function(f) {
        var e = this,
        b, a, d, c, g;
        c = e.isConstraintSatisfied();
        f = f && Ext.Function.pass(f, [c]);
        b = e.getTaskStore(true);
        g = b && b.hasListener("constraintconflict");
        a = b && b.constraintDatePrecision || Sch.util.Date.DAY;
        d = !c && e.getConstraintClass().getResolution(f, e, null, a);
        if (!c && b && g) {
            b.fireEvent("constraintconflict", e, d)
        } else {
            if (!c) {
                d.cancelAction()
            } else {
                if (f) {
                    f(false)
                }
            }
        }
        return c
    },
    getWorkingTimeStartForDate: function(c) {
        var d = this,
        b = false,
        a, e;
        a = Ext.Date.clearTime(c, true);
        e = Sch.util.Date.add(a, Sch.util.Date.DAY, 1);
        d.forEachAvailabilityInterval({
            isForward: true,
            startDate: a,
            endDate: e,
            segments: false,
            resources: true,
            fn: function(g, f) {
                b = new Date(g);
                return false
            }
        });
        return b
    },
    getWorkingTimeEndForDate: function(c) {
        var d = this,
        b = false,
        a, e;
        a = Ext.Date.clearTime(c, true);
        e = Sch.util.Date.add(a, Sch.util.Date.DAY, 1);
        d.forEachAvailabilityInterval({
            isForward: false,
            startDate: a,
            endDate: e,
            segments: false,
            resources: true,
            fn: function(g, f) {
                b = new Date(f);
                return false
            }
        });
        return b
    },
    getNearestWorkingTimeStartForDate: function(c, d, b) {
        var f = this,
        e, a;
        d = d || false;
        b = b || 365;
        e = d ? -1 : 1;
        a = f.getWorkingTimeStartForDate(c);
        while (!a && b--) {
            c = Sch.util.Date.add(c, Sch.util.Date.DAY, e);
            a = f.getWorkingTimeStartForDate(c)
        }
        return a
    },
    getNearestWorkingTimeEndForDate: function(c, d, b) {
        var f = this,
        e, a;
        d = d || false;
        b = b || 365;
        e = d ? -1 : 1;
        a = f.getWorkingTimeEndForDate(c);
        while (!a && b--) {
            c = Sch.util.Date.add(c, Sch.util.Date.DAY, e);
            a = f.getWorkingTimeEndForDate(c)
        }
        return a
    },
    getWorkingTimeIntervalForDateTime: function(d) {
        var c = this,
        b = false,
        a, e;
        a = Ext.Date.clearTime(d, true);
        e = Sch.util.Date.add(a, Sch.util.Date.DAY, 1);
        d = d.valueOf();
        c.forEachAvailabilityInterval({
            isForward: true,
            startDate: a,
            endDate: e,
            segments: false,
            resources: true,
            fn: function(g, f) {
                if (g <= d && d <= f) {
                    b = {
                        startDate: new Date(g),
                        endDate: new Date(f)
                    }
                }
                return ! b
            }
        });
        return b
    },
    isDateTimeWithinWorkingTimeInterval: function(b) {
        var a = this;
        return a.getWorkingTimeIntervalForDateTime(b) !== false
    }
});
Ext.define("Gnt.model.task.Splittable", {
    uses: ["Gnt.model.TaskSegment"],
    segmentsTrackingSuspended: 0,
    changingTaskBySegments: false,
    splitsDuration: 0,
    segmentsSnapshot: null,
    segmentsProjection: null,
    getFirstSegment: function() {
        var a = this.getSegments();
        return a && a[0]
    },
    getLastSegment: function() {
        var a = this.getSegments();
        return a && a[a.length - 1]
    },
    normalizeSegments: function() {
        var a = this.getSegments();
        this.suspendSegmentsTracking();
        a.sort(function(d, c) {
            if (!d.normalized) {
                d.normalize()
            }
            if (!c.normalized) {
                c.normalize()
            }
            return d.getStartDate() > c.getStartDate() ? 1 : -1
        });
        this.mergeOverlappedSegments();
        if (a = this.getSegments()) {
            this.data[this.durationField] = this.getSegmentsDuration()
        }
        this.resumeSegmentsTracking()
    },
    updateSegmentsDates: function(a) {
        a = a || {};
        if (!this.isSegmented()) {
            return
        }
        this.suspendSegmentsTracking();
        a = Ext.apply({
            useAbsoluteOffset: false
        },
        a);
        a.isForward = a.isForward !== false;
        this.forEachSegment(function(b) {
            b.updateDatesByOffsets(a)
        },
        a.isForward);
        this.set(this.segmentsField, this.getSegments().slice());
        this.resumeSegmentsTracking()
    },
    getSegmentIntervalsForRange: function(h, d, g) {
        g = g || this.getSegments();
        if (!g) {
            return
        }
        var b = Sch.util.Date,
        k = [];
        for (var f = 0,
        e = g.length; f < e; f++) {
            var c = g[f],
            j = c.getStartDate(),
            a = c.getEndDate();
            if (b.intersectSpans(h, d, j, a)) {
                k.push([b.constrain(j, h, d) - 0, b.constrain(a, h, d) - 0])
            }
        }
        return k.length && k || null
    },
    getSegmentByDate: function(d, c) {
        c = c || this.getSegments();
        if (!c) {
            return
        }
        for (var e = 0,
        a = c.length; e < a; e++) {
            var b = c[e];
            if (d >= b.getStartDate() && d < b.getEndDate()) {
                return b
            }
        }
    },
    constrainSegments: function(d) {
        if (this.changingTaskBySegments) {
            return
        }
        d = d || {};
        var n = this.getSegments();
        if (!n) {
            return
        }
        var c = this.getDuration("MILLI"),
        q = d.unit || this.getDurationUnit(),
        f = d.duration,
        b = this.getStartDate(),
        r = this.getEndDate(),
        t = this.getUnitConverter();
        if (!b || (!r && !c && !f)) {
            this.set(this.segmentsField, null);
            return
        }
        if (f) {
            f = t.convertDurationToMs(f, q)
        } else {
            if (!r) {
                f = c
            }
        }
        this.suspendSegmentsTracking();
        n[0].setStartDateWithoutPropagation(this.getStartDate(), false);
        var m = 0,
        k = [],
        g = f,
        j,
        a;
        var h;
        if (f) {
            h = function(i) {
                return g <= 0
            }
        } else {
            h = function(i) {
                return i.getStartDate() >= r
            }
        }
        for (var p = 0,
        o = n.length; p < o; p++) {
            j = n[p];
            if (h(j)) {
                k.push.apply(k, n.slice(p));
                break
            }
            g -= j.getDuration("MILLI");
            if (a) {
                m += j.getStartOffset() - a.getEndOffset()
            }
            a = j
        }
        this.removeSegments(k);
        if (n.length < 2) {
            this.set(this.segmentsField, null)
        } else {
            var e = this.getLastSegment();
            var s = false;
            if (f) {
                if (g) {
                    e.setDurationWithoutPropagation(t.convertMSDurationToUnit(e.getEndOffset() - e.getStartOffset() + g, e.getDurationUnit()));
                    s = true
                }
            } else {
                if (e.getEndDate() - r) {
                    e.setEndDateWithoutPropagation(r, false);
                    s = true
                }
            }
            e.setNextSegment(null);
            this.splitsDuration = m;
            if ((k || s) && (!this.modified || !this.modified[this.segmentsField])) {
                this.set(this.segmentsField, this.getSegments().slice())
            }
        }
        this.resumeSegmentsTracking()
    },
    forEachSegment: function(b, e, d, a) {
        if (!b) {
            return
        }
        a = a || this;
        var f, c;
        if (e !== false) {
            f = "getNextSegment";
            c = d || this.getFirstSegment()
        } else {
            f = "getPrevSegment";
            c = d || this.getLastSegment()
        }
        while (c) {
            if (b.call(a, c) === false) {
                return
            }
            c = c[f].call(c)
        }
    },
    split: function(g, d, c, f, e) {
        var b = this,
        a;
        b.propagateChanges(function() {
            return b.splitWithoutPropagation(g, d, c, f,
            function h(i) {
                a = i
            })
        },
        function(i, h) {
            i && a && a();
            e && e(i, h)
        })
    },
    splitWithoutPropagation: function(n, a, i, k, e) {
        var u = this;
        if (k !== true && k !== false) {
            var f = u.getTaskStore(true);
            k = f ? f.skipWeekendsDuringDragDrop: false
        }
        if (!n || !u.isLeaf() || u.isMilestone()) {
            return
        }
        var c = u.getStartDate(),
        o = u.getEndDate();
        if (!c || !o || (c >= n) || (n >= o)) {
            return
        }
        var l = u.getSegments(),
        b;
        var d = u.buildSegmentsSnapshot(l);
        if (l) {
            b = u.getSegmentByDate(n);
            if (!b) {
                return
            }
        } else {
            l = []
        }
        a = a || 1;
        i = i || this.getDurationUnit();
        var r = new Date(n),
        p = r,
        h = r,
        m = u.getUnitConverter().convertDurationToMs(a, i);
        if (k) {
            h = u.skipNonWorkingTime(h, true, true);
            p = u.skipNonWorkingTime(p, false, true)
        }
        var q = u.getDurationUnit(),
        g,
        s;
        u.suspendSegmentsTracking();
        if (!b) {
            g = u.calculateDuration(c, p);
            s = u.getDuration() - g;
            l.push(Ext.create(u.segmentClassName, {
                StartDate: c,
                Duration: g,
                DurationUnit: q,
                task: u
            }))
        } else {
            g = u.calculateDuration(b.getStartDate(), p, q);
            s = b.getDuration(q) - g;
            b.setEndDateWithoutPropagation(p, false, k)
        }
        var t = u.getUnitConverter().convertDurationToMs(a, i);
        if (b && b.getNextSegment()) {
            u.forEachSegment(function(v) {
                v.setStartEndOffset(v.getStartOffset() + t, v.getEndOffset() + t);
                v.updateDatesByOffsets()
            },
            true, b.getNextSegment())
        }
        h = u.skipWorkingTime(h, t);
        if (k) {
            h = u.skipNonWorkingTime(h)
        }
        var j = Ext.create(u.segmentClassName, {
            StartDate: h,
            Duration: s,
            DurationUnit: q,
            prevSegment: b || l[0],
            task: u
        });
        if (b) {
            Ext.Array.insert(l, Ext.Array.indexOf(l, b) + 1, [j])
        } else {
            l.push(j)
        }
        u.resumeSegmentsTracking();
        e && e(function() {
            u.rollbackSegmentsToSnapshot(d)
        });
        if (!b) {
            u.setSegmentsWithoutPropagation(l)
        } else {
            u.onSegmentsChanged(null, null)
        }
        return true
    },
    merge: function(b, a, d) {
        var c = this;
        c.propagateChanges(function() {
            return c.mergeWithoutPropagation(b, a)
        },
        d)
    },
    mergeWithoutPropagation: function(c, a) {
        if (!this.isSegmented() || !c || !a) {
            return
        }
        var d, b;
        if (c.getStartOffset() > a.getStartOffset()) {
            d = a;
            b = c
        } else {
            d = c;
            b = a
        }
        d.setEndDateWithoutPropagation(b.getEndDate(), false);
        return true
    },
    suspendSegmentsTracking: function() {
        this.segmentsTrackingSuspended++
    },
    resumeSegmentsTracking: function() {
        this.segmentsTrackingSuspended--
    },
    getSegmentsDuration: function(e) {
        e = e || this.getDurationUnit();
        var b = this.getSegments();
        var f = 0;
        for (var c = 0,
        a = b.length; c < a; c++) {
            var d = b[c];
            f += d.getEndOffset() - d.getStartOffset()
        }
        return this.getUnitConverter().convertMSDurationToUnit(f, e)
    },
    mergeOverlappedSegments: function(g) {
        var b = this.getSegments();
        if (b) {
            var d = [],
            e = b[0],
            f;
            for (var c = 1,
            a = b.length; c < a; c++) {
                f = b[c];
                if (f.getStartOffset() <= e.getEndOffset()) {
                    d.push(f);
                    if (f.getEndOffset() > e.getEndOffset()) {
                        e.setEndDateWithoutPropagation(f.getEndDate(), false)
                    }
                } else {
                    f.setPrevSegment(e);
                    e = f
                }
            }
            this.removeSegments(d);
            if (b.length < 2 && !g) {
                this.setSegmentsWithoutPropagation(null)
            } else {
                b[b.length - 1].setNextSegment(null)
            }
        }
    },
    onSegmentEditBegin: function(a) {
        this.snapshotSegments()
    },
    onSegmentsChanged: function(c, b) {
        if (this.segmentsTrackingSuspended) {
            return
        }
        var a = this.getSegments();
        this.changingTaskBySegments = true;
        this.suspendSegmentsTracking();
        this.mergeOverlappedSegments(true);
        a = this.getSegments();
        if (c && b && c.durationField in b) {
            this.setDurationWithoutPropagation(this.getSegmentsDuration())
        } else {
            this.setStartDateWithoutPropagation(this.getStartDate(), true)
        }
        a = this.getSegments();
        this.set(this.segmentsField, a && a.slice() || null);
        this.resumeSegmentsTracking();
        this.changingTaskBySegments = false
    },
    removeSegments: function(d) {
        var b = this.getSegments();
        if (!b || !d || !d.length) {
            return
        }
        if (!Ext.isArray(d)) {
            d = [d]
        }
        for (var c = 0,
        a = d.length; c < a; c++) {
            Ext.Array.remove(b, d[c])
        }
        this.onSegmentsChanged()
    },
    setSegments: function(b, c) {
        var a = this;
        a.propagateChanges(function() {
            return a.setSegmentsWithoutPropagation(b)
        },
        c)
    },
    setSegmentsWithoutPropagation: function(a) {
        this.splitsDuration = 0;
        this.suspendSegmentsTracking();
        var b = this.getSegments();
        this.set(this.segmentsField, this.processSegmentsValue(a));
        if (!this.isSegmented()) {
            if (b) {
                this.removeSegments(b.slice())
            }
        }
        this.resumeSegmentsTracking();
        this.onSegmentsChanged(null, null);
        return true
    },
    processSegmentsValue: function(d) {
        var b;
        if (d) {
            d = [].concat(d);
            b = [];
            for (var c = 0,
            a = d.length; c < a; c++) {
                if (d[c] instanceof Gnt.model.TaskSegment) {
                    b.push(d[c])
                } else {
                    b.push(Ext.create(this.segmentClassName, Ext.apply(d[c], {
                        task: this
                    })))
                }
            }
            d = b && b.length > 1 && b || null
        }
        return d
    },
    isSegmented: function() {
        return Boolean(this.getSegments())
    },
    getSegment: function(a) {
        return this.getSegments()[a]
    },
    rejectSegmentsProjection: function() {
        var d = this.getTaskStore(true).getProjectionLevel();
        var b, c;
        if (this.segmentsProjection) {
            var a;
            for (c = d; c >= 0; c--) {
                if (b = this.segmentsProjection[c]) {
                    a = c;
                    break
                }
            }
            if (a === d) {
                delete this.segmentsProjection[a]
            }
        }
        if (b) {
            this.rollbackSegmentsToSnapshot(b)
        }
    },
    commitSegmentsProjection: function() {
        var a = this.getTaskStore(true),
        b = a && a.getProjectionLevel();
        if (this.segmentsProjection) {
            delete this.segmentsProjection[b]
        }
    },
    rollbackSegmentsToSnapshot: function(a) {
        this.data[this.segmentsField] = a && Ext.Array.map(a,
        function(b) {
            return b && b[0].readSnapshot(b)
        })
    },
    buildSegmentsSnapshot: function(a) {
        a = a || this.getSegments();
        return a && Ext.Array.map(a,
        function(b) {
            return b && b.buildSnapshot()
        })
    },
    snapshotSegments: function() {
        var c = this.getTaskStore(true),
        b = this.getSegments(),
        d = c && c.getProjectionLevel(),
        a;
        if (d) {
            this.segmentsProjection = this.segmentsProjection || {};
            a = this.segmentsProjection[d - 1];
            if (!a) {
                a = this.buildSegmentsSnapshot(b);
                this.segmentsProjection[d - 1] = a
            }
        }
        if (!this.segmentsSnapshot) {
            this.segmentsSnapshot = a || this.buildSegmentsSnapshot(b)
        }
    },
    commitSegments: function() {
        if (this.rejecting) {
            return
        }
        this.segmentsSnapshot = null;
        var b = this.getSegments();
        if (b) {
            for (var c = 0,
            a = b.length; c < a; c++) {
                b[c].commit()
            }
        }
    },
    rejectSegments: function() {
        this.rollbackSegmentsToSnapshot(this.segmentsSnapshot);
        this.segmentsSnapshot = null;
        var b = this.getSegments();
        if (b) {
            for (var c = 0,
            a = b.length; c < a; c++) {
                b[c].reject()
            }
        }
    }
});
Ext.define("Gnt.model.Task", {
    extend: "Sch.model.Range",
    requires: ["Sch.util.Date", "Ext.data.NodeInterface"],
    uses: ["Gnt.model.TaskSegment"],
    mixins: ["Gnt.model.mixin.ProjectableModel", "Gnt.model.task.More", "Gnt.model.task.Constraints", "Gnt.model.task.Splittable"],
    segmentClassName: "Gnt.model.TaskSegment",
    idProperty: "Id",
    customizableFields: [{
        name: "Duration",
        type: "number",
        allowNull: true
    },
    {
        name: "Effort",
        type: "number",
        allowNull: true
    },
    {
        name: "EffortUnit",
        type: "string",
        defaultValue: "h"
    },
    {
        name: "CalendarId",
        type: "string"
    },
    {
        name: "Note",
        type: "string"
    },
    {
        name: "DurationUnit",
        type: "string",
        defaultValue: "d",
        convert: function(a) {
            return a || "d"
        }
    },
    {
        name: "PercentDone",
        type: "number",
        defaultValue: 0
    },
    {
        name: "ConstraintType",
        type: "string",
        defaultValue: ""
    },
    {
        name: "ConstraintDate",
        type: "date",
        dateFormat: "c"
    },
    {
        name: "ManuallyScheduled",
        type: "boolean",
        defaultValue: false
    },
    {
        name: "SchedulingMode",
        type: "string",
        defaultValue: "Normal"
    },
    {
        name: "BaselineStartDate",
        type: "date",
        dateFormat: "c"
    },
    {
        name: "BaselineEndDate",
        type: "date",
        dateFormat: "c"
    },
    {
        name: "BaselinePercentDone",
        type: "int",
        defaultValue: 0
    },
    {
        name: "Draggable",
        type: "boolean",
        persist: false,
        defaultValue: true
    },
    {
        name: "Resizable",
        persist: false,
        defaultValue: ""
    },
    {
        name: "Rollup",
        type: "boolean",
        defaultValue: false
    },
    {
        name: "Segments",
        persist: true,
        convert: function(b, a) {
            return a.processSegmentsValue(b, a)
        },
        serialize: function(f, b) {
            if (!f) {
                return null
            }
            var c = [].concat(f),
            e = [];
            for (var d = 0,
            a = c.length; d < a; d++) {
                e.push(c[d].serialize())
            }
            return e
        }
    },
    {
        name: "PhantomId",
        type: "string"
    },
    {
        name: "PhantomParentId",
        type: "string"
    },
    {
        name: "index",
        type: "int",
        persist: true
    }],
    constraintTypeField: "ConstraintType",
    constraintDateField: "ConstraintDate",
    draggableField: "Draggable",
    resizableField: "Resizable",
    nameField: "Name",
    durationField: "Duration",
    durationUnitField: "DurationUnit",
    effortField: "Effort",
    effortUnitField: "EffortUnit",
    percentDoneField: "PercentDone",
    manuallyScheduledField: "ManuallyScheduled",
    schedulingModeField: "SchedulingMode",
    rollupField: "Rollup",
    calendarIdField: "CalendarId",
    baselineStartDateField: "BaselineStartDate",
    baselineEndDateField: "BaselineEndDate",
    baselinePercentDoneField: "BaselinePercentDone",
    noteField: "Note",
    segmentsField: "Segments",
    calendar: null,
    dependencyStore: null,
    taskStore: null,
    phantomIdField: "PhantomId",
    phantomParentIdField: "PhantomParentId",
    normalized: false,
    recognizedSchedulingModes: ["Normal", "Manual", "FixedDuration", "EffortDriven", "DynamicAssignment"],
    convertEmptyParentToLeaf: true,
    autoCalculateEffortForParentTask: true,
    autoCalculatePercentDoneForParentTask: true,
    isHighlighted: false,
    calendarWaitingListener: null,
    childTasksDuration: null,
    completedChildTasksDuration: null,
    totalCount: null,
    predecessors: null,
    successors: null,
    assignments: null,
    removeChildIsCalledFromReplaceChild: false,
    savedDirty: null,
    useOwnCalendarAsConverter: false,
    constructor: function() {
        this._singleProp = {};
        this.initProjectable();
        this.callParent(arguments);
        if (this.phantom) {
            this.data[this.phantomIdField] = this.getInternalId();
            this._phantomId = this.getInternalId()
        }
        this.predecessors = [];
        this.successors = [];
        this.assignments = []
    },
    normalize: function() {
        var h = this.getDurationUnit(),
        c = this.getStartDate(),
        g = this.getEndDate(),
        f = this.getSchedulingMode(),
        e = this.data,
        j = this.getTaskStore(true);
        this.assignments = j && j.cachedAssignments && j.cachedAssignments[this.getId()] || this.assignments;
        var b = this.endDateField;
        if (j && this.isSegmented()) {
            this.normalizeSegments();
            var m;
            if (m = this.getLastSegment()) {
                g = e[b] = m.getEndDate()
            }
        }
        var d = this.getDuration();
        var k = this.effortField;
        if (g && this.inclusiveEndDate) {
            var l = this.getField(b).dateFormat;
            var a = (l && !Ext.Date.formatContainsHourInfo(l)) || (g.getHours() === 0 && g.getMinutes() === 0 && g.getSeconds() === 0 && g.getMilliseconds() === 0);
            if (a) {
                if (Ext.isNumber(d)) {
                    g = e[b] = this.calculateEndDate(c, d, h)
                } else {
                    g = e[b] = Ext.Date.add(g, Ext.Date.DAY, 1)
                }
            }
        }
        if (d == null && c && g) {
            d = e[this.durationField] = this.calculateDuration(c, g, h)
        }
        if ((f == "Normal" || this.isManuallyScheduled()) && g == null && c && Ext.isNumber(d)) {
            g = e[b] = this.calculateEndDate(c, d, h)
        }
        var o = this.get(k),
        i = this.getEffortUnit();
        if (f == "FixedDuration") {
            if (g == null && c && Ext.isNumber(d)) {
                g = e[b] = this.calculateEndDate(c, d, h)
            }
            if (o == null && c && g) {
                e[k] = this.calculateEffort(c, g, i)
            }
        } else {
            if (f == "EffortDriven") {
                if (o == null && c && g) {
                    e[k] = this.calculateEffort(c, g, i)
                }
                if (g == null && c && o) {
                    e[b] = this.calculateEffortDrivenEndDate(c, o, i);
                    if (d == null) {
                        e[this.durationField] = this.calculateDuration(c, e[b], h)
                    }
                }
            } else {
                if (g == null && c && Ext.isNumber(d)) {
                    g = e[b] = this.calculateEndDate(c, d, h)
                }
            }
        }
        var n = this.getCalendarId();
        if (n) {
            this.setCalendarId(n, true)
        }
        this.normalized = true
    },
    getUnitConverter: function() {
        return this.useOwnCalendarAsConverter && this.getCalendar() || this.getProjectCalendar()
    },
    normalizeParent: function() {
        var l = this.childNodes;
        var a = 0;
        var d = 0;
        var h = 0;
        var j = this.autoCalculatePercentDoneForParentTask;
        var f = this.autoCalculateEffortForParentTask;
        for (var e = 0; e < l.length; e++) {
            var c = l[e];
            var b = c.isLeaf();
            if (!b) {
                c.normalizeParent()
            }
            if (f) {
                a += c.getEffort("MILLI")
            }
            if (j) {
                var k = b ? c.getDuration("MILLI") || 0 : c.childTasksDuration;
                d += k;
                h += b ? k * (c.getPercentDone() || 0) : c.completedChildTasksDuration
            }
        }
        if (j) {
            this.childTasksDuration = d;
            this.completedChildTasksDuration = h;
            var g = d ? h / d: 0;
            if (this.getPercentDone() != g) {
                this.data[this.percentDoneField] = g
            }
        }
        if (f) {
            if (this.getEffort("MILLI") != a) {
                this.data[this.effortField] = this.getUnitConverter().convertMSDurationToUnit(a, this.getEffortUnit())
            }
        }
    },
    getInternalId: function() {
        return this.getId() || this.internalId
    },
    getCalendar: function(a) {
        return a ? this.getOwnCalendar() : this.getOwnCalendar() || this.parentNode && this.parentNode.getCalendar() || this.getProjectCalendar()
    },
    getOwnCalendar: function() {
        var a = this.get(this.calendarIdField);
        return a ? Gnt.data.Calendar.getCalendar(a) : this.calendar
    },
    getProjectCalendar: function() {
        var a = this.getTaskStore(true);
        var b = a && a.getCalendar() || this.parentNode && this.parentNode.getProjectCalendar() || this.isRoot() && this.calendar;
        if (!b) {
            Ext.Error.raise("Can't find a project calendar in `getProjectCalendar`")
        }
        return b
    },
    setCalendar: function(c, d) {
        var b = this,
        a = c instanceof Gnt.data.Calendar;
        if (a && !c.calendarId) {
            throw new Error("Can't set calendar w/o `calendarId` property")
        }
        return b.setCalendarId(a ? c.calendarId: c, false, d)
    },
    setCalendarId: function(b, c, d) {
        var a = this;
        if (!c) {
            a.propagateChanges(function() {
                return a.setCalendarIdWithoutPropagation(b, c)
            },
            d)
        } else {
            a.setCalendarIdWithoutPropagation(b, c)
        }
    },
    setCalendarIdWithoutPropagation: function(d, e) {
        var a = false;
        if (d instanceof Gnt.data.Calendar) {
            d = d.calendarId
        }
        var c = this.getCalendarId();
        if (c != d || e) {
            a = true;
            if (this.calendarWaitingListener) {
                this.calendarWaitingListener.destroy();
                this.calendarWaitingListener = null
            }
            var b = {
                calendarchange: this.adjustToCalendarWithoutPropagation,
                scope: this
            };
            var g = this.calendar || Gnt.data.Calendar.getCalendar(c);
            this.calendar = null;
            g && g.un(b);
            this.set(this.calendarIdField, d);
            var f = Gnt.data.Calendar.getCalendar(d);
            if (f) {
                f.on(b);
                if (!e) {
                    this.adjustToCalendarWithoutPropagation()
                }
            } else {
                this.calendarWaitingListener = Ext.data.StoreManager.on("add",
                function(h, j, i) {
                    f = Gnt.data.Calendar.getCalendar(d);
                    if (f) {
                        this.calendarWaitingListener.destroy();
                        this.calendarWaitingListener = null;
                        f.on(b);
                        this.adjustToCalendarWithoutPropagation()
                    }
                },
                this, {
                    destroyable: true
                })
            }
        }
        return a
    },
    getDependencyStore: function() {
        var a = this.dependencyStore || this.getTaskStore().dependencyStore;
        if (!a) {
            Ext.Error.raise("Can't find a dependencyStore in `getDependencyStore`")
        }
        return a
    },
    getResourceStore: function() {
        return this.getTaskStore().getResourceStore()
    },
    getAssignmentStore: function() {
        return this.getTaskStore().getAssignmentStore()
    },
    getTaskStore: function(b) {
        if (this.taskStore) {
            return this.taskStore
        }
        var a = this.getTreeStore() || this.parentNode && this.parentNode.getTaskStore(b);
        if (!a && !b) {
            Ext.Error.raise("Can't find a taskStore in `getTaskStore`")
        }
        this.taskStore = a;
        return a
    },
    setTaskStore: function(a) {
        this.taskStore = a
    },
    isManuallyScheduled: function() {
        return this.get(this.schedulingModeField) === "Manual" || this.get(this.manuallyScheduledField)
    },
    setSchedulingMode: function(b, c) {
        var a = this;
        a.propagateChanges(function() {
            return a.setSchedulingModeWithoutPropagation(b)
        },
        c)
    },
    setSchedulingModeWithoutPropagation: function(c) {
        var b = this,
        a;
        if (b.getSchedulingMode() != c) {
            b.set(this.schedulingModeField, c);
            switch (c) {
            case "FixedDuration":
                b.updateEffortBasedOnDuration();
                break;
            case "EffortDriven":
                b.updateSpanBasedOnEffort();
                break
            }
            var d = b.getPredecessors();
            if (d.length > 0) {
                a = d[0]
            } else {
                a = b
            }
        }
        return a
    },
    skipWorkingTime: function(d, f, e, c) {
        var a;
        var g;
        e = e !== false;
        var b = {
            isForward: e,
            segments: c || false,
            resources: this.hasResources(),
            fn: function(k, j) {
                var i = j - k,
                h = new Date(k).getTimezoneOffset() - new Date(j).getTimezoneOffset();
                if (i >= g) {
                    a = new Date((e ? k: j) - 0 + (e ? 1 : -1) * g);
                    return false
                } else {
                    g -= i + h * 60 * 1000
                }
            }
        };
        if (Ext.isObject(d)) {
            Ext.apply(b, d)
        } else {
            if (e) {
                b.startDate = d
            } else {
                b.endDate = d
            }
        }
        g = f || b.duration;
        if (!g) {
            return d
        }
        this.forEachAvailabilityInterval(b);
        return a
    },
    skipNonWorkingTime: function(d, e, c) {
        var b = false;
        e = e !== false;
        var a = {
            isForward: e,
            segments: c || false,
            resources: this.hasResources(),
            fn: function(g, f) {
                if (g !== f) {
                    d = e ? g: f;
                    b = true;
                    return false
                }
            }
        };
        if (Ext.isObject(d)) {
            Ext.apply(a, d)
        } else {
            if (e) {
                a.startDate = d
            } else {
                a.endDate = d
            }
        }
        this.forEachAvailabilityInterval(a);
        return b ? new Date(d) : this.getCalendar().skipNonWorkingTime(d, e)
    },
    setStartDate: function(a, e, d, c) {
        var b = this;
        b.propagateChanges(function() {
            return b.setStartDateWithoutPropagation(a, e, d)
        },
        function(f, g) {
            if (f) {
                b.rejectSegmentsProjection()
            } else {
                b.commitSegmentsProjection()
            }
            c && c.apply(this, arguments)
        })
    },
    setStartDateWithoutPropagation: function(b, h, g) {
        var c = this,
        a = c.getTaskStore(true),
        e,
        d;
        h = h !== false;
        if (a && g !== true && g !== false) {
            g = a.skipWeekendsDuringDragDrop
        } else {
            if (g !== true && g !== false) {
                g = false
            }
        }
        c.beginEdit();
        if (!b) {
            c.set(c.durationField, null);
            c.set(c.startDateField, null);
            c.setSegments(null)
        } else {
            if (g) {
                b = c.skipNonWorkingTime(b, !c.isMilestone())
            }
            var f = c.getStartDate();
            c.set(c.startDateField, b);
            if (a && c.isSegmented() && (b - f)) {
                c.updateSegmentsDates()
            }
            if (h !== false) {
                c.set(c.endDateField, c.recalculateEndDate(b))
            } else {
                d = this.getEndDate();
                if (d) {
                    this.constrainSegments();
                    c.set(c.durationField, c.calculateDuration(b, d, c.getDurationUnit()))
                }
            }
        }
        e = c.getDuration();
        d = c.getEndDate();
        if (b && d && (e === undefined || e === null)) {
            c.set(c.durationField, c.calculateDuration(b, d, c.getDurationUnit()))
        }
        c.onPotentialEffortChange();
        c.endEdit();
        return true
    },
    setEndDate: function(a, e, d, c) {
        var b = this;
        b.propagateChanges(function() {
            return b.setEndDateWithoutPropagation(a, e, d)
        },
        function(f, g) {
            if (f) {
                b.rejectSegmentsProjection()
            } else {
                b.commitSegmentsProjection()
            }
            c && c.apply(this, arguments)
        })
    },
    setEndDateWithoutPropagation: function(e, c, d) {
        var i = this,
        j = i.getTaskStore(true),
        g,
        b;
        c = c !== false;
        if (d !== true && d !== false && j) {
            d = j.skipWeekendsDuringDragDrop
        } else {
            if (d !== true && d !== false) {
                d = false
            }
        }
        i.beginEdit();
        var h = i.getEndDate();
        if (!e) {
            i.set(i.durationField, null);
            i.set(i.endDateField, null);
            i.setSegments(null)
        } else {
            b = i.getStartDate();
            if (e < b && c === false) {
                e = b
            }
            if (d) {
                e = i.skipNonWorkingTime(e, false)
            }
            if (c !== false) {
                g = i.getDuration();
                if (Ext.isNumber(g)) {
                    if (j && i.isSegmented() && (e - h)) {
                        i.updateSegmentsDates({
                            isForward: false,
                            endDate: e
                        })
                    }
                    i.set(i.startDateField, i.calculateStartDate(e, g, i.getDurationUnit()));
                    i.set(i.endDateField, e)
                } else {
                    i.set(i.endDateField, e)
                }
            } else {
                var f = i.isMilestone();
                if (e < b) {
                    i.set(i.startDateField, e)
                }
                i.set(i.endDateField, e);
                i.constrainSegments();
                if (b) {
                    i.set(i.durationField, i.calculateDuration(b, e, i.getDurationUnit()));
                    if (f && !i.isMilestone()) {
                        var a = i.skipNonWorkingTime(b, true);
                        if (a - b !== 0) {
                            i.set(i.startDateField, a)
                        }
                    }
                }
            }
        }
        g = i.getDuration();
        b = i.getStartDate();
        if (e && b && (g === undefined || g === null)) {
            i.set(i.durationField, i.calculateDuration(b, e, i.getDurationUnit()))
        }
        i.onPotentialEffortChange();
        i.endEdit();
        return true
    },
    setStartEndDate: function(a, c, e, d) {
        var b = this;
        e = e || false;
        b.propagateChanges(function() {
            return b.setStartEndDateWithoutPropagation(a, c, e)
        },
        function(f, g) {
            if (f) {
                b.rejectSegmentsProjection()
            } else {
                b.commitSegmentsProjection()
            }
            d && d.apply(this, arguments)
        })
    },
    setStartEndDateWithoutPropagation: function(a, e, g) {
        var c = this,
        b = c.getTaskStore(true);
        if (g !== true && g !== false && b) {
            g = b.skipWeekendsDuringDragDrop
        } else {
            if (g !== true && g !== false) {
                g = false
            }
        }
        if (g) {
            a = a && c.skipNonWorkingTime(a, true);
            e = e && c.skipNonWorkingTime(e, false);
            if (e < a) {
                a = e
            }
        }
        var f = c.getStartDate(),
        d = c.getEndDate();
        c.beginEdit();
        c.set(c.startDateField, a);
        c.set(c.endDateField, e);
        if (c.getTaskStore(true) && c.isSegmented() && ((a - f) || (e - d))) {
            c.updateSegmentsDates()
        }
        if (e - d) {
            c.constrainSegments()
        }
        c.set(c.durationField, c.calculateDuration(a, e, c.getDurationUnit()));
        c.onPotentialEffortChange();
        c.endEdit();
        return true
    },
    shift: function(c, a, d) {
        var b = this;
        b.setStartEndDate(Sch.util.Date.add(b.getStartDate(), c, a), Sch.util.Date.add(b.getEndDate(), c, a), undefined, d)
    },
    getDuration: function(b) {
        if (!b) {
            return this.get(this.durationField)
        }
        var a = this.getUnitConverter(),
        c = a.convertDurationToMs(this.get(this.durationField), this.get(this.durationUnitField));
        return a.convertMSDurationToUnit(c, b)
    },
    getEffort: function(b) {
        var c = this.get(this.effortField) || 0;
        if (!b) {
            return c
        }
        var a = this.getUnitConverter(),
        d = a.convertDurationToMs(c, this.getEffortUnit());
        return a.convertMSDurationToUnit(d, b)
    },
    setEffort: function(c, b, d) {
        var a = this;
        a.propagateChanges(function() {
            return a.setEffortWithoutPropagation(c, b)
        },
        function(e) {
            if (e) {
                a.rejectSegmentsProjection()
            } else {
                a.commitSegmentsProjection()
            }
            d && d.apply(this, arguments)
        })
    },
    setEffortWithoutPropagation: function(c, b) {
        var a = this;
        b = b || a.getEffortUnit();
        a.beginEdit();
        a.set(a.effortField, c);
        a.set(a.effortUnitField, b);
        switch (a.getSchedulingMode()) {
        case "EffortDriven":
            a.updateSpanBasedOnEffort();
            break;
        case "DynamicAssignment":
            a.updateAssignments();
            break
        }
        a.endEdit();
        return true
    },
    getCalendarDuration: function(a) {
        return this.getUnitConverter().convertMSDurationToUnit(this.getEndDate() - this.getStartDate(), a || this.get(this.durationUnitField))
    },
    setDuration: function(c, b, d) {
        var a = this;
        a.propagateChanges(function() {
            return a.setDurationWithoutPropagation(c, b)
        },
        function(e) {
            if (e) {
                a.rejectSegmentsProjection()
            } else {
                a.commitSegmentsProjection()
            }
            d && d.apply(this, arguments)
        })
    },
    setDurationWithoutPropagation: function(d, j) {
        var h = this;
        j = j || h.getDurationUnit();
        var e = h.isMilestone();
        h.beginEdit();
        if (Ext.isNumber(d) && !h.getStartDate()) {
            var i = h.getTaskStore(true);
            var b = (i && i.getProjectStartDate()) || Ext.Date.clearTime(new Date());
            h.setStartDateWithoutPropagation(b)
        }
        var f = null;
        this.constrainSegments({
            duration: d,
            unit: j
        });
        if (Ext.isNumber(d)) {
            f = h.calculateEndDate(h.getStartDate(), d, j)
        }
        h.set(h.endDateField, f);
        h.set(h.durationField, d);
        h.set(h.durationUnitField, j);
        if (h.isMilestone() != e) {
            if (e) {
                var c = h.getStartDate();
                if (c) {
                    var a = h.skipNonWorkingTime(c, true);
                    if (a - c !== 0) {
                        h.set(h.startDateField, a)
                    }
                }
            } else {
                if (f) {
                    var g = h.skipNonWorkingTime(f, false);
                    if (g - f !== 0) {
                        h.set(h.startDateField, g);
                        h.set(h.endDateField, g)
                    }
                }
            }
        }
        h.onPotentialEffortChange();
        h.endEdit();
        return true
    },
    calculateStartDate: function(e, d, c) {
        c = c || this.getDurationUnit();
        if (!d) {
            return e
        }
        if (this.getTaskStore(true)) {
            var b = this.getUnitConverter().convertDurationToMs(d, c || this.getDurationUnit());
            var a;
            this.forEachAvailabilityInterval({
                endDate: e,
                isForward: false,
                resources: this.hasResources()
            },
            function(i, h, g) {
                var f = h - i;
                if (f >= b) {
                    a = new Date(h - b);
                    return false
                } else {
                    b -= f
                }
            });
            return a
        } else {
            return this.getCalendar().calculateStartDate(e, d, c)
        }
    },
    recalculateEndDate: function(b) {
        var c = this,
        a, d;
        b = b || c.getStartDate();
        if (b && c.getSchedulingMode() == "EffortDriven") {
            a = c.calculateEffortDrivenEndDate(b, c.getEffort())
        } else {
            d = c.getDuration();
            if (b && Ext.isNumber(d)) {
                a = c.calculateEndDate(b, d, c.getDurationUnit())
            } else {
                a = c.getEndDate()
            }
        }
        return a
    },
    calculateEndDate: function(a, g, e) {
        e = e || this.getDurationUnit();
        if (!g) {
            return a
        }
        var d = this.getSchedulingMode(),
        c = {
            startDate: a
        },
        f;
        if (this.getTaskStore(true) && d != "FixedDuration" && d != "DynamicAssignment" && d != "EffortDriven") {
            var b = this.getUnitConverter().convertDurationToMs(g, e);
            c.resources = this.hasResources();
            this.forEachAvailabilityInterval(c,
            function(k, j) {
                var i = j - k;
                if (i >= b) {
                    f = new Date(k + b);
                    return false
                } else {
                    var h = new Date(k).getTimezoneOffset() - new Date(j).getTimezoneOffset();
                    b -= i + h * 60 * 1000
                }
            })
        } else {
            return this.getCalendar().calculateEndDate(a, g, e)
        }
        return f
    },
    calculateDuration: function(a, c, b) {
        b = b || this.getDurationUnit();
        if (!a || !c) {
            return 0
        }
        if (this.getTaskStore(true)) {
            var d = 0;
            this.forEachAvailabilityInterval({
                startDate: a,
                endDate: c,
                resources: this.hasResources()
            },
            function(g, f) {
                var e = new Date(g).getTimezoneOffset() - new Date(f).getTimezoneOffset();
                d += f - g + e * 60 * 1000
            });
            return this.getUnitConverter().convertMSDurationToUnit(d, b)
        } else {
            return this.getCalendar().calculateDuration(a, c, b)
        }
    },
    isCalendarApplicable: function(j) {
        var b = this.getStartDate();
        if (!b) {
            return true
        }
        var h = this.getTaskStore(true);
        if (!h) {
            return true
        }
        var g = Sch.util.Date.add(b, "d", (h && h.availabilitySearchLimit) || 5 * 365);
        var a = this.getAssignments();
        var c = [];
        Ext.each(a,
        function(k) {
            var i = k.getResource();
            if (i) {
                c.push(i.getCalendar())
            }
        });
        if (!c.length) {
            return true
        }
        var e = Gnt.data.Calendar.getCalendar(j);
        for (var f = 0,
        d = c.length; f < d; f++) {
            if (e.isAvailabilityIntersected(c[f], b, g)) {
                return true
            }
        }
        return false
    },
    forEachAvailabilityInterval: function(y, t, K) {
        t = t || y.fn;
        K = K || y.scope || this;
        var r = this,
        d = y.startDate,
        v = y.endDate,
        C = y.includeEmptyIntervals,
        X = y.resources,
        N = y.segments || (y.segments !== false),
        s = y.isForward !== false,
        h = Sch.util.Date,
        x,
        g;
        var a = this.getTaskStore(true);
        if (s) {
            if (!d) {
                throw new Error("forEachAvailabilityInterval: `startDate` is required when `isForward` is true")
            }
            if (!v) {
                v = h.add(d, "d", y.availabilitySearchLimit || (a && a.availabilitySearchLimit) || 5 * 365)
            }
            x = new Date(d)
        } else {
            if (!v) {
                throw new Error("forEachAvailabilityInterval: `endDate` is required when `isForward` is false")
            }
            if (!d) {
                d = h.add(v, "d", -(y.availabilitySearchLimit || (a && a.availabilitySearchLimit) || 5 * 365))
            }
            x = new Date(v)
        }
        var E = this.getOwnCalendar(),
        W = this.getProjectCalendar(),
        e = {},
        w = [];
        if (X) {
            var G = false;
            var o = y.assignments;
            var q = function(i) {
                var n = i.getInternalId(),
                l = o && Ext.Array.findBy(o,
                function(Y) {
                    return Y.getResourceId() == i.getInternalId()
                }) || r.getAssignmentFor(i),
                k = i.getCalendar(),
                m = k.getCalendarId();
                if (!e[m]) {
                    e[m] = [];
                    w.push(k)
                }
                e[m].push({
                    assignment: l,
                    resourceId: n,
                    units: l && l.getUnits()
                });
                G = true
            };
            if (X !== true) {
                Ext.each(X, q)
            } else {
                Ext.each(this.getAssignments(),
                function(k) {
                    var i = k.getResource();
                    if (i) {
                        q(i)
                    }
                })
            }
            if (!G) {
                return
            }
        } else {
            E = E || W
        }
        if (N) {
            if (!Ext.isArray(N)) {
                g = this.getSegments()
            } else {
                g = N
            }
        }
        var U, S, R, b, V, B;
        while (s ? x < v: x > d) {
            var z = {};
            var f = [];
            var I = x - (s ? 0 : 1);
            if (E) {
                var J = E.getAvailabilityIntervalsFor(I);
                for (S = 0, R = J.length; S < R; S++) {
                    b = J[S];
                    V = b.startDate - 0;
                    B = b.endDate - 0;
                    if (!z[V]) {
                        z[V] = [];
                        f.push(V)
                    }
                    z[V].push({
                        type: "00-taskAvailailabilityStart",
                        typeBackward: "01-taskAvailailabilityStart"
                    });
                    f.push(B);
                    z[B] = z[B] || [];
                    z[B].push({
                        type: "01-taskAvailailabilityEnd",
                        typeBackward: "00-taskAvailailabilityEnd"
                    })
                }
            }
            if (g) {
                var j, c;
                if (s) {
                    j = x;
                    c = h.getStartOfNextDay(x)
                } else {
                    j = h.getEndOfPreviousDay(x);
                    c = x
                }
                var p = this.getSegmentIntervalsForRange(j, c, g);
                if (p) {
                    for (U = 0, R = p.length; U < R; U++) {
                        V = p[U][0];
                        B = p[U][1];
                        if (!z[V]) {
                            z[V] = [];
                            f.push(V)
                        }
                        z[V].push({
                            type: "04-taskSegmentStart",
                            typeBackward: "05-taskSegmentStart"
                        });
                        f.push(B);
                        z[B] = z[B] || [];
                        z[B].push({
                            type: "05-taskSegmentEnd",
                            typeBackward: "04-taskSegmentEnd"
                        })
                    }
                }
            }
            var T;
            for (U = 0, R = w.length; U < R; U++) {
                var M = w[U],
                A = M.getAvailabilityIntervalsFor(I);
                T = e[M.getCalendarId()];
                for (S = 0; S < A.length; S++) {
                    b = A[S];
                    V = b.startDate - 0;
                    B = b.endDate - 0;
                    if (!z[V]) {
                        z[V] = [];
                        f.push(V)
                    }
                    z[V].push({
                        type: "02-resourceAvailailabilityStart",
                        typeBackward: "03-resourceAvailailabilityStart",
                        resources: T
                    });
                    if (!z[B]) {
                        z[B] = [];
                        f.push(B)
                    }
                    z[B].push({
                        type: "03-resourceAvailailabilityEnd",
                        typeBackward: "02-resourceAvailailabilityEnd",
                        resources: T
                    })
                }
            }
            f.sort();
            var H = false,
            u = false,
            Q = {},
            F = 0,
            L, D, P, O;
            if (s) {
                for (U = 0, R = f.length; U < R; U++) {
                    L = z[f[U]];
                    L.sort(function(k, i) {
                        return k.type < i.type ? 1 : -1
                    });
                    for (S = 0; S < L.length; S++) {
                        D = L[S];
                        switch (D.type) {
                        case "00-taskAvailailabilityStart":
                            H = true;
                            break;
                        case "01-taskAvailailabilityEnd":
                            H = false;
                            break;
                        case "02-resourceAvailailabilityStart":
                            T = D.resources;
                            for (P = 0, O = T.length; P < O; P++) {
                                Q[T[P].resourceId] = T[P];
                                F++
                            }
                            break;
                        case "03-resourceAvailailabilityEnd":
                            T = D.resources;
                            for (P = 0, O = T.length; P < O; P++) {
                                delete Q[T[P].resourceId];
                                F--
                            }
                            break;
                        case "04-taskSegmentStart":
                            u = true;
                            break;
                        case "05-taskSegmentEnd":
                            u = false;
                            break
                        }
                    }
                    if ((H || !E) && (!g || u) && (!X || F || C)) {
                        V = f[U];
                        B = f[U + 1];
                        if (V >= v || B <= d) {
                            continue
                        }
                        if (V < d) {
                            V = d - 0
                        }
                        if (B > v) {
                            B = v - 0
                        }
                        if (t.call(K, V, B, Q) === false) {
                            return false
                        }
                    }
                }
            } else {
                for (U = f.length - 1; U >= 0; U--) {
                    L = z[f[U]];
                    L.sort(function(k, i) {
                        return k.typeBackward < i.typeBackward ? 1 : -1
                    });
                    for (S = 0; S < L.length; S++) {
                        D = L[S];
                        switch (D.typeBackward) {
                        case "00-taskAvailailabilityEnd":
                            H = true;
                            break;
                        case "01-taskAvailailabilityStart":
                            H = false;
                            break;
                        case "02-resourceAvailailabilityEnd":
                            T = D.resources;
                            for (P = 0, O = T.length; P < O; P++) {
                                Q[T[P].resourceId] = T[P];
                                F++
                            }
                            break;
                        case "03-resourceAvailailabilityStart":
                            T = D.resources;
                            for (P = 0, O = T.length; P < O; P++) {
                                delete Q[T[P].resourceId];
                                F--
                            }
                            break;
                        case "04-taskSegmentEnd":
                            u = true;
                            break;
                        case "05-taskSegmentStart":
                            u = false;
                            break
                        }
                    }
                    if ((H || !E) && (!g || u) && (!X || F || C)) {
                        V = f[U - 1];
                        B = f[U];
                        if (V > v || B <= d) {
                            continue
                        }
                        if (V < d) {
                            V = d - 0
                        }
                        if (B > v) {
                            B = v - 0
                        }
                        if (t.call(K, V, B, Q) === false) {
                            return false
                        }
                    }
                }
            }
            x = s ? h.getStartOfNextDay(x) : h.getEndOfPreviousDay(x)
        }
    },
    forEachAvailabilityIntervalWithResources: function(a, c, b) {
        if (!a.resources) {
            a.resources = true
        }
        this.forEachAvailabilityInterval.apply(this, arguments)
    },
    calculateEffortDrivenEndDate: function(a, c, b) {
        var e = this.getUnitConverter().convertDurationToMs(c, b || this.getEffortUnit());
        var d = new Date(a);
        this.forEachAvailabilityIntervalWithResources({
            startDate: a
        },
        function(l, k, j) {
            var m = 0;
            for (var h in j) {
                m += j[h].units
            }
            var g = k - l;
            var f = m * g / 100;
            if (f >= e) {
                d = new Date(l + e / f * g);
                return false
            } else {
                e -= f
            }
        });
        return d
    },
    refreshCalculatedParentNodeData: function() {
        var v = this.autoCalculatePercentDoneForParentTask;
        var j = this.autoCalculateEffortForParentTask;
        var a = this.childNodes;
        var d = a.length;
        var f = {};
        if (d > 0 && (j || v)) {
            var h = 0;
            var p = 0;
            var s = 0;
            for (var t = 0; t < d; t++) {
                var b = a[t];
                var w = b.isLeaf();
                if (j) {
                    h += b.getEffort("MILLI")
                }
                if (v) {
                    var c = w ? b.getDuration("MILLI") || 0 : b.childTasksDuration;
                    p += c;
                    s += w ? c * (b.getPercentDone() || 0) : b.completedChildTasksDuration
                }
            }
            if (j && this.getEffort("MILLI") != h) {
                f.Effort = true;
                this.setEffortWithoutPropagation(this.getUnitConverter().convertMSDurationToUnit(h, this.getEffortUnit()))
            }
            if (v) {
                this.childTasksDuration = p;
                this.completedChildTasksDuration = s;
                var q = p ? s / p: 0;
                if (this.getPercentDone() != q) {
                    f.PercentDone = true;
                    this.setPercentDone(q)
                }
            }
        }
        var e, n;
        if (!this.isRoot() && d > 0 && !this.isManuallyScheduled()) {
            var g = new Date( - 8640000000000000),
            l = new Date( + 8640000000000000),
            m = new Date( + 8640000000000000),
            y = new Date( - 8640000000000000);
            for (var u = 0; u < d; u++) {
                var o = a[u];
                m = Sch.util.Date.min(m, o.getStartDate() || m);
                y = Sch.util.Date.max(y, o.getEndDate() || y)
            }
            if (y < m && m < l && y > g) {
                var x;
                x = y;
                y = m;
                m = x
            }
            e = f.StartDate = m - l !== 0 && this.getStartDate() - m !== 0;
            n = f.EndDate = y - g !== 0 && this.getEndDate() - y !== 0;
            if (e && n) {
                this.setStartEndDateWithoutPropagation(m, y, false)
            } else {
                if (e) {
                    this.setStartDateWithoutPropagation(m, false, false)
                } else {
                    if (n) {
                        this.setEndDateWithoutPropagation(y, false, false)
                    }
                }
            }
        }
        return f
    },
    recalculateParents: function() {
        var a = this.parentNode;
        a && (a.refreshCalculatedParentNodeData(), !this.getTaskStore().cascading && a.recalculateParents())
    },
    recalculateAllParents: function() {
        var c = this.parentNode,
        b = false,
        d;
        if (c) {
            d = c.refreshCalculatedParentNodeData();
            for (var a in d) {
                if (d[a]) {
                    b = true;
                    break
                }
            }
            b && c.recalculateAllParents()
        }
    },
    isMilestone: function(a) {
        return a ? this.isBaselineMilestone() : this.getDuration() === 0
    },
    convertToMilestone: function(b) {
        var a = this;
        a.propagateChanges(function() {
            return a.convertToMilestoneWithoutPropagation()
        },
        b)
    },
    convertToMilestoneWithoutPropagation: function() {
        var b = this,
        a = false;
        if (!b.isMilestone()) {
            b.setStartDateWithoutPropagation(b.getEndDate(), false);
            b.setDurationWithoutPropagation(0);
            a = true
        }
        return a
    },
    convertToRegular: function(b) {
        var a = this;
        a.propagateChanges(function() {
            return a.convertToRegularWithoutPropagation()
        },
        b)
    },
    convertToRegularWithoutPropagation: function() {
        var d = this,
        b = false,
        c, a;
        if (d.isMilestone()) {
            c = d.get(d.durationUnitField);
            a = d.calculateStartDate(d.getStartDate(), 1, c);
            d.setDurationWithoutPropagation(1, c);
            d.setStartDateWithoutPropagation(a, true, false, false);
            b = true
        }
        return b
    },
    isBaselineMilestone: function() {
        var b = this.getBaselineStartDate(),
        a = this.getBaselineEndDate();
        if (b && a) {
            return a - b === 0
        }
        return false
    },
    markAsParent: function() {
        var a = this;
        a.isSegmented() && a.setSegmentsWithoutPropagation(null);
        a.set("leaf", false)
    },
    getDurationUnit: function() {
        return this.get(this.durationUnitField) || "d"
    },
    getEffortUnit: function() {
        return this.get(this.effortUnitField) || "h"
    },
    getBaselinePercentDone: function() {
        return this.get(this.baselinePercentDoneField) || 0
    },
    isPersistable: function() {
        var a = this.parentNode;
        return ! a.phantom
    },
    getResources: function() {
        var a = [];
        Ext.each(this.assignments,
        function(b) {
            a.push(b.getResource())
        });
        return a
    },
    getAssignments: function() {
        return this.assignments
    },
    hasAssignments: function() {
        return this.assignments.length > 0
    },
    hasResources: function() {
        var a = false;
        Ext.each(this.assignments,
        function(b) {
            if (b.getResource()) {
                a = true;
                return false
            }
        });
        return a
    },
    getAssignmentFor: function(b) {
        var a = null,
        c = b instanceof Gnt.model.Resource ? b.getInternalId() : b;
        Ext.each(this.assignments,
        function(d) {
            if (d.getResourceId() == c) {
                a = d;
                return false
            }
        });
        return a
    },
    isAssignedTo: function(a) {
        return !! this.getAssignmentFor(a)
    },
    assign: function(e, b, g) {
        var d = this,
        a, c;
        d.propagateChanges(function() {
            return d.assignWithoutPropagation(e, b,
            function h(j, i) {
                c = j;
                a = i
            })
        },
        function f(i, h) {
            i && c && c();
            g && g(i, h)
        });
        return a
    },
    assignWithoutPropagation: function(c, g, f) {
        var i = this,
        h = i.getInternalId(),
        l = [],
        j = i.getTaskStore(),
        e = j.getAssignmentStore(),
        k = j.getResourceStore(),
        a = i.assignments,
        b,
        d;
        g = g || 100;
        b = i.getAssignmentFor(c); ! b || Ext.Error.raise("Resource can't be assigned twice to the same task");
        if (c instanceof Gnt.model.Resource && k.indexOf(c) == -1) {
            d = c.getInternalId();
            k.add(c);
            l.push(function() {
                k.remove(c)
            })
        } else {
            if (c instanceof Gnt.model.Resource) {
                d = c.getInternalId()
            } else {
                if (k.indexOfId(c) >= 0) {
                    d = c
                } else {
                    Ext.Error.raise("Can't assign resource to a task, task's resource store doesn't contain resource id given")
                }
            }
        }
        b = new e.model();
        b.setTaskId(h);
        b.setResourceId(d);
        b.setUnits(g);
        e.add(b);
        l.push(function() {
            e.remove(b)
        });
        if (!i.getTreeStore() && !Ext.Array.contains(a, b)) {
            a.push(b);
            l.push(function() {
                Ext.Array.remove(a, b)
            })
        }
        f && f(function() {
            Ext.Array.forEach(l,
            function(m) {
                m()
            })
        },
        b);
        return true
    },
    unAssign: function(c, e) {
        var b = this,
        a;
        b.propagateChanges(function() {
            return b.unassignWithoutPropagation(c,
            function f(g) {
                a = g
            })
        },
        function d(g, f) {
            g && a && a();
            e && e(g, f)
        })
    },
    unassignWithoutPropagation: function(e, c) {
        var i = this,
        h = i.getInternalId(),
        f = e instanceof Gnt.model.Resource ? e.getInternalId() : e,
        g = i.getAssignmentStore(),
        b = i.assignments,
        d = i.getAssignmentFor(f),
        a;
        a = g.indexOf(d);
        g.remove(d);
        Ext.Array.remove(b, d);
        c && c(function() {
            g.insert(a, d);
            Ext.Array.insert(b, a, [d])
        });
        return true
    },
    unassign: function() {
        return this.unAssign.apply(this, arguments)
    },
    linkTo: function(a, c, g, e) {
        var d = this,
        b;
        d.propagateChanges(function() {
            return d.linkToWithoutPropagation(a, c,
            function h(i) {
                b = i
            },
            e)
        },
        function f(i, h) {
            i && b && b();
            g && g(i, h)
        })
    },
    linkToWithoutPropagation: function(c, h, a, f) {
        var g = this,
        e = g.getInternalId(),
        i = g.getTaskStore(),
        b = g.getDependencyStore(),
        d;
        c = c instanceof Gnt.model.Task ? c.getInternalId() : c;
        h = ((h === null || h === undefined) && Gnt.model.Dependency.Type.EndToStart) || h;
        d = new b.model();
        d.setSourceId(e);
        d.setTargetId(c);
        d.setType(h);
        if (b.isValidDependency(d) && (!f || f(d) !== false)) {
            b.add(d)
        }
        a && a(function() {
            b.remove(d)
        });
        return g
    },
    unlinkFrom: function(a, e) {
        var c = this,
        b;
        c.propagateChanges(function() {
            return c.unlinkFromWithoutPropagation(a,
            function f(g) {
                b = g
            })
        },
        function d(g, f) {
            g && b && b();
            e && e(g, f)
        })
    },
    unlinkFromWithoutPropagation: function(d, e) {
        var g = this,
        a = g.getInternalId(),
        c = g.getDependencyStore(),
        b,
        f;
        d = d instanceof Gnt.model.Task ? d.getInternalId() : d;
        b = c.getByTaskIds(d, a);
        f = c.indexOf(b);
        c.remove(b);
        e && e(function() {
            c.insert(f, b)
        });
        return g
    },
    calculateEffort: function(a, c, b) {
        if (!a || !c) {
            return 0
        }
        var d = 0;
        this.forEachAvailabilityIntervalWithResources({
            startDate: a,
            endDate: c
        },
        function(h, g, f) {
            var j = 0;
            for (var e in f) {
                j += f[e].units
            }
            d += (g - h) * j / 100
        });
        return this.getUnitConverter().convertMSDurationToUnit(d, b || this.getEffortUnit())
    },
    updateAssignments: function() {
        var b = {};
        var a = this.getStartDate();
        var d = this.getEndDate();
        if (!a || !d) {
            return
        }
        var c = 0;
        this.forEachAvailabilityIntervalWithResources({
            startDate: a,
            endDate: d
        },
        function(h, g, f) {
            for (var i in f) {
                c += g - h
            }
        });
        if (!c) {
            return
        }
        var e = this.getEffort(Sch.util.Date.MILLI);
        Ext.Array.each(this.getAssignments(),
        function(f) {
            f.setUnits(e / c * 100)
        })
    },
    updateEffortBasedOnDuration: function() {
        this.setEffortWithoutPropagation(this.calculateEffort(this.getStartDate(), this.getEndDate()))
    },
    updateEffortBasedOnSpan: function() {
        this.updateEffortBasedOnDuration()
    },
    updateSpanBasedOnEffort: function() {
        this.setStartEndDateWithoutPropagation(this.getStartDate(), this.recalculateEndDate())
    },
    onPotentialEffortChange: function() {
        switch (this.getSchedulingMode()) {
        case "FixedDuration":
            this.updateEffortBasedOnDuration();
            break;
        case "DynamicAssignment":
            this.updateAssignments();
            break
        }
    },
    onAssignmentMutation: function() {
        switch (this.getSchedulingMode()) {
        case "FixedDuration":
            this.updateEffortBasedOnDuration();
            break;
        case "EffortDriven":
            this.updateSpanBasedOnEffort();
            break;
        case "DynamicAssignment":
            this.updateAssignments();
            break
        }
    },
    onAssignmentStructureMutation: function() {
        switch (this.getSchedulingMode()) {
        case "FixedDuration":
            this.updateEffortBasedOnDuration();
            break;
        case "EffortDriven":
            this.updateSpanBasedOnEffort();
            break;
        case "DynamicAssignment":
            this.updateAssignments();
            break
        }
    },
    adjustToCalendar: function(b) {
        var a = this;
        a.propagateChanges(function() {
            return a.adjustToCalendarWithoutPropagation()
        },
        b)
    },
    adjustToCalendarWithoutPropagation: function() {
        var b = this.getTaskStore(true),
        a = false;
        if (this.get("leaf") && !this.isManuallyScheduled() && b) {
            this.setStartDateWithoutPropagation(this.getStartDate(), true, b.skipWeekendsDuringDragDrop);
            this.constrainWithoutPropagation(b, null);
            a = this
        }
        return a
    },
    isEditable: function(a) {
        if (!this.isLeaf()) {
            if (a === this.effortField && this.autoCalculateEffortForParentTask) {
                return false
            }
            if (a === this.percentDoneField && this.autoCalculatePercentDoneForParentTask) {
                return false
            }
        }
        if ((a === this.durationField || a === this.endDateField) && this.getSchedulingMode() === "EffortDriven") {
            return false
        }
        if (a === this.effortField && this.getSchedulingMode() === "FixedDuration") {
            return false
        }
        return true
    },
    isDraggable: function() {
        return this.getDraggable()
    },
    isResizable: function() {
        return this.getResizable()
    },
    getWBSCode: function() {
        var b = [],
        a = this;
        while (a.parentNode) {
            b.push(a.data.index + 1);
            a = a.parentNode
        }
        return b.reverse().join(".")
    },
    resetTotalCount: function(b) {
        var a = this;
        while (a) {
            a.totalCount = b ? -1 : null;
            a = a.parentNode
        }
    },
    getTotalCount: function() {
        var b = this.totalCount;
        var c = b == -1;
        if (b == null || c) {
            var e = this.childNodes;
            b = e.length;
            for (var d = 0,
            a = e.length; d < a; d++) {
                b += e[d].getTotalCount()
            }
            if (c) {
                return b
            } else {
                this.totalCount = b
            }
        }
        return b
    },
    getPredecessorsCount: function() {
        var a = this.previousSibling,
        b = this.data.index;
        while (a) {
            b += a.getTotalCount();
            a = a.previousSibling
        }
        return b
    },
    getSequenceNumber: function() {
        var b = 0,
        a = this;
        while (a.parentNode) {
            b += a.getPredecessorsCount() + 1;
            a = a.parentNode
        }
        return b
    },
    getBySequenceNumber: function(f) {
        var c = null,
        e, b;
        if (f === 0) {
            c = this
        } else {
            if (f > 0 && f <= this.getTotalCount()) {
                f--;
                for (var d = 0,
                a = this.childNodes.length; d < a; d++) {
                    e = this.childNodes[d];
                    b = e.getTotalCount();
                    if (f > b) {
                        f -= b + 1
                    } else {
                        e = this.childNodes[d];
                        c = e.getBySequenceNumber(f);
                        break
                    }
                }
            }
        }
        return c
    },
    getDisplayStartDate: function(e, c, d, a, b) {
        e = e || Ext.Date.defaultFormat;
        if (arguments.length < 3) {
            d = this.getStartDate();
            if (arguments.length < 2) {
                c = true
            }
        }
        if (d && c && this.isMilestone(b) && d - Ext.Date.clearTime(d, true) === 0 && !Ext.Date.formatContainsHourInfo(e)) {
            d = Sch.util.Date.add(d, Sch.util.Date.MILLI, -1)
        }
        return a ? d: (d ? Ext.util.Format.date(d, e) : "")
    },
    getDisplayEndDate: function(e, c, d, a, b) {
        e = e || Ext.Date.defaultFormat;
        if (arguments.length < 3) {
            d = this.getEndDate();
            if (arguments.length < 2) {
                c = true
            }
        }
        if (d && (!this.isMilestone(b) || c) && d - Ext.Date.clearTime(d, true) === 0 && !Ext.Date.formatContainsHourInfo(e)) {
            d = Sch.util.Date.add(d, Sch.util.Date.MILLI, -1)
        }
        return a ? d: (d ? Ext.util.Format.date(d, e) : "")
    },
    fullCopy: function(a) {
        var b = this.callParent(arguments);
        b.taskStore = this.getTaskStore();
        return b
    },
    commit: function() {
        this.callParent(arguments);
        this.commitSegments()
    },
    reject: function() {
        this.callParent(arguments);
        this.rejectSegments()
    },
    isUnscheduled: function() {
        return ! this.getStartDate() || !this.getEndDate()
    }
},
function() {
    Ext.data.NodeInterface.decorate(this);
    this.override({
        remove: function() {
            var d = this,
            c = d.parentNode,
            b = d.getTaskStore(true),
            a;
            a = d.callParent(arguments);
            if (c && b && b.recalculateParents && c.convertEmptyParentToLeaf && !c.isRoot() && c.childNodes.length === 0) {
                c.set("leaf", true)
            } else {
                if (c && b && b.recalculateParents && !b.suspendAutoRecalculateParents && !c.isRoot() && c.childNodes.length > 0) {
                    c.refreshCalculatedParentNodeData();
                    c.recalculateParents()
                }
            }
            return a
        },
        insertBefore: function(c) {
            c = this.createNode(c);
            if (this.phantom) {
                this.data[this.phantomIdField] = c.data[this.phantomParentIdField] = this.getInternalId()
            }
            var b = c.parentNode;
            this.resetTotalCount(b);
            var a = this.callParent(arguments);
            if (b) {
                this.resetTotalCount()
            }
            return a
        },
        appendChild: function(a, e, f) {
            var d = false;
            a = a instanceof Array ? a: [a];
            for (var c = 0; c < a.length; c++) {
                a[c] = this.createNode(a[c]);
                if (a[c].parentNode) {
                    d = true
                }
                if (this.phantom) {
                    a[c].data[this.phantomParentIdField] = this.getInternalId()
                }
            }
            if (this.phantom) {
                this.data[this.phantomIdField] = this.getInternalId()
            }
            this.resetTotalCount(d);
            var b = this.callParent([a.length > 1 ? a: a[0], e, f]);
            if (d) {
                this.resetTotalCount()
            }
            this.beginEdit();
            this.set("leaf", false);
            this.set(this.schedulingModeField, "Normal");
            this.endEdit();
            return b
        },
        removeChild: function(h, e, f, b) {
            var g = this,
            d = !g.removeChildIsCalledFromReplaceChild && g.convertEmptyParentToLeaf && g.childNodes.length == 1,
            c = g.getTaskStore(true),
            a;
            g.resetTotalCount();
            g.removeChildIsCalledFromReplaceChild = false;
            a = g.callParent(arguments);
            if (b) {
                g.resetTotalCount()
            }
            if (c && c.recalculateParents && !c.suspendAutoRecalculateParents) {
                g.refreshCalculatedParentNodeData()
            }
            d && !g.isRoot() && g.set("leaf", true);
            return a
        },
        replaceChild: function() {
            this.removeChildIsCalledFromReplaceChild = true;
            this.callParent(arguments)
        },
        removeAll: function() {
            this.resetTotalCount();
            this.callParent(arguments)
        },
        createNode: function(d) {
            var b = this.getTaskStore(true),
            a = b && b.autoNormalizeNodes && !d.normalized && !d.normalizeScheduled;
            d = this.callParent(arguments);
            if (a) {
                var c = d.updateInfo;
                d.updateInfo = function() {
                    c.apply(this, arguments);
                    delete d.updateInfo;
                    d.normalize()
                };
                d.normalizeScheduled = true
            }
            return d
        }
    })
});
Ext.define("Gnt.model.TaskSegment", {
    extend: "Gnt.model.Task",
    task: null,
    prevSegment: null,
    nextSegment: null,
    customizableFields: [{
        name: "StartOffset",
        type: "int"
    },
    {
        name: "EndOffset",
        type: "int"
    }],
    startOffsetField: "StartOffset",
    endOffsetField: "EndOffset",
    taskNotifyingSuspended: 0,
    respectNeighbours: 0,
    constructor: function(a) {
        a = a || {};
        a.leaf = true;
        if (!a.task) {
            throw "'task' has to be specified"
        }
        this.task = a.task;
        this.setPrevSegment(a.prevSegment);
        this.callParent(arguments);
        Ext.override(this, this.overridables);
        if (this.getTask().normalized && this.getTaskStore(true) && !this.normalized) {
            this.normalize()
        }
    },
    overridables: {
        set: function() {
            var a = this.getTask();
            if (!this.editing && a) {
                a.onSegmentEditBegin(this)
            }
            this.callParent(arguments)
        }
    },
    serialize: function() {
        var a = {};
        if (this.getId()) {
            a[this.idProperty] = this.getId()
        }
        a[this.phantomIdField] = this.getPhantomId();
        a[this.startDateField] = this.getStartDate();
        a[this.endDateField] = this.getEndDate();
        a[this.durationField] = this.getDuration();
        a[this.durationUnitField] = this.getDurationUnit();
        a[this.clsField] = this.getCls();
        return a
    },
    setStartOffset: function(a) {
        var c = this.getTask().getProjectCalendar();
        var b = c.convertMSDurationToUnit(this.getEndOffset() - a, this.getDurationUnit());
        this.beginEdit();
        this.set(this.startOffsetField, a);
        this.set(this.durationField, b);
        this.endEdit()
    },
    setEndOffset: function(b) {
        var c = this.getTask().getProjectCalendar();
        var a = c.convertMSDurationToUnit(b - this.getStartOffset(), this.getDurationUnit());
        this.beginEdit();
        this.set(this.endOffsetField, b);
        this.set(this.durationField, a);
        this.endEdit()
    },
    setStartEndOffset: function(a, c) {
        var d = this.getTask().getProjectCalendar();
        var b = d.convertMSDurationToUnit(c - a, this.getDurationUnit());
        this.beginEdit();
        this.set(this.startOffsetField, a);
        this.set(this.endOffsetField, c);
        this.set(this.durationField, b);
        this.endEdit()
    },
    normalize: function() {
        this.callParent(arguments);
        var b = this.getStartDate();
        if (!this.getStartOffset() && b) {
            var c = this.getTask();
            var a = this.calculateDuration(c.getStartDate(), b, "MILLI");
            var d = a + this.getDuration("MILLI");
            var f = c.getProjectCalendar();
            var e = f.convertMSDurationToUnit(d - a, this.getDurationUnit());
            this.data[this.startOffsetField] = a;
            this.data[this.endOffsetField] = d;
            this.data[this.durationField] = e
        }
    },
    updateOffsetsByDates: function() {
        if (!this.getTaskStore(true)) {
            return
        }
        if (this.updatingOffsets || this.updatingDates) {
            return
        }
        this.updatingOffsets = true;
        var a = this.calculateDuration(this.getTask().getStartDate(), this.getStartDate(), "MILLI");
        this.setStartEndOffset(a, a + this.getDuration("MILLI"));
        this.updatingOffsets = false
    },
    updateDatesByOffsets: function(f) {
        f = f || {};
        if (this.updatingDates || this.updatingOffsets) {
            return
        }
        var g = f.isForward !== false,
        e = f.useAbsoluteOffset !== false,
        b = f.startDate,
        h = f.endDate,
        d = this.getTaskStore(true);
        if (!d) {
            return
        }
        this.updatingDates = true;
        var c, a;
        if (g) {
            a = this.getPrevSegment();
            if (a && !e) {
                c = this.skipWorkingTime(a.getEndDate(), this.getStartOffset() - a.getEndOffset())
            } else {
                c = this.skipWorkingTime(b || this.getTask().getStartDate(), this.getStartOffset())
            }
        } else {
            a = this.getNextSegment();
            if (a && !e) {
                c = this.skipWorkingTime(a.getStartDate(), a.getStartOffset() - this.getEndOffset() + this.getDuration("MILLI"), false)
            } else {
                c = this.skipWorkingTime(h || this.getTask().getEndDate(), this.getDuration("MILLI"), false)
            }
        }
        this.setStartDateWithoutPropagation(c, true, d.skipWeekendsDuringDragDrop);
        this.updatingDates = false
    },
    getPrevSegment: function() {
        return this.prevSegment
    },
    getNextSegment: function() {
        return this.nextSegment
    },
    setPrevSegment: function(a) {
        this.prevSegment = a;
        if (a) {
            a.nextSegment = this
        }
    },
    setNextSegment: function(a) {
        this.nextSegment = a;
        if (a) {
            a.prevSegment = this
        }
    },
    buildSnapshot: function() {
        return [this, Ext.apply({},
        this.data), {
            prevSegment: this.getPrevSegment(),
            nextSegment: this.getNextSegment()
        }]
    },
    readSnapshot: function(a) {
        if (a) {
            Ext.apply(this.data, a[1]);
            Ext.apply(this, a[2]);
            return this
        }
        return a
    },
    enableRespectNeighbours: function() {
        this.respectNeighbours++
    },
    disableRespectNeighbours: function() {
        this.respectNeighbours--
    },
    suspendTaskNotifying: function() {
        this.taskNotifyingSuspended++
    },
    resumeTaskNotifying: function() {
        this.taskNotifyingSuspended--
    },
    setStartDate: function(a, b) {
        if (b) {
            this.enableRespectNeighbours()
        }
        this.callParent(arguments);
        if (b) {
            this.disableRespectNeighbours()
        }
    },
    setStartDateWithoutPropagation: function() {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        if (!this.inShifting && this.respectNeighbours && this.getNextSegment()) {
            var a = this.getNextSegment();
            var b = this.getEndOffset() - a.getStartOffset();
            if (a && (b > 0)) {
                a.suspendTaskNotifying();
                a.enableRespectNeighbours();
                a.shiftWithoutPropagation(b);
                a.resumeTaskNotifying();
                a.disableRespectNeighbours()
            }
        }
        this.endEdit();
        return true
    },
    shiftWithoutPropagation: function(c) {
        var b = this;
        if (!c) {
            return
        }
        b.beginEdit();
        b.inShifting = true;
        b.setStartEndOffset(b.getStartOffset() + c, b.getEndOffset() + c);
        b.updateDatesByOffsets();
        var a;
        if (b.respectNeighbours && (a = c > 0 ? b.getNextSegment() : b.getPrevSegment())) {
            a.suspendTaskNotifying();
            a.enableRespectNeighbours();
            a.shiftWithoutPropagation(c);
            a.resumeTaskNotifying();
            a.disableRespectNeighbours()
        }
        b.inShifting = false;
        b.endEdit();
        return true
    },
    setEndDateWithoutPropagation: function() {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        this.endEdit();
        return true
    },
    setStartEndDateWithoutPropagation: function() {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        this.endEdit();
        return true
    },
    setDurationWithoutPropagation: function() {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        this.endEdit();
        return true
    },
    getTask: function() {
        return this.task
    },
    beginEdit: function() {
        var a = this.getTask();
        if (a && !this.__editCounter) {
            a.onSegmentEditBegin(this)
        }
        this.callParent(arguments)
    },
    endEdit: function() {
        var a = this.previous;
        this.callParent(arguments);
        if (!this.__editCounter && !this.taskNotifyingSuspended) {
            if (this.startDateField in a || this.endDateField in a || this.startOffsetField in a || this.endOffsetField in a || this.durationField in a) {
                this.getTask().onSegmentsChanged(this, a)
            }
        }
    },
    setSegments: Ext.emptyFn,
    getSegments: Ext.emptyFn,
    callTask: function(b) {
        var a = this.task;
        var d = this.callTask.caller;
        var c = d && a[d.$name];
        if (c) {
            return c.apply(a, b)
        }
    },
    getSchedulingMode: function() {
        return this.callTask(arguments)
    },
    getCalendar: function() {
        return this.callTask(arguments)
    },
    getOwnCalendar: function() {
        return this.callTask(arguments)
    },
    getProjectCalendar: function() {
        return this.callTask(arguments)
    },
    getDependencyStore: function() {
        return this.callTask(arguments)
    },
    getResourceStore: function() {
        return this.callTask(arguments)
    },
    getAssignmentStore: function() {
        return this.callTask(arguments)
    },
    getTaskStore: function() {
        return this.callTask(arguments)
    },
    forEachAvailabilityInterval: function(a) {
        a.segments = a.segments || false;
        return this.callTask(arguments)
    },
    propagateChanges: function() {
        return this.callTask(arguments)
    },
    rejectSegmentsProjection: function() {
        return this.callTask(arguments)
    },
    commitSegmentsProjection: function() {
        return this.callTask(arguments)
    }
});
Ext.define("Gnt.util.DurationParser", {
    requires: ["Sch.util.Date"],
    mixins: ["Gnt.mixin.Localizable"],
    parseNumberFn: null,
    durationRegex: null,
    allowDecimals: true,
    constructor: function(a) {
        Ext.apply(this, a);
        if (this.unitsRegex) {
            Ext.apply(this.l10n.unitsRegex, this.unitsRegex)
        }
        if (!this.durationRegex) {
            this.durationRegex = this.allowDecimals ? /^\s*([\-+]?\d+(?:[.,]\d+)?)\s*(\w+)?/i: /^\s*([\-+]?\d+)(?![.,])\s*(\w+)?/i
        }
    },
    parse: function(c) {
        var a = this.durationRegex.exec(c);
        if (c == null || !a) {
            return null
        }
        var e = this.parseNumberFn(a[1]);
        var b = a[2];
        var d;
        if (b) {
            Ext.iterate(this.L("unitsRegex"),
            function(f, g) {
                if (g.test(b)) {
                    d = Sch.util.Date.getUnitByName(f);
                    return false
                }
            });
            if (!d) {
                return null
            }
        }
        return {
            value: e,
            unit: d
        }
    }
});
Ext.define("Gnt.util.DependencyParser", {
    requires: ["Gnt.util.DurationParser"],
    mixins: ["Gnt.mixin.Localizable"],
    separator: /\s*;\s*/,
    parseNumberFn: null,
    dependencyRegex: null,
    types: null,
    constructor: function(a) {
        Ext.apply(this, a);
        this.initTypes();
        var d = this.L("typeText");
        for (var b = 0; b < this.types.length; b++) {
            this.types[b] = (d[this.types[b]] || this.types[b])
        }
        var c = "(-?\\d+)(" + this.types.join("|") + ")?([\\+\\-].*)?";
        this.dependencyRegex = this.dependencyRegex || new RegExp(c, "i");
        this.durationParser = new Gnt.util.DurationParser({
            parseNumberFn: this.parseNumberFn
        })
    },
    initTypes: function() {
        this.types = this.types || ["SS", "SF", "FS", "FF"]
    },
    parse: function(j) {
        if (!j) {
            return []
        }
        var d = j.split(this.separator);
        var k = [];
        var c = this.dependencyRegex;
        for (var f = 0; f < d.length; f++) {
            var a = d[f];
            if (!a && f == d.length - 1) {
                continue
            }
            var g = c.exec(a);
            var e = {};
            if (!g) {
                return null
            }
            e.taskId = parseInt(g[1], 10);
            e.type = Ext.Array.indexOf(this.types, (g[2] || this.types[2]).toUpperCase());
            var h = g[3];
            if (h) {
                var b = this.durationParser.parse(h);
                if (!b) {
                    return null
                }
                e.lag = b.value;
                e.lagUnit = b.unit || "d"
            }
            k.push(e)
        }
        return k
    }
});
Ext.define("Gnt.util.Data", {
    requires: ["Ext.data.Model"],
    singleton: true,
    cloneModelSet: function(b, d, c) {
        var e = [],
        a;
        var f = function(g) {
            a = g.copy();
            a.phantom = false;
            a.originalRecord = g;
            if (d) {
                if (d.call(c || b, a, g) === false) {
                    return
                }
            }
            e.push(a)
        };
        if (b.each) {
            b.each(f)
        } else {
            Ext.Array.each(b, f)
        }
        return e
    },
    applyCloneChanges: function(g, m, j, p) {
        var a = [];
        var c = m.autoSyncSuspended;
        if (m.autoSync && !c) {
            m.suspendAutoSync()
        }
        var f = g.getRemovedRecords();
        for (var e = 0,
        b = f.length; e < b; e++) {
            if (f[e].originalRecord) {
                a.push(f[e].originalRecord)
            }
        }
        if (a.length) {
            m.remove(a);
            g.removed.length = 0
        }
        var n = g.getModifiedRecords(),
        q,
        d,
        o,
        h;
        for (e = 0, b = n.length; e < b; e++) {
            q = n[e].originalRecord;
            d = n[e].getData();
            delete d[n[e].idProperty];
            if (q) {
                q.beginEdit();
                for (var k in d) {
                    q.set(k, d[k])
                }
                if (j) {
                    j.call(p || n[e], d, n[e])
                }
                q.endEdit()
            } else {
                if (j) {
                    j.call(p || n[e], d, n[e])
                }
                h = m.add(d);
                n[e].originalRecord = h && h[0]
            }
            n[e].commit(true)
        }
        if (m.autoSync && !c) {
            m.resumeAutoSync();
            m.sync()
        }
    }
});
Ext.define("Gnt.data.linearizator.CycleResolvers",
function(i) {
    function g() {
        return false
    }
    function j() {
        Ext.Error.raise("Can't linearize dependent tasks, there's a cycle in the dependency chain!")
    }
    function a(m, o) {
        var q = d(m, o),
        l = {},
        p = function(t, s) {
            var r = l[t] || (l[t] = {});
            r[s] = s
        };
        f(q,
        function n(r) {
            if (r.prevSibling) {
                e(r.prevSibling.foldedDeps, r.foldedDeps, p);
                r.foldedDeps = Ext.apply(r.foldedDeps, r.prevSibling.foldedDeps)
            }
            if (!r.nextSibling && r.parentNode) {
                e(r.parentNode.foldedDeps, r.foldedDeps, p);
                r.parentNode.foldedDepds = Ext.apply(r.parentNode.foldedDeps, r.foldedDeps)
            }
        });
        c(o.fromById, l);
        return true
    }
    function d(l, r) {
        var n, m = [],
        p = {},
        o,
        q;
        for (o in l) {
            if (l.hasOwnProperty(o)) {
                q = p[o] = h(l[o].task, l, r);
                if (!l.hasOwnProperty(q.parentNode)) {
                    m.push(q)
                }
            }
        }
        for (o in p) {
            if (p.hasOwnProperty(o)) {
                p[o] = k(p[o], p)
            }
        }
        if (m.length == 1) {
            n = m[0]
        } else {
            n = {
                parentNode: null,
                prevSibling: null,
                nextSibling: null,
                children: m,
                foldedDeps: {}
            }
        }
        return n
    }
    function h(x, n, y) {
        var p = y.fromById,
        o = {},
        v = x.internalId,
        s, q, w, m, u, l, r, t;
        o[v] = Ext.clone(p[v] || {});
        s = x.parentNode && n.hasOwnProperty(x.parentNode.internalId) && x.parentNode.internalId;
        m = x.childNodes || [];
        l = [];
        for (r = 0, t = m.length; r < t; r++) {
            u = m[r].internalId;
            if (n.hasOwnProperty(u)) {
                l.push(u)
            }
        }
        w = x.previousSibling;
        while (w && !n.hasOwnProperty(w.internalId)) {
            w = w.previousSibling
        }
        w = w && w.internalId;
        q = x.nextSibling;
        while (q && !n.hasOwnProperty(q.internalId)) {
            q = q.nextSibling
        }
        q = q && q.internalId;
        return {
            parentNode: s,
            prevSibling: w,
            nextSibling: q,
            children: l,
            foldedDeps: o
        }
    }
    function k(p, m) {
        var o, l, n = p.children;
        for (o = 0, l = n.length; o < l; o++) {
            n[o] = m[n[o]]
        }
        p.parentNode = (p.parentNode || p.parentNode === 0) && m[p.parentNode] || null;
        p.prevSibling = (p.prevSibling || p.prevSibling === 0) && m[p.prevSibling] || null;
        p.nextSibling = (p.nextSibling || p.nextSibling === 0) && m[p.nextSibling] || null;
        return p
    }
    function f(p, o) {
        var n = p.children,
        m, l;
        for (m = 0, l = n.length; m < l; m++) {
            f(n[m], o)
        }
        o(p);
        return p
    }
    function e(r, w, p) {
        var x, s, n, l, u, o, v, t, q, m;
        x = Ext.Object.getKeys(r);
        n = Ext.Object.getKeys(w);
        s = Ext.Array.flatten(Ext.Array.map(x,
        function(y) {
            return Ext.Object.getKeys(r[y])
        }));
        l = Ext.Array.flatten(Ext.Array.map(n,
        function(y) {
            return Ext.Object.getKeys(w[y])
        }));
        u = Ext.Array.intersect(s, n);
        v = Ext.Array.intersect(l, x);
        if (u.length > 0 && v.length > 0) {
            o = 0;
            Ext.Array.forEach(u,
            function(A) {
                for (var z = 0,
                y = s.length; z < y; z++) {
                    s[z] == A && ++o
                }
            });
            t = 0;
            Ext.Array.forEach(v,
            function(A) {
                for (var z = 0,
                y = l.length; z < y; z++) {
                    l[z] == A && ++t
                }
            });
            if (o < t) {
                Ext.Array.forEach(u,
                function(y) {
                    b(r, y, p)
                })
            } else {
                Ext.Array.forEach(v,
                function(y) {
                    b(w, y, p)
                })
            }
        }
    }
    function b(o, l, n) {
        var m;
        for (m in o) {
            if (o.hasOwnProperty(m) && o[m].hasOwnProperty(l)) {
                n(m, l)
            }
        }
    }
    function c(r, m) {
        var o, n, q, p, l;
        for (o in m) {
            if (m.hasOwnProperty(o)) {
                q = m[o];
                for (n in q) {
                    if (q.hasOwnProperty(n)) {
                        r[o][n][0] = "green"
                    }
                }
            }
        }
        return r
    }
    return {
        singleton: true,
        none: g,
        exception: j,
        cut: a
    }
});
Ext.define("Gnt.data.Linearizator",
function(u) {
    var r = {};
    function c(y, x, w) {
        w = l(w);
        return e([].concat(y), x, w.tasksDepsCollectingFn, w.cycleSolverFn)
    }
    function e(A, D, x, B) {
        var z = false,
        E = true,
        G, F, C, w, y;
        G = k();
        F = h();
        g(A, x, G, F);
        while (E) {
            z = false;
            while (!z) {
                z = true;
                E = false;
                for (C in G) {
                    if (G.hasOwnProperty(C) && G[C].color != "green") {
                        w = G[C].task;
                        y = f(w, F);
                        if (y != "red") {
                            v(y, w, G, F);
                            D(w, y, G, F);
                            z = false
                        } else {
                            E = true
                        }
                    }
                }
            }
            if (E) {
                E = B && B(G, F)
            }
        }
    }
    function l(y) {
        var x = n(y),
        A,
        z,
        w;
        w = r[x];
        if (!w) {
            A = Gnt.data.linearizator.CycleResolvers[y.cycles || "none"];
            z = [];
            y.self && (z.push(d));
            y.ancestors && (z.push(i));
            y.descendants && (z.push(t));
            y.successors && (z.push(p));
            z = q(z);
            w = {
                tasksDepsCollectingFn: z,
                cycleSolverFn: A
            };
            r[x] = w
        }
        return w
    }
    function n(x) {
        var w = [],
        y;
        for (y in x) {
            if (x.hasOwnProperty(y)) {
                w.push(y, "=", String(x[y]))
            }
        }
        return w.join(";")
    }
    function q(w) {
        return function(y, x, z) {
            var A = [];
            Ext.Array.forEach(w,
            function(B) {
                A = A.concat(B(y, x, z))
            });
            return A
        }
    }
    function g(z, y, x, w) {
        Ext.Array.forEach(z,
        function(A) {
            var B = y(A, x, w);
            if (B.length > 0) {
                g(B, y, x, w)
            }
        })
    }
    function d(x, w, y) {
        var A = [],
        z = x.internalId;
        if (!w.hasOwnProperty(z)) {
            w[z] = {
                task: x,
                color: "red"
            };
            A = [x]
        }
        return A
    }
    function i(x, I, H) {
        var w = [],
        z = H.downFromById,
        D = H.downToById,
        B = H.upFromById,
        C = H.upToById,
        E = x.internalId,
        y = x.parentNode,
        A = y && y.internalId,
        F,
        G;
        if (y && !I.hasOwnProperty(A)) {
            I[A] = {
                task: y,
                color: "red"
            };
            w.push(y)
        }
        if (y) {
            F = ["red"];
            G = ["red"]; ! z[A] && (z[A] = {}); ! z[A][E] && (z[A][E] = F); ! D[E] && (D[E] = F); ! C[A] && (C[A] = {}); ! C[A][E] && (C[A][E] = G); ! B[E] && (B[E] = G)
        }
        return w
    }
    function t(y, F, E) {
        var w = [],
        z = E.downFromById,
        C = E.downToById,
        A = E.upFromById,
        B = E.upToById,
        x = !y.isRoot() && y.childNodes,
        D = y.internalId;
        x && Ext.Array.forEach(x,
        function(G) {
            var J = G.internalId,
            H, I;
            if (!F.hasOwnProperty(J)) {
                F[J] = {
                    task: G,
                    color: "red"
                };
                w.push(G)
            }
            H = ["red"];
            I = ["red"]; ! z[D] && (z[D] = {}); ! z[D][J] && (z[D][J] = H); ! C[J] && (C[J] = H); ! B[D] && (B[D] = {}); ! B[D][J] && (B[D][J] = I); ! A[J] && (A[J] = I)
        });
        return w
    }
    function p(y, x, z) {
        var C = [],
        D = z.fromById,
        w = z.toById,
        B = y.getSuccessors(),
        A = y.internalId;
        Ext.Array.forEach(B,
        function(G) {
            var F = G.internalId,
            E;
            if (!x.hasOwnProperty(F)) {
                x[F] = {
                    task: G,
                    color: "red"
                };
                C.push(G)
            }
            E = ["red"]; ! D[A] && (D[A] = {}); ! D[A][F] && (D[A][F] = E); ! w[F] && (w[F] = {}); ! w[F][A] && (w[F][A] = E)
        });
        return C
    }
    function k() {
        return {}
    }
    function h() {
        return {
            fromById: {},
            toById: {},
            downFromById: {},
            downToById: {},
            upFromById: {},
            upToById: {}
        }
    }
    function j(y, A) {
        var x = A.toById[y.internalId],
        w = false,
        z;
        for (z in x) {
            if (x.hasOwnProperty(z) && x[z] && x[z][0] == "red") {
                w = true;
                break
            }
        }
        return w
    }
    function b(x, z) {
        var A = z.fromById[x.internalId],
        w = false,
        y;
        for (y in A) {
            if (A.hasOwnProperty(y) && A[y] && A[y][0] == "red") {
                w = true;
                break
            }
        }
        return w
    }
    function o(x, y) {
        var z = y.downToById,
        w = x.internalId;
        return z[w] && z[w][0] == "red"
    }
    function s(x, A) {
        var z = A.downFromById[x.internalId],
        w = false,
        y;
        for (y in z) {
            if (z.hasOwnProperty(y) && z[y] && z[y][0] == "red") {
                w = true;
                break
            }
        }
        return w
    }
    function a(x, z) {
        var A = z.upToById[x.internalId],
        w = false,
        y;
        for (y in A) {
            if (A.hasOwnProperty(y) && A[y] && A[y][0] == "red") {
                w = true;
                break
            }
        }
        return w
    }
    function m(x, y) {
        var w = x.internalId,
        z = y.upToById;
        return z[w] && z[w][0] == "red"
    }
    function f(x, y) {
        var w = "red";
        if (!j(x, y) && !o(x, y) && !a(x, y)) {
            w = "green"
        } else {
            if (!j(x, y) && !o(x, y) && s(x, y)) {
                w = "yellow"
            } else {
                w = "red"
            }
        }
        return w
    }
    function v(y, w, E, D) {
        var C = w.internalId,
        x = D.fromById[C],
        A = D.downFromById[C],
        B = D.upFromById[C],
        z;
        E[C].color = y;
        if (y == "green") {
            if (x) {
                for (z in x) {
                    if (x.hasOwnProperty(z)) {
                        x[z][0] = y
                    }
                }
            }
            if (A) {
                for (z in A) {
                    if (A.hasOwnProperty(z)) {
                        A[z][0] = y
                    }
                }
            }
            if (B) {
                B[0] = y
            }
        } else {
            if (y == "yellow") {
                if (A) {
                    for (z in A) {
                        if (A.hasOwnProperty(z)) {
                            A[z][0] = y
                        }
                    }
                }
            }
        }
    }
    return {
        singleton: true,
        requires: ["Gnt.data.linearizator.CycleResolvers"],
        linearWalkBySpecification: c
    }
});
Ext.define("Gnt.widget.ConstraintResolutionForm", {
    extend: "Ext.form.Panel",
    requires: ["Ext.form.RadioGroup", "Ext.form.field.Display"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.constraintresolutionform",
    legacyMode: false,
    config: {
        resolutionContext: null,
        dateFormat: null
    },
    bodyPadding: 5,
    autoScroll: true,
    constructor: function(a) {
        var b = this;
        if (Ext.Version.compare(Ext.versions.extjs, "5.0.0") == -1) {
            b.initConfig(a)
        }
        b.callParent([a])
    },
    initComponent: function() {
        var a = this;
        a.setupItemsFromResolutionContext(a.resolutionContext);
        a.setupFooterFromResolutionContext(a.resolutionContext);
        a.callParent(arguments)
    },
    setupItemsFromResolutionContext: function(b) {
        var c = this,
        a = [];
        Ext.Array.each(b.resolutions,
        function(e, d) {
            a.push({
                xtype: "radio",
                boxLabel: c.getResolutionOptionDescription(e.title, b),
                name: "resolutionOption",
                checked: e === b.getCancelActionOption(),
                inputValue: d,
                tabIndex: d
            })
        });
        c.items = [{
            xtype: "displayfield",
            itemId: "description",
            value: c.getConstraintViolationDescription(b),
            anchor: "-0"
        },
        {
            xtype: "radiogroup",
            itemId: "options",
            columns: 1,
            title: c.L("Resolution options"),
            allowBlank: false,
            items: a,
            anchor: "-0"
        }]
    },
    setupFooterFromResolutionContext: function(a) {
        var b = this;
        b.fbar = {
            itemId: "footer-tb",
            items: [{
                xtype: "checkbox",
                itemId: "dont-ask-cb",
                boxLabel: b.L("Don't ask again"),
                tabIndex: a.resolutions.length + 1
            },
            "->", {
                text: b.L("OK"),
                itemId: "ok-btn",
                formBind: true,
                tabIndex: a.resolutions.length + 2,
                handler: b.onUserActionOk,
                scope: b
            },
            {
                text: b.L("Cancel"),
                itemId: "cancel-btn",
                tabIndex: a.resolutions.length + 3,
                handler: b.onUserActionCancel,
                scope: b
            }]
        }
    },
    getDontAskValue: function() {
        var a = this;
        return a.down("#dont-ask-cb").getValue()
    },
    getConstraintViolationDescription: function(f) {
        var h = this,
        g, d, e, c, b, a;
        g = f.title;
        c = f.task;
        b = c.getName() || "";
        e = c.getConstraintClass();
        a = h.dateFormat || h.L("dateFormat") || Ext.Date.defaultFormat;
        d = e && e.getDisplayableConstraintDateForFormat(f.date, a, c) || f.date;
        return d ? Ext.String.format(h.L("Task {0} violates constraint {1} {2}"), b, g, Ext.Date.format(d, a)) : Ext.String.format(h.L("Task {0} violates constraint {1}"), b, g)
    },
    getResolutionOptionDescription: function(g, e) {
        var f = this,
        c, b, d, a;
        c = e.task;
        d = c.getConstraintClass();
        a = f.dateFormat || f.L("dateFormat") || Ext.Date.defaultFormat;
        b = d && d.getDisplayableConstraintDateForFormat(e.date, a, c) || e.date;
        return b ? Ext.String.format(g, Ext.Date.format(b, a)) : Ext.String.format(g, "")
    },
    onUserActionOk: function(b) {
        var c = this,
        a;
        a = c.getValues();
        a.dontAsk = c.getDontAskValue();
        c.fireEvent("ok", c, a)
    },
    onUserActionCancel: function(a) {
        var b = this;
        b.fireEvent("cancel", b)
    },
    getOptimalHeight: function(f) {
        var g = this,
        a, h, e, d, c, b;
        if (f) {
            a = g.getXY();
            h = g.getWidth();
            g.setXY([ - 10000, -10000]);
            g.setWidth(f)
        }
        e = g.getComponent("options");
        d = e.getEl().getOffsetsTo(g.body);
        b = g.getDockedComponent("footer-tb");
        c = d[1] + Ext.getDom(e.getEl()).scrollHeight + 2 * g.bodyPadding + b.getHeight() + 10;
        if (f) {
            g.setWidth(h);
            g.setXY(a)
        }
        return c
    }
});
Ext.define("Gnt.widget.ConstraintResolutionWindow", {
    extend: "Ext.window.Window",
    alias: "widget.constraintresolutionwindow",
    requires: ["Gnt.widget.ConstraintResolutionForm"],
    mixins: ["Gnt.mixin.Localizable"],
    modal: true,
    closable: true,
    resizable: true,
    collapsible: false,
    border: false,
    bodyBorder: false,
    config: {
        resolutionContext: null,
        dateFormat: null
    },
    form: null,
    constructor: function(a) {
        var b = this;
        if (Ext.Version.compare(Ext.versions.extjs, "5.0.0") == -1) {
            b.initConfig(a)
        }
        b.callParent([a])
    },
    initComponent: function() {
        var a = this;
        a.title = a.L("Constraint violation");
        a.setupItems();
        a.height = Math.round(Ext.dom.Element.getViewportHeight() / 3);
        a.width = Math.round(Ext.dom.Element.getViewportWidth() / 4);
        a.callParent(arguments);
        a.on("afterlayout", a.onAfterOptimalLayout, a, {
            single: true
        })
    },
    setupItems: function() {
        var a = this;
        a.layout = "fit";
        a.form = new Gnt.widget.ConstraintResolutionForm({
            margin: "0 0 3 0",
            resolutionContext: a.getResolutionContext(),
            dateFormat: a.getDateFormat(),
            bubbleEvents: ["ok", "cancel"]
        });
        a.items = a.form
    },
    onAfterOptimalLayout: function() {
        var c = this,
        d, a, e, b;
        d = c.getHeight();
        a = c.form.getHeight();
        e = c.form.getOptimalHeight();
        b = e + d - a;
        d != b && c.setHeight(b)
    }
});
Ext.define("Gnt.plugin.ConstraintResolutionGui", {
    extend: "Ext.AbstractPlugin",
    alias: "plugin.constraintresolutiongui",
    requires: ["Gnt.widget.ConstraintResolutionWindow"],
    config: {
        dateFormat: null
    },
    cmpDetacher: null,
    storeDetacher: null,
    storedResolutions: null,
    constructor: function(a) {
        var b = this;
        if (Ext.Version.compare(Ext.versions.extjs, "5.0.0") == -1) {
            b.initConfig(a)
        }
        b.callParent([a])
    },
    init: function(b) {
        var a = this;
        a.callParent(arguments);
        if (!a.disabled) {
            a.enable()
        }
    },
    enable: function() {
        var b = this,
        a = b.getCmp();
        b.callParent();
        if (a.rendered) {
            b.attachToTaskStore()
        } else {
            b.cmpDetacher = a.on("afterrender",
            function() {
                b.attachToTaskStore()
            },
            null, {
                destroyable: true,
                single: true
            })
        }
    },
    disable: function() {
        var b = this,
        a = b.getCmp();
        b.callParent();
        if (a.rendered) {
            b.detachFromTaskStore()
        } else {
            b.cmpDetacher && Ext.destroy(b.cmpDetacher);
            b.cmpDetacher = null
        }
    },
    attachToTaskStore: function() {
        var c = this,
        b, a;
        if (!c.storeDetacher) {
            b = c.getCmp();
            a = b.getTaskStore();
            c.storeDetacher = b.mon(a, "constraintconflict", c.onConstraintConflict, c, {
                destroyable: true
            })
        }
    },
    detachFromTaskStore: function() {
        var a = this;
        a.storeDetacher && Ext.destroy(a.storeDetacher);
        a.storeDetacher = null
    },
    onConstraintConflict: function(b, a) {
        var i = this,
        k = i.getCmp(),
        l = k.lockedGrid.getView(),
        d = k.normalGrid.getView(),
        f = k.getDependencyView(),
        j = d.indexOf(b),
        c,
        h,
        g = {
            destroy: function() {
                Ext.destroy(h)
            }
        };
        function e() {
            if (j != -1) {
                l.refreshNode(j);
                d.refreshNode(j);
                f.updateDependencies(b)
            }
        }
        e();
        if (!i.hasStoredResolutionForContext(a)) {
            c = new Gnt.widget.ConstraintResolutionWindow({
                dateFormat: i.getDateFormat(),
                resolutionContext: a
            });
            h = c.on({
                ok: Ext.Function.bind(i.onUserActionOk, i, [a, e, c, g], true),
                cancel: Ext.Function.bind(i.onUserActionCancel, i, [a, e, c, g], true),
                close: Ext.Function.bind(i.onUserActionClose, i, [a, e, g], true),
                scope: i,
                destroyable: true
            });
            k.completeEdit();
            c.show()
        } else {
            i.resolveSilently(a, e)
        }
    },
    getStoredResolutions: function() {
        var a = this;
        if (!a.storedResolutions) {
            a.storedResolutions = {}
        }
        return a.storedResolutions
    },
    getStoredResolutionKeyForContext: function(a) {
        return a.title + a.resolutions.length
    },
    hasStoredResolutionForContext: function(b) {
        var c = this,
        a = c.getStoredResolutionKeyForContext(b),
        d = c.getStoredResolutions();
        return Ext.isDefined(d[a])
    },
    getStoredResolutionForContext: function(b) {
        var c = this,
        a = c.getStoredResolutionKeyForContext(b),
        d = c.getStoredResolutions();
        return d[a]
    },
    storeResolutionForContext: function(b, d) {
        var c = this,
        a = c.getStoredResolutionKeyForContext(b),
        e = c.storedResolutions;
        c.storedResolutions[a] = d
    },
    resolveSilently: function(a, d) {
        var c = this,
        b = c.getStoredResolutionForContext(a);
        a.resolutions[b].resolve();
        d()
    },
    onUserActionOk: function(g, b, d, c, h, f, a) {
        var e = this;
        Ext.destroy(a);
        f.close();
        if (b.dontAsk) {
            e.storeResolutionForContext(c, b.resolutionOption)
        }
        c.resolutions[b.resolutionOption].resolve();
        h()
    },
    onUserActionCancel: function(f, c, b, g, e, a) {
        var d = this;
        Ext.destroy(a);
        e.close();
        b.cancelAction();
        g()
    },
    onUserActionClose: function(e, c, b, f, a) {
        var d = this;
        Ext.destroy(a);
        b.cancelAction();
        f()
    }
});
Ext.define("Gnt.data.Calendar", {
    extend: "Ext.data.Store",
    requires: ["Ext.Date", "Gnt.model.CalendarDay", "Sch.model.Range", "Sch.util.Date"],
    model: "Gnt.model.CalendarDay",
    proxy: "memory",
    daysPerMonth: 30,
    daysPerWeek: 7,
    hoursPerDay: 24,
    unitsInMs: null,
    defaultNonWorkingTimeCssCls: "gnt-holiday",
    weekendsAreWorkdays: false,
    weekendFirstDay: 6,
    weekendSecondDay: 0,
    holidaysCache: null,
    availabilityIntervalsCache: null,
    daysIndex: null,
    weekAvailability: null,
    defaultWeekAvailability: null,
    nonStandardWeeksByStartDate: null,
    nonStandardWeeksStartDates: null,
    calendarId: null,
    parent: null,
    defaultAvailability: ["00:00-24:00"],
    name: null,
    suspendCacheUpdate: 0,
    availabilitySearchLimit: 1825,
    statics: {
        getCalendar: function(a) {
            if (a instanceof Gnt.data.Calendar) {
                return a
            }
            return Ext.data.StoreManager.lookup("GNT_CALENDAR:" + a)
        },
        getAllCalendars: function() {
            var a = [];
            Ext.data.StoreManager.each(function(b) {
                if (b instanceof Gnt.data.Calendar) {
                    a.push(b)
                }
            });
            return a
        },
        removeAll: function() {
            var a = Ext.data.StoreManager;
            a.each(function(b) {
                if (b instanceof Gnt.data.Calendar) {
                    a.unregister(b);
                    Ext.destroy(b)
                }
            })
        }
    },
    constructor: function(a) {
        a = a || {};
        var b = a.parent;
        delete a.parent;
        var c = a.calendarId;
        delete a.calendarId;
        this.callParent(arguments);
        this.setParent(b);
        this.setCalendarId(c);
        this.unitsInMs = {
            MILLI: 1,
            SECOND: 1000,
            MINUTE: 60 * 1000,
            HOUR: 60 * 60 * 1000,
            DAY: this.hoursPerDay * 60 * 60 * 1000,
            WEEK: this.daysPerWeek * this.hoursPerDay * 60 * 60 * 1000,
            MONTH: this.daysPerMonth * this.hoursPerDay * 60 * 60 * 1000,
            QUARTER: 3 * this.daysPerMonth * 24 * 60 * 60 * 1000,
            YEAR: 4 * 3 * this.daysPerMonth * 24 * 60 * 60 * 1000
        };
        this.defaultWeekAvailability = this.getDefaultWeekAvailability();
        this.on({
            update: this.clearCache,
            datachanged: this.clearCache,
            clear: this.clearCache,
            load: this.clearCache,
            scope: this
        });
        this.clearCache()
    },
    getCalendarId: function() {
        return this.calendarId
    },
    setCalendarId: function(b) {
        if (this.calendarId != null) {
            Ext.data.StoreManager.unregister(this)
        }
        this.calendarId = b;
        if (b != null) {
            this.storeId = "GNT_CALENDAR:" + b;
            Ext.data.StoreManager.register(this)
        } else {
            this.storeId = null
        }
        var a = this.proxy;
        if (a && a.extraParams) {
            a.extraParams.calendarId = b
        }
    },
    getDefaultWeekAvailability: function() {
        var e = this.defaultAvailability;
        var d = this.weekendFirstDay;
        var a = this.weekendSecondDay;
        var c = [];
        for (var b = 0; b < 7; b++) {
            c.push(this.weekendsAreWorkdays || b != d && b != a ? new this.model({
                Type: "WEEKDAY",
                Weekday: b,
                Availability: e && Ext.Array.clone(e) || [],
                IsWorkingDay: true
            }) : new this.model({
                Type: "WEEKDAY",
                Weekday: b,
                Availability: []
            }))
        }
        return c
    },
    clearCache: function() {
        if (this.suspendCacheUpdate > 0) {
            return
        }
        this.holidaysCache = {};
        this.availabilityIntervalsCache = {};
        var c = this.daysIndex = {};
        var a = this.weekAvailability = [];
        var d = this.nonStandardWeeksStartDates = [];
        var b = this.nonStandardWeeksByStartDate = {};
        this.each(function(k) {
            var e = k.getId();
            var n = /^(\d)-(\d\d\d\d\/\d\d\/\d\d)-(\d\d\d\d\/\d\d\/\d\d)$/.exec(e);
            var j = /^WEEKDAY:(\d+)$/.exec(e);
            var m = k.getType();
            var l = k.getWeekday();
            if (m == "WEEKDAYOVERRIDE" || n) {
                var f, i;
                if (m == "WEEKDAYOVERRIDE") {
                    f = k.getOverrideStartDate();
                    i = k.getOverrideEndDate()
                }
                if (n) {
                    f = Ext.Date.parse(n[2], "Y/m/d");
                    i = Ext.Date.parse(n[3], "Y/m/d");
                    l = n[1]
                }
                if (f && i && l != null) {
                    var h = f - 0;
                    if (!b[h]) {
                        b[h] = {
                            startDate: new Date(f),
                            endDate: new Date(i),
                            name: k.getName(),
                            weekAvailability: [],
                            mainDay: null
                        };
                        d.push(h)
                    }
                    if (l >= 0) {
                        b[h].weekAvailability[l] = k
                    } else {
                        b[h].mainDay = k
                    }
                }
            } else {
                if (m == "WEEKDAY" || j) {
                    if (j) {
                        l = j[1]
                    }
                    if (l != null) {
                        if (l < 0 || l > 6) {
                            throw new Error("Incorrect week day index")
                        }
                        a[l] = k
                    }
                } else {
                    var g = k.getDate();
                    if (g) {
                        c[g - 0] = k
                    }
                }
            }
        });
        d.sort();
        this.fireEvent("calendarchange", this)
    },
    intersectsWithCurrentWeeks: function(b, c) {
        var a = false;
        this.forEachNonStandardWeek(function(f) {
            var d = f.startDate;
            var e = f.endDate;
            if (d <= b && b < e || d < c && c <= e) {
                a = true;
                return false
            }
        });
        return a
    },
    addNonStandardWeek: function(b, f, a, c) {
        b = Ext.Date.clearTime(new Date(b));
        f = Ext.Date.clearTime(new Date(f));
        if (this.intersectsWithCurrentWeeks(b, f)) {
            throw new Error("Can not add intersecting week")
        }
        var e = this.model;
        var g = [];
        Ext.Array.each(a,
        function(h, i) {
            if (h instanceof Gnt.model.CalendarDay) {
                h.setType("WEEKDAYOVERRIDE");
                h.setOverrideStartDate(b);
                h.setOverrideEndDate(f);
                h.setWeekday(i);
                h.setName(c || "Week override");
                g.push(h)
            } else {
                if (Ext.isArray(h)) {
                    var j = new e();
                    j.setType("WEEKDAYOVERRIDE");
                    j.setOverrideStartDate(b);
                    j.setOverrideEndDate(f);
                    j.setWeekday(i);
                    j.setName(c || "Week override");
                    j.setAvailability(h);
                    g.push(j)
                }
            }
        });
        var d = new e();
        d.setType("WEEKDAYOVERRIDE");
        d.setOverrideStartDate(b);
        d.setOverrideEndDate(f);
        d.setWeekday( - 1);
        d.setName(c || "Week override");
        g.push(d);
        this.add(g)
    },
    getNonStandardWeekByStartDate: function(a) {
        return this.nonStandardWeeksByStartDate[Ext.Date.clearTime(new Date(a)) - 0] || null
    },
    getNonStandardWeekByDate: function(d) {
        d = Ext.Date.clearTime(new Date(d)) - 0;
        var e = this.nonStandardWeeksStartDates;
        var a = this.nonStandardWeeksByStartDate;
        for (var c = 0; c < e.length; c++) {
            var b = a[e[c]];
            if (b.startDate > d) {
                break
            }
            if (b.startDate <= d && d <= b.endDate) {
                return b
            }
        }
        return null
    },
    removeNonStandardWeek: function(a) {
        a = Ext.Date.clearTime(new Date(a)) - 0;
        var b = this.getNonStandardWeekByStartDate(a);
        if (!b) {
            return
        }
        this.remove(Ext.Array.clean(b.weekAvailability).concat(b.mainDay))
    },
    forEachNonStandardWeek: function(e, c) {
        var d = this;
        var f = this.nonStandardWeeksStartDates;
        var a = this.nonStandardWeeksByStartDate;
        for (var b = 0; b < f.length; b++) {
            if (e.call(c || d, a[f[b]]) === false) {
                return false
            }
        }
    },
    setWeekendsAreWorkDays: function(a) {
        if (a !== this.weekendsAreWorkdays) {
            this.weekendsAreWorkdays = a;
            this.defaultWeekAvailability = this.getDefaultWeekAvailability();
            this.clearCache()
        }
    },
    areWeekendsWorkDays: function() {
        return this.weekendsAreWorkdays
    },
    getCalendarDay: function(a) {
        a = typeof a == "number" ? new Date(a) : a;
        return this.getOverrideDay(a) || this.getWeekDay(a.getDay(), a) || this.getDefaultCalendarDay(a.getDay())
    },
    getOverrideDay: function(a) {
        return this.getOwnCalendarDay(a) || this.parent && this.parent.getOverrideDay(a) || null
    },
    getOwnCalendarDay: function(a) {
        a = typeof a == "number" ? new Date(a) : a;
        return this.daysIndex[Ext.Date.clearTime(a, true) - 0]
    },
    getWeekDay: function(c, b) {
        if (b) {
            var a = this.getNonStandardWeekByDate(b);
            if (a && a.weekAvailability[c]) {
                return a.weekAvailability[c]
            }
        }
        return this.weekAvailability[c] || this.parent && this.parent.getWeekDay(c, b) || null
    },
    getDefaultCalendarDay: function(a) {
        if (!this.hasOwnProperty("defaultAvailability") && !this.hasOwnProperty("weekendsAreWorkdays") && this.parent) {
            return this.parent.getDefaultCalendarDay(a)
        }
        return this.defaultWeekAvailability[a]
    },
    isHoliday: function(c) {
        var b = c - 0;
        var d = this.holidaysCache;
        if (d[b] != null) {
            return d[b]
        }
        c = typeof c == "number" ? new Date(c) : c;
        var a = this.getCalendarDay(c);
        if (!a) {
            throw "Can't find day for " + c
        }
        return d[b] = !a.getIsWorkingDay()
    },
    isWeekend: function(b) {
        var a = b.getDay();
        return a === this.weekendFirstDay || a === this.weekendSecondDay
    },
    isWorkingDay: function(a) {
        return ! this.isHoliday(a)
    },
    convertMSDurationToUnit: function(a, b) {
        return a / this.unitsInMs[Sch.util.Date.getNameOfUnit(b)]
    },
    convertDurationToMs: function(b, a) {
        return b * this.unitsInMs[Sch.util.Date.getNameOfUnit(a)]
    },
    getHolidaysRanges: function(d, g, a) {
        if (d > g) {
            Ext.Error.raise("startDate can't be bigger than endDate")
        }
        d = Ext.Date.clearTime(d, true);
        g = Ext.Date.clearTime(g, true);
        var c = [],
        h,
        e;
        for (e = d; e < g; e = Sch.util.Date.getNext(e, Sch.util.Date.DAY, 1)) {
            if (this.isHoliday(e) || (this.weekendsAreWorkdays && a && this.isWeekend(e))) {
                var i = this.getCalendarDay(e);
                var j = i && i.getCls() || this.defaultNonWorkingTimeCssCls;
                var f = Sch.util.Date.getNext(e, Sch.util.Date.DAY, 1);
                if (!h) {
                    h = {
                        StartDate: e,
                        EndDate: f,
                        Cls: j
                    }
                } else {
                    if (h.Cls == j) {
                        h.EndDate = f
                    } else {
                        c.push(h);
                        h = {
                            StartDate: e,
                            EndDate: f,
                            Cls: j
                        }
                    }
                }
            } else {
                if (h) {
                    c.push(h);
                    h = null
                }
            }
        }
        if (h) {
            c.push(h)
        }
        var b = [];
        Ext.each(c,
        function(k) {
            b.push(Ext.create("Sch.model.Range", {
                StartDate: k.StartDate,
                EndDate: k.EndDate,
                Cls: k.Cls
            }))
        });
        return b
    },
    forEachAvailabilityInterval: function(r, f, q) {
        q = q || this;
        var m = this;
        var d = r.startDate;
        var k = r.endDate;
        var p = r.isForward !== false;
        if (p ? !d: !k) {
            throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option")
        }
        var a = new Date(p ? d: k);
        var c = Sch.util.Date;
        if (p) {
            if (!k) {
                k = c.add(d, "d", r.availabilitySearchLimit || this.availabilitySearchLimit || 5 * 365)
            }
        } else {
            if (!d) {
                d = c.add(k, "d", -(r.availabilitySearchLimit || this.availabilitySearchLimit || 5 * 365))
            }
        }
        var g = false;
        while (p ? a < k: a > d) {
            var j = this.getAvailabilityIntervalsFor(a - (p ? 0 : 1), p ? g: false);
            for (var h = p ? 0 : j.length - 1; p ? h < j.length: h >= 0; p ? h++:h--) {
                var b = j[h];
                var l = b.startDate;
                var o = b.endDate;
                if (l >= k || o <= d) {
                    continue
                }
                var e = l < d ? d: l;
                var n = o > k ? k: o;
                if (f.call(q, e, n) === false) {
                    return false
                }
            }
            a = p ? c.getStartOfNextDay(a, false, g) : c.getEndOfPreviousDay(a, g);
            g = true
        }
    },
    calculateDuration: function(a, d, b) {
        var c = 0;
        this.forEachAvailabilityInterval({
            startDate: a,
            endDate: d
        },
        function(g, f) {
            var e = g.getTimezoneOffset() - f.getTimezoneOffset();
            c += f - g + e * 60 * 1000
        });
        return this.convertMSDurationToUnit(c, b)
    },
    calculateEndDate: function(a, f, b) {
        if (!f) {
            return new Date(a)
        }
        var e = Sch.util.Date,
        d;
        f = this.convertDurationToMs(f, b);
        var c = f === 0 && Ext.Date.clearTime(a, true) - a === 0 ? e.add(a, Sch.util.Date.DAY, -1) : a;
        this.forEachAvailabilityInterval({
            startDate: c
        },
        function(i, h) {
            var j = h - i;
            var g = i.getTimezoneOffset() - h.getTimezoneOffset();
            if (j >= f) {
                d = new Date(i - 0 + f);
                return false
            } else {
                f -= j + g * 60 * 1000
            }
        });
        return d
    },
    calculateStartDate: function(d, c, b) {
        if (!c) {
            return new Date(d)
        }
        var a;
        c = this.convertDurationToMs(c, b);
        this.forEachAvailabilityInterval({
            endDate: d,
            isForward: false
        },
        function(f, e) {
            var g = e - f;
            if (g >= c) {
                a = new Date(e - c);
                return false
            } else {
                c -= g
            }
        });
        return a
    },
    skipNonWorkingTime: function(a, c) {
        var b = false;
        this.forEachAvailabilityInterval(c ? {
            startDate: a
        }: {
            endDate: a,
            isForward: false
        },
        function(e, d) {
            a = c ? e: d;
            b = true;
            return false
        });
        if (!b) {
            throw "skipNonWorkingTime: Cannot skip non-working time, please ensure that this calendar has any working period of time specified"
        }
        return new Date(a)
    },
    skipWorkingTime: function(a, c, b) {
        return c >= 0 ? this.calculateEndDate(a, c, b) : this.calculateStartDate(a, -c, b)
    },
    getAvailabilityIntervalsFor: function(a, b) {
        if (b) {
            a = (a).valueOf()
        } else {
            if (a instanceof Date) {
                a = (new Date(a.getFullYear(), a.getMonth(), a.getDate())).valueOf()
            } else {
                a = Ext.Date.clearTime(new Date(a)).valueOf()
            }
        }
        return this.availabilityIntervalsCache[a] = (this.availabilityIntervalsCache[a] || this.getCalendarDay(a).getAvailabilityIntervalsFor(a))
    },
    getByInternalId: function(a) {
        return this.data.map[a]
    },
    getParentableCalendars: function() {
        var c = this,
        a = [],
        d = Gnt.data.Calendar.getAllCalendars();
        var b = function(e) {
            if (!e.parent) {
                return false
            }
            if (e.parent == c) {
                return true
            }
            return b(e.parent)
        };
        Ext.Array.each(d,
        function(e) {
            if (e === c) {
                return
            }
            if (!b(e)) {
                a.push({
                    Id: e.calendarId,
                    Name: e.name || e.calendarId
                })
            }
        });
        return a
    },
    setParent: function(e) {
        var d = Gnt.data.Calendar.getCalendar(e);
        if (e && !d) {
            throw new Error("Invalid parent specified for the calendar")
        }
        if (this.parent != d) {
            var b = this.proxy;
            var c = {
                calendarchange: this.clearCache,
                scope: this
            };
            var a = this.parent;
            if (a) {
                a.un(c)
            }
            this.parent = d;
            if (d) {
                d.on(c)
            }
            if (b && b.extraParams) {
                b.extraParams.parentId = d ? d.calendarId: null
            }
            this.clearCache();
            this.fireEvent("parentchange", this, d, a)
        }
    },
    isAvailabilityIntersected: function(p, b, m) {
        var n, a, e, h;
        for (var g = 0; g < 7; g++) {
            n = this.getWeekDay(g) || this.getDefaultCalendarDay(g);
            e = p.getWeekDay(g) || p.getDefaultCalendarDay(g);
            if (!n || !e) {
                continue
            }
            a = n.getAvailability();
            h = e.getAvailability();
            for (var f = 0,
            c = a.length; f < c; f++) {
                for (var d = 0,
                o = h.length; d < o; d++) {
                    if (h[d].startTime < a[f].endTime && h[d].endTime > a[f].startTime) {
                        return true
                    }
                }
            }
        }
        var q = false;
        this.forEachNonStandardWeek(function(i) {
            if (i.startDate >= m) {
                return false
            }
            if (b < i.endDate) {
                q = true;
                return false
            }
        });
        return q
    }
});
Ext.define("Gnt.data.CalendarManager", {
    extend: "Ext.data.TreeStore",
    requires: ["Gnt.data.Calendar"],
    model: "Gnt.model.Calendar",
    alias: "store.calendarmanager",
    calendarClass: "Gnt.data.Calendar",
    calendarConfig: null,
    projectCalendar: null,
    myListeners: null,
    constructor: function(b) {
        b = b || {};
        if (!b.proxy) {
            b.proxy = {
                type: "memory"
            }
        }
        this.callParent([b]);
        this.myListeners = this.on({
            idchanged: this.onChangeId,
            rootchange: this.onNewRoot,
            nodeappend: this.onNewNode,
            nodeinsert: this.onNewNode,
            noderemove: this.onRemoveNode,
            destroyable: true,
            scope: this
        });
        var a = this.getRootNode();
        if (a) {
            this.bindCalendars(a)
        } else {
            this.setRoot({
                expanded: true
            })
        }
    },
    destroy: function() {
        this.myListeners.destroy();
        this.callParent(arguments)
    },
    onChangeId: function(c, e, b, a) {
        if (! (c instanceof Gnt.model.Calendar)) {
            return
        }
        var d = this.getCalendar(e || a);
        d.setCalendarId(b)
    },
    onIdChanged: function(b, c, a) {
        this.onChangeId(b, c, a);
        return this.callParent(arguments)
    },
    onNewNode: function(a, c) {
        this.bindCalendars(c);
        c.set && c.set("iconCls", "gnt-date");
        var b = this;
        c.cascadeBy(function(d) {
            d.setCalendarManager(b)
        })
    },
    onNewRoot: function(a) {
        this.onNewNode(null, a)
    },
    onRemoveNode: function(b, c, a) {
        if (!a) {
            var d = c.calendar;
            if (d) {
                this.unbindCalendarEvents(d);
                if (!this.__loading) {
                    d.destroy();
                    Ext.data.StoreManager.unregister(d)
                }
                c.setCalendarManager(null)
            }
        }
    },
    suspendCalendarsEvents: function(a) {
        this.getRootNode().cascadeBy(function(b) {
            var d = b.getCalendar();
            if (d) {
                d.suspendEvents(a)
            }
        },
        this)
    },
    resumeCalendarsEvents: function() {
        this.getRootNode().cascadeBy(function(a) {
            var b = a.getCalendar();
            if (b) {
                b.resumeEvents()
            }
        },
        this)
    },
    getProjectCalendar: function() {
        return this.projectCalendar
    },
    setProjectCalendar: function(a) {
        if (typeof a !== "object") {
            a = this.getCalendar(a) || Gnt.data.Calendar.getCalendar(a)
        }
        if (!a) {
            return
        }
        this.projectCalendar = a;
        this.fireEvent("projectcalendarset", this, a)
    },
    getCalendar: function(b) {
        var a = this.getNodeById(b);
        return a && a.getCalendar()
    },
    bindCalendarEvents: function(a) {
        this.relayEvents(a, ["load"], "calendar");
        this.relayEvents(a, ["add", "update", "remove", "bulkremove"], "day");
        this.relayEvents(a, ["calendarchange"]);
        a.on({
            add: this.onDayAdd,
            update: this.onDayUpdate,
            remove: this.onDayRemove,
            scope: this
        })
    },
    unbindCalendarEvents: function(a) {
        a && a.un({
            add: this.onDayAdd,
            update: this.onDayUpdate,
            remove: this.onDayRemove,
            scope: this
        })
    },
    onDayAdd: function(b, a) {
        this.getNodeById(b.getCalendarId()).dirty = true
    },
    onDayUpdate: function(b, a) {
        this.getNodeById(b.getCalendarId()).dirty = true
    },
    onDayRemove: function(b, a) {
        this.getNodeById(b.getCalendarId()).dirty = true
    },
    bindCalendar: function(b) {
        if (!b || this.getRoot() === b) {
            return
        }
        var e = b.getCalendar();
        var g = b.getDays();
        var f = b.getId() || b.internalId;
        g = Ext.isArray(g) && g;
        if (!e || g) {
            if (!e) {
                e = this.getCalendar(f);
                if (e) {
                    b.setCalendar(e);
                    return
                }
                e = Gnt.data.Calendar.getCalendar(f)
            }
            if (!e) {
                var c = b.parentNode && b.parentNode.getCalendar();
                var d = Ext.ClassManager.get(b.getCalendarClass() || this.calendarClass);
                var a = Ext.applyIf(b.getCalendarConfig(), {
                    data: g,
                    parent: c
                });
                e = Ext.create(d, Ext.apply(a, this.calendarConfig))
            }
            b.setCalendar(e);
            this.bindCalendarEvents(e)
        } else {
            if (!this.getCalendar(e.calendarId)) {
                this.bindCalendarEvents(e)
            }
        }
        this.fireEvent("calendarbound", this, e, b)
    },
    unbindCalendar: function(a) {
        if (!a || this.getRoot() === a) {
            return
        }
        var b = a.getCalendar();
        if (!b) {
            return
        }
        this.unbindCalendarEvents(b);
        this.fireEvent("calendarunbound", this, b, a)
    },
    bindCalendars: function(b) {
        var a = this;
        if (b) {
            if (Ext.isArray(b)) {
                Ext.each(b,
                function(c) {
                    c.cascadeBy(a.bindCalendar, a)
                })
            } else {
                b.cascadeBy(a.bindCalendar, a)
            }
        }
    },
    unbindCalendars: function(b) {
        var a = this;
        if (b) {
            if (Ext.isArray(b)) {
                Ext.each(b,
                function(c) {
                    c.cascadeBy(a.unbindCalendar, a)
                })
            } else {
                b.cascadeBy(a.unbindCalendar, a)
            }
        }
    }
});
Ext.define("Gnt.data.calendar.BusinessTime", {
    extend: "Gnt.data.Calendar",
    daysPerMonth: 20,
    daysPerWeek: 5,
    hoursPerDay: 8,
    defaultAvailability: ["08:00-12:00", "13:00-17:00"]
});
Ext.define("Gnt.data.DependencyStore", {
    extend: "Ext.data.Store",
    model: "Gnt.model.Dependency",
    storeId: "dependencies",
    alias: "store.gantt_dependencystore",
    taskStore: null,
    methodsCache: null,
    strictDependencyValidation: false,
    transitiveDependencyValidation: false,
    ignoreInitial: true,
    isLoadingRecords: false,
    allowedDependencyTypes: null,
    proxy: "memory",
    allowParentTaskDependencies: true,
    constructor: function(a) {
        a = a || {};
        this.callParent([a]);
        this.init();
        this.ignoreInitial = false
    },
    init: function() {
        this.methodsCache = {};
        this.on({
            add: this.onDependencyAdd,
            update: this.onDependencyUpdate,
            load: this.onDependencyLoad,
            datachanged: this.onDependencyDataChanged,
            remove: this.onDependencyRemove,
            clear: this.onDependencyStoreClear,
            beforesync: this.onBeforeSyncOperation,
            priority: 100,
            scope: this
        })
    },
    onDependencyLoad: function() {
        var a = this.getTaskStore();
        a && a.fillTasksWithDepInfo()
    },
    onDependencyDataChanged: function() {
        var a = this.getTaskStore();
        if (this.isLoadingRecords && a) {
            a.fillTasksWithDepInfo()
        }
    },
    loadRecords: function() {
        this.isLoadingRecords = true;
        this.callParent(arguments);
        this.isLoadingRecords = false
    },
    scheduleTask: function(b) {
        var c = this.getTaskStore(),
        a = b.getStartDate(),
        d = b.getEndDate();
        if (!a || !d) {
            b.beginEdit();
            if (!a) {
                b.setStartDateWithoutPropagation(c.getProjectStartDate(), undefined !== b.getDuration())
            }
            if (!d) {
                b.setDurationWithoutPropagation(1)
            }
            b.endEdit()
        }
    },
    scheduleLinkedTasks: function(b, a) {
        this.scheduleTask(b);
        if (!a.getStartDate() && !b.getTaskStore().cascadeChanges) {
            a.constrain()
        }
        this.scheduleTask(a)
    },
    onDependencyAdd: function(c, d) {
        if (this.ignoreInitial) {
            return
        }
        for (var b = 0; b < d.length; b++) {
            var a = d[b];
            if (!this.isValidDependencyType(a.getType())) {
                throw "This dependency type is invalid. Check Gnt.data.DependencyStore#allowedDependencyTypes value"
            }
            var f = a.getSourceTask(),
            e = a.getTargetTask();
            if (f && e) {
                f.successors.push(a);
                e.predecessors.push(a);
                this.scheduleLinkedTasks(f, e)
            }
        }
        c.resetMethodsCache()
    },
    onDependencyRemove: function(d, e, c, a) {
        var b = this.getTaskStore();
        Ext.each(e,
        function(f) {
            var h = f.getSourceTask(b),
            g = f.getTargetTask(b);
            if (h) {
                Ext.Array.remove(h.successors, f)
            }
            if (g) {
                Ext.Array.remove(g.predecessors, f)
            }
        });
        d.resetMethodsCache()
    },
    onDependencyUpdate: function(i, b, c) {
        if (c != Ext.data.Model.COMMIT) {
            var j = this.getTaskStore();
            var e = b.previous;
            var h = b.getSourceTask();
            var f = b.getTargetTask();
            var g = e && b.fromField in e;
            var a = e && b.toField in e;
            if (g) {
                var k = j.getNodeById(e[b.fromField]);
                k && Ext.Array.remove(k.successors, b);
                if (h && Ext.Array.indexOf(h.successors, b) < 0) {
                    h.successors.push(b)
                }
            }
            if (a) {
                var d = j.getNodeById(e[b.toField]);
                d && Ext.Array.remove(d.predecessors, b);
                if (f && Ext.Array.indexOf(f.predecessors, b) < 0) {
                    f.predecessors.push(b)
                }
            }
            if ((g || a) && h && f) {
                this.scheduleLinkedTasks(h, f)
            }
            this.resetMethodsCache()
        }
    },
    onDependencyStoreClear: function(b) {
        var a = b.getTaskStore();
        a && a.fillTasksWithDepInfo()
    },
    onBeforeSyncOperation: function(a) {
        if (a.create) {
            for (var c, b = a.create.length - 1; b >= 0; b--) {
                c = a.create[b];
                if (!c.isPersistable()) {
                    Ext.Array.remove(a.create, c)
                }
            }
            if (a.create.length === 0) {
                delete a.create
            }
        }
        return Boolean((a.create && a.create.length > 0) || (a.update && a.update.length > 0) || (a.destroy && a.destroy.length > 0))
    },
    getDependenciesForTask: function(a) {
        return a.successors.concat(a.predecessors)
    },
    getIncomingDependenciesForTask: function(a, b) {
        return b ? a.predecessors: a.predecessors.slice()
    },
    getOutgoingDependenciesForTask: function(a, b) {
        return b ? a.successors: a.successors.slice()
    },
    getKeyByDeps: function(e, g, b) {
        if (!e || !e.length) {
            return ""
        }
        var d = "";
        for (var c = 0,
        a = e.length; c < a; c++) {
            var f = e[c];
            d += (f.getSourceId && f.getSourceId() || f[g]) + ":" + (f.getTargetId && f.getTargetId() || f[b]) + ","
        }
        return d
    },
    buildCacheKey: function(f, g, c, e, a) {
        var i = a.fromField || (a.fromField = this.model.prototype.fromField),
        d = a.toField || (a.toField = this.model.prototype.toField),
        b = a.ignoreDepKey,
        h = a.addDepKey;
        if (!a.hasOwnProperty("ignoreDepKey")) {
            a.ignoreDepKey = b = c && this.getKeyByDeps(c, i, d) || "";
            a.addDepKey = h = e && this.getKeyByDeps(e, i, d) || ""
        }
        return f + "-" + g + "-" + b + "-" + h
    },
    hasTransitiveDependency: function(f, b, c, o, a) {
        a = a || {
            visitedTasks: {}
        };
        var d = this.buildCacheKey(f, b, c, o, a);
        var r = a.visitedTasks,
        p = a.extraSuccessors;
        if (this.isCachedResultAvailable("hasTransitiveDependency", d)) {
            return this.methodsCache.hasTransitiveDependency[d]
        }
        var q = this,
        u = a.fromField,
        g = a.toField,
        s = this.getTaskById(f),
        n,
        k;
        if (r[f]) {
            return false
        }
        r[f] = true;
        if (s) {
            if (o && !p) {
                p = a.extraSuccessors = {};
                for (n = 0, k = o.length; n < k; n++) {
                    var e = o[n];
                    var m = e.getSourceId && e.getSourceId() || e[u];
                    p[m] = p[m] || [];
                    p[m].push(e)
                }
            }
            var j, h = s.successors;
            if (p && p[f]) {
                h = h.concat(p[f])
            }
            for (n = 0, k = h.length; n < k; n++) {
                j = h[n];
                var t = j.getTargetId && j.getTargetId() || j[g];
                if ((!c || Ext.Array.indexOf(c, j) == -1) && (t === b || q.hasTransitiveDependency(t, b, c, o, a))) {
                    return this.setCachedResult("hasTransitiveDependency", d, true)
                }
            }
        }
        return this.setCachedResult("hasTransitiveDependency", d, false)
    },
    successorsHaveTransitiveDependency: function(j, k, e, h, b) {
        b = b || {};
        var g = this.buildCacheKey(j, k, e, h, b);
        var c = k instanceof Gnt.model.Task ? k: this.getTaskById(k);
        if (this.isCachedResultAvailable("successorsHaveTransitiveDependency", g)) {
            return this.methodsCache.successorsHaveTransitiveDependency[g]
        }
        for (var f = 0,
        d = c.successors.length; f < d; f++) {
            var a = c.successors[f].getTargetId();
            if (this.hasTransitiveDependency(j, a, e, h) || this.predecessorsHaveTransitiveDependency(j, a, e, h) || this.successorsHaveTransitiveDependency(j, a, e, h, b)) {
                return this.setCachedResult("successorsHaveTransitiveDependency", g, true)
            }
        }
        return this.setCachedResult("successorsHaveTransitiveDependency", g, false)
    },
    predecessorsHaveTransitiveDependency: function(j, k, d, h, a) {
        a = a || {};
        var g = this.buildCacheKey(j, k, d, h, a);
        var b = j instanceof Gnt.model.Task ? j: this.getTaskById(j);
        if (this.isCachedResultAvailable("predecessorsHaveTransitiveDependency", g)) {
            return this.methodsCache.predecessorsHaveTransitiveDependency[g]
        }
        for (var f = 0,
        c = b.predecessors.length; f < c; f++) {
            var e = b.predecessors[f].getSourceId();
            if (this.hasTransitiveDependency(e, k, d, h) || this.successorsHaveTransitiveDependency(e, k, d, h) || this.predecessorsHaveTransitiveDependency(e, k, d, h, a)) {
                return this.setCachedResult("predecessorsHaveTransitiveDependency", g, true)
            }
        }
        return this.setCachedResult("predecessorsHaveTransitiveDependency", g, false)
    },
    isPartOfTransitiveDependency: function(e, c, d, a) {
        var b = e instanceof Gnt.model.Task ? e: this.getTaskById(e);
        if (!b.predecessors.length && !b.successors.length) {
            return false
        }
        if (b.predecessors.length) {
            return this.predecessorsHaveTransitiveDependency.apply(this, arguments)
        } else {
            return this.successorsHaveTransitiveDependency.apply(this, arguments)
        }
    },
    getCycle: function(a) {
        a = a || {};
        Ext.applyIf(a, {
            ignoreTasks: {},
            visitedTasks: {},
            path: [],
            task: this.getAt(0).getSourceTask()
        });
        var f = a.visitedTasks,
        g = a.ignoreTasks,
        k = a.path,
        b = a.task,
        j = b.getInternalId();
        if (g[j]) {
            return
        }
        k.push(b);
        if (f[j]) {
            return k
        }
        f[j] = true;
        var c = b.successors;
        for (var h = 0,
        d = c.length; h < d; h++) {
            a.task = c[h].getTargetTask();
            var e = this.getCycle(a);
            if (e) {
                return e
            }
        }
        k.pop();
        delete f[j]
    },
    getCycles: function() {
        var c = this,
        a = [],
        b = {};
        this.each(function(g) {
            var f = c.getCycle({
                task: g.getSourceTask(),
                ignoreTasks: b
            });
            if (f) {
                for (var e = 0,
                d = f.length; e < d; e++) {
                    b[f[e]] = true
                }
                a.push(f)
            }
        });
        return a
    },
    resetMethodsCache: function() {
        this.methodsCache = {}
    },
    isCachedResultAvailable: function(b, a) {
        return this.methodsCache[b] && this.methodsCache[b].hasOwnProperty(a)
    },
    getCachedResult: function(b, a) {
        return this.methodsCache[b][a]
    },
    setCachedResult: function(c, a, b) {
        this.methodsCache[c] = this.methodsCache[c] || {};
        this.methodsCache[c][a] = b;
        return b
    },
    getGroupTopTasks: function(g, h) {
        var b = g.length,
        f = h.length,
        d = b,
        a = f,
        e, c;
        do {
            e = g[d];
            c = h[a];
            d--;
            a--
        } while ( e == c && d >= 0 && a >= 0 );
        return [e, c]
    },
    groupsHasTransitiveDependency: function(h, c, d, u, b) {
        var q = b || {
            targets: null,
            visitedTasks: {}
        };
        var r = this.getTaskStore().getRootNode(),
        j = false,
        y = this,
        o = this.getTaskById(h),
        A = this.getTaskById(c),
        z = q.visitedTasks,
        x = q.targets;
        if (!q.targetGroup) {
            q.targetGroup = A.getTopParent(true)
        }
        var B = q.fromField || (q.fromField = this.model.prototype.fromField),
        k = q.toField || (q.toField = this.model.prototype.toField),
        n = q.ignoreDepKey,
        a = q.addDepKey;
        var v = this.getGroupTopTasks(o.getTopParent(true), q.targetGroup),
        m = v[0],
        f = v[1];
        if (m === o && f === A && o.isLeaf() && A.isLeaf()) {
            return this.hasTransitiveDependency(h, c, d)
        }
        if (!q.hasOwnProperty("ignoreDepKey")) {
            q.ignoreDepKey = n = d && this.getKeyByDeps(d, B, k) || "";
            q.addDepKey = a = u && this.getKeyByDeps(u, B, k) || ""
        }
        var e = m.getInternalId() + "-" + f.getInternalId() + "-" + n + "-" + a;
        if (this.isCachedResultAvailable("groupsHasTransitiveDependency", e)) {
            return this.methodsCache.groupsHasTransitiveDependency[e]
        }
        if (f !== q.targetTopParent) {
            q.targetTopParent = f;
            x = q.targets = {};
            f.cascadeBy(function(i) {
                x[i.getInternalId()] = true
            })
        }
        var w = q.extraSuccessors;
        if (u && !w) {
            w = q.extraSuccessors = {};
            for (var t = 0,
            p = u.length; t < p; t++) {
                var g = u[t];
                var s = g.getSourceId && g.getSourceId() || g[B];
                w[s] = w[s] || [];
                w[s].push(g)
            }
        }
        m.cascadeBy(function(E) {
            if (E !== r) {
                var H = E.getInternalId();
                if (z[H]) {
                    return false
                }
                z[H] = true;
                var I = E.successors;
                if (w && w[H]) {
                    I = I.concat(w[H])
                }
                for (var G = 0,
                D = I.length; G < D; G++) {
                    var F = I[G],
                    C = F.getTargetId && F.getTargetId() || F[k];
                    if ((!d || Ext.Array.indexOf(d, F) == -1) && (x[C] || y.groupsHasTransitiveDependency(C, c, d, u, q))) {
                        j = true;
                        return false
                    }
                }
            }
        });
        return this.setCachedResult("groupsHasTransitiveDependency", e, j)
    },
    getDependencyError: function(c, a, j, h, l, f) {
        var d, i, e;
        var b = c instanceof Gnt.model.Dependency;
        if (b) {
            d = c.getSourceId();
            i = this.getTaskById(d);
            h = a;
            l = j;
            if (h && Ext.Array.contains(h, c)) {
                h = Ext.Array.slice(h, 0);
                Ext.Array.remove(h, c)
            }
            j = c.getType();
            a = c.getTargetId();
            e = this.getTaskById(a);
            if (c.joined && c.joined.length) {
                f = c
            }
        } else {
            d = c;
            i = this.getTaskById(d);
            e = this.getTaskById(a);
            if (j === undefined) {
                var g = this.model.getField(this.model.prototype.typeField).defaultValue;
                j = g !== undefined ? g: this.model.Type.EndToStart
            }
        }
        if (!f && b && !c.isValid()) {
            return - 1
        } else {
            if (!d || !a || d == a) {
                return - 1
            }
        }
        if (!i || !e) {
            return - 2
        }
        if (!this.isValidDependencyType(j)) {
            return - 10
        }
        if (i.contains(e) || e.contains(i)) {
            return - 9
        }
        var k;
        if (l || f) {
            k = [];
            if (f) {
                k.push(f)
            }
            if (l) {
                k = k.concat(l)
            }
        }
        if (this.transitiveDependencyValidation) {
            if (this.hasTransitiveDependency(d, a, k, h)) {
                return - 3
            }
        } else {
            if (this.areTasksLinkedForward(d, a, k, h)) {
                return - 3
            }
        }
        if (this.hasTransitiveDependency(a, d, k, h)) {
            return - 4
        }
        if (this.transitiveDependencyValidation && this.isPartOfTransitiveDependency(d, a, k, h)) {
            return - 5
        }
        if (this.strictDependencyValidation) {
            if (this.groupsHasTransitiveDependency(e.getInternalId(), i.getInternalId(), k, h)) {
                return - 7
            }
            if (this.transitiveDependencyValidation && this.groupsHasTransitiveDependency(i.getInternalId(), e.getInternalId(), k, h)) {
                return - 8
            }
        }
        if (!this.allowParentTaskDependencies && (!i.isLeaf() || !e.isLeaf())) {
            return - 11
        }
        return 0
    },
    isValidDependencyType: function(c) {
        if (this.allowedDependencyTypes) {
            var a = false,
            b = this.model;
            Ext.each(this.allowedDependencyTypes,
            function(d) {
                if (b.Type[d] == c) {
                    a = true;
                    return false
                }
            });
            return a
        }
        return true
    },
    isValidDependency: function(f, b, d, a, c, e) {
        return ! this.getDependencyError(f, b, d, a, c, e)
    },
    areTasksLinkedForward: function(a, h, p, j) {
        var n = a instanceof Gnt.model.Task ? a: this.getTaskById(a);
        var o = h instanceof Gnt.model.Task ? h: this.getTaskById(h);
        if (!n || !o) {
            return false
        }
        var f = this.model.prototype,
        s = f.fromField,
        g = f.toField;
        var k = n.getInternalId() + "-" + o.getInternalId() + "-" + (this.getKeyByDeps(p, s, g) || "") + "-" + (this.getKeyByDeps(j, s, g) || "");
        if (this.isCachedResultAvailable("areTasksLinkedForward", k)) {
            return this.methodsCache.areTasksLinkedForward[k]
        }
        var c = n.successors,
        b = o.predecessors,
        m, e, d;
        for (e = 0, d = c.length; e < d; e++) {
            m = c[e];
            if ((!p || !Ext.Array.contains(p, m)) && Ext.Array.contains(b, m)) {
                return this.setCachedResult("areTasksLinkedForward", k, true)
            }
        }
        if (j) {
            var r, q;
            for (e = 0, d = j.length; e < d; e++) {
                m = j[e];
                r = m.getSourceId && m.getSourceId() || m[s];
                q = m.getTargetId && m.getTargetId() || m[g];
                if (r == n.getInternalId() && q == o.getInternalId()) {
                    return this.setCachedResult("areTasksLinkedForward", k, true)
                }
            }
        }
        return this.setCachedResult("areTasksLinkedForward", k, false)
    },
    areTasksLinked: function(a, e) {
        var d = a instanceof Gnt.model.Task ? a: this.getTaskById(a);
        var c = e instanceof Gnt.model.Task ? e: this.getTaskById(e);
        if (!d || !c) {
            return false
        }
        var b = d.getInternalId() + "-" + c.getInternalId();
        if (this.isCachedResultAvailable("areTasksLinked", b)) {
            return this.methodsCache.areTasksLinked[b]
        }
        return this.setCachedResult("areTasksLinked", b, this.areTasksLinkedForward(d, c) || this.areTasksLinkedForward(c, d))
    },
    getByTaskIds: function(c, b) {
        var a = this.findBy(function(f) {
            var d = f.getTargetId(),
            e = f.getSourceId();
            if ((e === c && d === b) || (e === b && d === c)) {
                return true
            }
        });
        return this.getAt(a)
    },
    getTaskById: function(c) {
        var b = this.getTaskStore().getNodeById(c);
        if (!b) {
            var a = this.getTaskStore().getRootNode();
            a.cascadeBy(function(d) {
                if (d !== a && d._phantomId == c) {
                    b = d;
                    return false
                }
            })
        }
        return b
    },
    getSourceTask: function(a) {
        var b = a instanceof Gnt.model.Dependency ? a.getSourceId() : a;
        return this.getTaskById(b)
    },
    getTargetTask: function(a) {
        var b = a instanceof Gnt.model.Dependency ? a.getTargetId() : a;
        return this.getTaskById(b)
    },
    getTaskStore: function() {
        return this.taskStore
    }
});
Ext.define("Gnt.data.TaskStore", {
    extend: "Ext.data.TreeStore",
    requires: ["Sch.util.Date", "Gnt.data.Linearizator", "Gnt.model.Task", "Gnt.data.Calendar", "Gnt.data.DependencyStore"],
    mixins: ["Sch.data.mixin.FilterableTreeStore", "Sch.data.mixin.EventStore", "Gnt.data.mixin.ProjectableStore"],
    model: "Gnt.model.Task",
    alias: "store.gantt_taskstore",
    storeId: "tasks",
    proxy: "memory",
    calendarManager: null,
    calendar: null,
    dependencyStore: null,
    resourceStore: null,
    assignmentStore: null,
    weekendsAreWorkdays: false,
    cascadeChanges: true,
    batchSync: true,
    recalculateParents: true,
    skipWeekendsDuringDragDrop: true,
    cascadeDelay: 0,
    moveParentAsGroup: true,
    enableDependenciesForParentTasks: true,
    availabilitySearchLimit: 1825,
    cycleResolutionStrategy: "cut",
    autoNormalizeNodes: true,
    cascading: false,
    isFillingRoot: false,
    isSettingRoot: false,
    earlyStartDates: null,
    earlyEndDates: null,
    lateStartDates: null,
    lateEndDates: null,
    lastTotalTimeSpan: null,
    suspendAutoRecalculateParents: 0,
    suspendAutoCascade: 0,
    currentCascadeBatch: null,
    batchCascadeLevel: 0,
    fillTasksWithDepInfoCounter: 0,
    fillTasksWithAssignmentInfoCounter: 0,
    dependenciesCalendar: "project",
    cachedAssignments: null,
    pendingDataUpdates: null,
    constructor: function(c) {
        c = c || {};
        if (!c.calendar) {
            var f = {};
            if (c.hasOwnProperty("weekendsAreWorkdays")) {
                f.weekendsAreWorkdays = c.weekendsAreWorkdays
            } else {
                if (this.self.prototype.hasOwnProperty("weekendsAreWorkdays") && this.self != Gnt.data.TaskStore) {
                    f.weekendsAreWorkdays = this.weekendsAreWorkdays
                }
            }
            if (c.calendarManager) {
                var g = this,
                b = c.calendarManager,
                i = b.getProjectCalendar();
                if (i) {
                    c.calendar = i
                } else {
                    this.calendarManagerListeners = b.on({
                        projectcalendarset: function(k, l) {
                            g.setCalendar(l, true)
                        },
                        destroyable: true,
                        single: true
                    })
                }
            }
            c.calendar = c.calendar || new Gnt.data.Calendar(f)
        }
        var a = c.dependencyStore || this.dependencyStore || Ext.create("Gnt.data.DependencyStore");
        delete c.dependencyStore;
        var j = c.resourceStore || this.resourceStore || Ext.create("Gnt.data.ResourceStore");
        delete c.resourceStore;
        var e = c.assignmentStore || this.assignmentStore || Ext.create("Gnt.data.AssignmentStore", {
            resourceStore: j
        });
        delete c.assignmentStore;
        var d = c.calendar;
        if (d) {
            delete c.calendar;
            this.setCalendar(d, true, true)
        }
        this.resetEarlyDates(true);
        this.resetLateDates(true);
        this.setDependencyStore(a);
        this.setAssignmentStore(e);
        this.setResourceStore(j);
        this.pendingDataUpdates = {
            recalculateParents: {}
        };
        this.callParent([c]);
        this.on({
            nodeappend: this.onMyNodeAdded,
            nodeinsert: this.onMyNodeAdded,
            update: this.onTaskUpdated,
            scope: this
        });
        this.on({
            noderemove: this.onTaskRemoved,
            nodemove: this.onTaskMoved,
            write: this.onTaskStoreWrite,
            sort: this.onTasksSorted,
            load: this.onTasksLoaded,
            rootchange: this.onTasksLoaded,
            scope: this,
            priority: 100
        });
        this.fillTasksWithDepInfo();
        this.cachedAssignments = this.fillAssignmentsCache();
        var h = this.getRootNode();
        if (h && this.autoNormalizeNodes) {
            h.normalizeParent()
        }
        if (this.autoSync) {
            if (this.batchSync) {
                this.sync = Ext.Function.createBuffered(this.sync, 500)
            } else {
                this.on("beforesync", this.onTaskStoreBeforeSync, this)
            }
        }
        this.initTreeFiltering()
    },
    fillNode: function(b, a) {
        if (b.isRoot()) {
            this.isSettingRoot = true;
            this.cachedAssignments = this.fillAssignmentsCache()
        }
        this.callParent(arguments);
        if (b.isRoot()) {
            this.isSettingRoot = false
        }
    },
    onTasksLoaded: function() {
        var a = this.getRoot();
        this.fillTasksWithDepInfoCounter = 1;
        this.fillTasksWithAssignmentInfoCounter = 1;
        this.fillTasksWithDepInfo();
        this.fillAssignmentsCache();
        if (a && this.autoNormalizeNodes) {
            a.normalizeParent()
        }
    },
    load: function(a) {
        this.un("noderemove", this.onTaskRemoved, this);
        this.un("nodeappend", this.onMyNodeAdded, this);
        this.un("update", this.onTaskUpdated, this);
        this.callParent(arguments);
        this.on("noderemove", this.onTaskRemoved, this);
        this.on("nodeappend", this.onMyNodeAdded, this);
        this.on("update", this.onTaskUpdated, this)
    },
    setRoot: function(a) {
        var d = this;
        var b = this.count() && this.getRoot();
        this.isSettingRoot = true;
        Ext.apply(a, {
            calendar: d.calendar,
            taskStore: d,
            dependencyStore: d.dependencyStore,
            phantom: false,
            dirty: false
        });
        var c = this.callParent(arguments);
        this.isSettingRoot = false;
        b && b.cascadeBy(function(e) {
            e.setTaskStore(null)
        });
        return c
    },
    getDependencyStore: function() {
        return this.dependencyStore
    },
    fillTasksWithDepInfo: function() {
        if (!this.getRootNode()) {
            return
        }
        var a = this.getDependencyStore();
        if (this.fillTasksWithDepInfoCounter++>0) {
            this.forEachTaskUnordered(function(b) {
                b.successors = [];
                b.predecessors = []
            })
        }
        if (a) {
            a.each(function(b) {
                var d = b.getSourceTask(),
                c = b.getTargetTask();
                if (d && c) {
                    d.successors.push(b);
                    c.predecessors.push(b)
                }
            })
        }
    },
    setDependencyStore: function(a) {
        var b = {
            add: this.onDependencyAdd,
            update: this.onDependencyUpdate,
            remove: this.onDependencyDelete,
            scope: this
        };
        if (this.dependencyStore) {
            this.dependencyStore.un(b)
        }
        if (a) {
            this.dependencyStore = Ext.StoreMgr.lookup(a);
            if (a) {
                a.taskStore = this;
                a.on(b);
                this.fillTasksWithDepInfo()
            }
        } else {
            this.dependencyStore = null
        }
    },
    setResourceStore: function(a) {
        if (a) {
            this.resourceStore = Ext.StoreMgr.lookup(a);
            a.taskStore = this;
            a.normalizeResources()
        } else {
            this.resourceStore = null
        }
    },
    getResourceStore: function() {
        return this.resourceStore || null
    },
    fillAssignmentsCache: function() {
        var b = this.getAssignmentStore(),
        a = {};
        if (this.fillTasksWithAssignmentInfoCounter++>0) {
            this.forEachTaskUnordered(function(c) {
                c.assignments = []
            })
        }
        if (b) {
            b.each(function(d) {
                var e = d.getTaskId();
                var c = d.getTask();
                a[e] ? a[e].push(d) : a[e] = [d];
                c && c.assignments.push(d)
            })
        }
        return a
    },
    fillTasksWithAssignmentInfo: function() {
        if (!this.getRootNode()) {
            return
        }
        var a = this.getAssignmentStore();
        if (this.fillTasksWithAssignmentInfoCounter++>0) {
            this.forEachTaskUnordered(function(b) {
                b.assignments = []
            })
        }
        if (a) {
            a.each(function(c) {
                var b = c.getTask();
                b && b.assignments.push(c)
            })
        }
    },
    setAssignmentStore: function(b) {
        var a = {
            add: this.onAssignmentStructureMutation,
            update: this.onAssignmentMutation,
            remove: this.onAssignmentStructureMutation,
            scope: this
        };
        if (this.assignmentStore) {
            this.assignmentStore.un(a)
        }
        if (b) {
            this.assignmentStore = Ext.StoreMgr.lookup(b);
            b.taskStore = this;
            b.on(a);
            this.fillTasksWithAssignmentInfo()
        } else {
            this.assignmentStore = null
        }
    },
    getAssignmentStore: function() {
        return this.assignmentStore || null
    },
    renormalizeTasks: function(b, a, d) {
        var c = this;
        c.resetEarlyDates();
        c.resetLateDates();
        if (a instanceof Gnt.model.Task) {
            a.adjustToCalendar(d)
        } else {
            a = c.getRootNode();
            a && a.propagateChanges(function() {
                a.cascadeBy(function(e) {
                    e.adjustToCalendarWithoutPropagation()
                });
                return a
            },
            d)
        }
    },
    getCalendar: function() {
        return this.calendar || null
    },
    setCalendar: function(e, c, b) {
        var d = {
            calendarchange: this.renormalizeTasks,
            scope: this
        };
        if (this.calendar) {
            this.calendar.un(d)
        }
        this.calendar = e;
        if (e) {
            e.on(d);
            var a = this.getRootNode();
            if (a) {
                a.calendar = e
            }
            if (!c) {
                this.renormalizeTasks()
            }
            if (!b) {
                this.fireEvent("calendarset", this, e)
            }
        }
    },
    getCriticalPaths: function() {
        var b = this.getRootNode(),
        a = [],
        d = new Date(0);
        b.cascadeBy(function(e) {
            d = Sch.util.Date.max(e.getEndDate(), d)
        });
        b.cascadeBy(function(e) {
            if (d - e.getEndDate() === 0 && !e.isRoot() && !(!e.isLeaf() && e.childNodes.length)) {
                a.push(e)
            }
        });
        var c = [];
        Ext.each(a,
        function(e) {
            c.push(e.getCriticalPaths())
        });
        return c
    },
    onMyNodeAdded: function(b, c) {
        if (!c.isRoot()) {
            if (this.lastTotalTimeSpan) {
                var a = this.getTotalTimeSpan();
                if (c.getEndDate() > a.end || c.getStartDate() < a.start) {
                    this.lastTotalTimeSpan = null
                }
            }
            if (c.getEndDate() - this.getProjectEndDate() === 0) {
                this.resetLateDates()
            }
            if (!this.cascading && this.recalculateParents && !this.suspendAutoRecalculateParents) {
                if (this.updating) {
                    this.pendingDataUpdates.recalculateParents[c.getInternalId()] = c
                } else {
                    c.recalculateParents()
                }
            }
        }
    },
    getViolatedConstraints: function(a) {
        var c = this,
        b = 0,
        d = [];
        this.dependencyStore.each(function(f) {
            var h = f.getSourceTask();
            var g = f.getTargetTask();
            if (h && g) {
                var e = g.getViolatedConstraints();
                if (e) {
                    b++;
                    d.push(e)
                }
                if (a && (b >= a)) {
                    return false
                }
            }
        });
        return d
    },
    onTaskUpdated: function(c, b, a) {
        var f = b.previous;
        if (this.lastTotalTimeSpan) {
            var d = this.getTotalTimeSpan();
            if (f && (f[b.endDateField] - d.end === 0 || f[b.startDateField] - d.start === 0) || (b.getEndDate() > d.end || b.getStartDate() < d.start)) {
                this.lastTotalTimeSpan = null
            }
        }
        if (!this.cascading && a !== Ext.data.Model.COMMIT && f) {
            var g = b.percentDoneField in f;
            if (b.startDateField in f || b.endDateField in f || "parentId" in f || b.effortField in f || f[b.schedulingModeField] === "Manual" || f[b.manuallyScheduledField]) {
                var e = b;
                if (this.cascadeChanges && !this.suspendAutoCascade) {
                    if (f[e.schedulingModeField] == "Manual") {
                        var h = e.getIncomingDependencies(true);
                        if (h.length) {
                            e = h[0].getSourceTask()
                        }
                    }
                    Ext.Function.defer(this.cascadeChangesForTask, this.cascadeDelay, this, [e])
                } else {
                    this.resetEarlyDates();
                    this.resetLateDates()
                }
                g = true
            } else {
                if ((f[b.schedulingModeField] || b.manuallyScheduledField in f) && b.isManuallyScheduled()) {
                    this.resetEarlyDates();
                    this.resetLateDates()
                }
            }
            if (g && this.recalculateParents && !this.suspendAutoRecalculateParents) {
                if (this.updating) {
                    this.pendingDataUpdates.recalculateParents[b.getInternalId()] = b
                } else {
                    b.recalculateParents()
                }
            }
        }
    },
    onEndUpdate: function() {
        var b = this,
        d = {},
        a, c;
        Ext.Object.each(b.pendingDataUpdates.recalculateParents,
        function(f, e) {
            e.parentNode && (d[e.parentNode.getInternalId()] = e.parentNode)
        });
        d = Ext.Array.sort(Ext.Object.getValues(d),
        function(f, e) {
            return (f.data.depth > e.data.depth) ? 1 : ((f.data.depth < e.data.depth) ? -1 : 0)
        });
        while (d.length > 0) {
            a = d.pop();
            a.refreshCalculatedParentNodeData();
            a.recalculateParents()
        }
        b.pendingDataUpdates.recalculateParents = {};
        return b.callParent(arguments)
    },
    getEmptyCascadeBatch: function() {
        var a = this;
        return {
            nbrAffected: 0,
            affected: {},
            visitedCounters: {},
            addVisited: function(c) {
                var b = c.internalId;
                if (!this.visitedCounters[b]) {
                    this.visitedCounters[b] = 1
                } else {
                    this.visitedCounters[b]++
                }
            },
            addAffected: function(d, c) {
                var b = d.internalId;
                if (this.affected[b]) {
                    return
                } else {
                    this.affected[b] = d;
                    this.nbrAffected++
                }
                if (!a.cascading && this.nbrAffected > 1) {
                    a.fireEvent("beforecascade", a);
                    a.cascading = true
                }
                if (!c) {
                    var e = this.affectedParentsbyInternalId;
                    var g = this.affectedParentsArray;
                    var f = d.isLeaf() ? d.parentNode: d;
                    while (f && !f.data.root) {
                        if (e[f.internalId]) {
                            break
                        }
                        e[f.internalId] = f;
                        g.push(f);
                        this.addAffected(f, true);
                        f = f.parentNode
                    }
                }
            },
            affectedParentsArray: [],
            affectedParentsbyInternalId: {},
            parentsStartDates: {}
        }
    },
    startBatchCascade: function() {
        if (!this.batchCascadeLevel) {
            this.currentCascadeBatch = this.getEmptyCascadeBatch();
            this.suspendAutoRecalculateParents++;
            this.suspendAutoCascade++
        }
        this.batchCascadeLevel++;
        return this.currentCascadeBatch
    },
    endBatchCascade: function() {
        this.batchCascadeLevel--;
        if (!this.batchCascadeLevel) {
            this.suspendAutoRecalculateParents--;
            this.suspendAutoCascade--;
            var a = this.currentCascadeBatch;
            this.currentCascadeBatch = null;
            this.resetEarlyDates();
            this.resetLateDates();
            if (this.cascading) {
                this.cascading = false;
                this.fireEvent("cascade", this, a)
            }
        }
    },
    cascadeChangesForTask: function(a, b) {
        a.propagateChanges(Ext.emptyFn, b, true)
    },
    removeTaskDependencies: function(a) {
        var b = this.dependencyStore,
        c = a.getAllDependencies(b);
        if (c.length) {
            b.remove(c)
        }
    },
    removeTaskAssignments: function(b) {
        var c = this.getAssignmentStore(),
        a = b.getAssignments();
        if (a.length) {
            c.remove(a)
        }
    },
    onTaskRemoved: function(g, e, h) {
        var a = this.dependencyStore;
        var d = this.getAssignmentStore();
        var i = !e.isReplace && !h;
        if (a && i) {
            e.cascadeBy(this.removeTaskDependencies, this)
        }
        if (d && i) {
            d.fireEvent("beforetaskassignmentschange", d, e.getInternalId(), []);
            e.cascadeBy(this.removeTaskAssignments, this);
            d.fireEvent("taskassignmentschanged", d, e.getInternalId(), [])
        }
        var f = this.getTotalTimeSpan();
        var b = e.getStartDate();
        var c = e.getEndDate();
        if (c - f.end === 0 || b - f.start === 0) {
            this.lastTotalTimeSpan = null
        }
        if (i) {
            e.setTaskStore(null)
        }
        this.resetEarlyDates();
        this.resetLateDates()
    },
    onTaskMoved: function(b, d, f, c) {
        var e = this.getTotalTimeSpan();
        var a = b.getStartDate();
        var g = b.getEndDate();
        if (g - e.end === 0 || a - e.start === 0) {
            this.lastTotalTimeSpan = null
        }
        this.resetEarlyDates();
        this.resetLateDates()
    },
    onAssignmentMutation: function(c, a) {
        var b = this;
        Ext.each(a,
        function(e) {
            var d = e.getTask(b);
            if (d) {
                d.onAssignmentMutation(e)
            }
        })
    },
    onAssignmentStructureMutation: function(c, a) {
        var b = this;
        Ext.each(a,
        function(e) {
            var d = e.getTask(b);
            if (d) {
                d.onAssignmentStructureMutation(e)
            }
        })
    },
    onDependencyUpdate: function(b, c, a) {
        if (a !== Ext.data.Model.COMMIT) {
            this.onDependencyAdd(b, c)
        }
    },
    onDependencyAdd: function(a, c) {
        this.resetEarlyDates();
        this.resetLateDates();
        if (this.cascadeChanges && !this.suspendAutoCascade) {
            var b = this,
            d = [];
            if (Ext.isArray(c)) {
                Ext.Array.forEach(c,
                function(e) {
                    var f = e.getSourceTask();
                    f && d.push(f)
                });
                d.length && b.getRoot().propagateChanges(function() {
                    return d
                })
            } else {
                d = c.getSourceTask();
                d && d.propagateChanges()
            }
        }
    },
    onDependencyDelete: function(a, b) {
        this.resetEarlyDates();
        this.resetLateDates()
    },
    onTaskStoreBeforeSync: function(b, c) {
        var a = b.create;
        if (a) {
            for (var e, d = a.length - 1; d >= 0; d--) {
                e = a[d];
                if (!e.isPersistable()) {
                    Ext.Array.remove(a, e)
                }
            }
            if (a.length === 0) {
                delete b.create
            }
        }
        return Boolean((b.create && b.create.length > 0) || (b.update && b.update.length > 0) || (b.destroy && b.destroy.length > 0))
    },
    onTaskStoreWrite: function(c, b) {
        var e = this.getDependencyStore();
        if (!e || b.action !== "create") {
            return
        }
        var a = b.getRecords(),
        d = this.getAssignmentStore().getNewRecords(),
        h,
        g = this,
        f;
        Ext.each(a,
        function(i) {
            f = i.getId();
            if (!i.phantom && f !== i._phantomId) {
                Ext.each(e.getNewRecords(),
                function(j) {
                    var l = j.getSourceId();
                    var k = j.getTargetId();
                    if (l === i._phantomId) {
                        j.setSourceId(f)
                    } else {
                        if (k === i._phantomId) {
                            j.setTargetId(f)
                        }
                    }
                });
                Ext.each(d,
                function(j) {
                    var k = j.getTaskId();
                    if (k === i._phantomId) {
                        j.setTaskId(f)
                    }
                });
                Ext.each(i.childNodes,
                function(j) {
                    if (j.phantom) {
                        h = true;
                        return false
                    }
                });
                delete i._phantomId
            }
        });
        if (h && !this.autoSync) {
            setTimeout(function() {
                g.sync()
            },
            1)
        }
    },
    forEachTaskUnordered: function(c, b) {
        var a = this.getRootNode();
        if (a) {
            a.cascadeBy(function(d) {
                if (d !== a) {
                    return c.call(b || this, d)
                }
            })
        }
    },
    getTimeSpanForTasks: function(d) {
        var a = new Date(9999, 0, 1),
        b = new Date(0);
        var c = function(f) {
            var e = f.getStartDate();
            var g = f.getEndDate();
            if (e && e < a) {
                a = e
            }
            if (e && g && g > b) {
                b = g
            }
        };
        if (d) {
            if (!Ext.isArray(d)) {
                d = [d]
            }
            Ext.Array.each(d, c)
        } else {
            this.forEachTaskUnordered(c)
        }
        a = a < new Date(9999, 0, 1) ? a: null;
        b = b > new Date(0) ? b: null;
        return {
            start: a,
            end: b || (a && Ext.Date.add(a, Ext.Date.DAY, 1)) || null
        }
    },
    getTotalTimeSpan: function() {
        if (this.lastTotalTimeSpan) {
            return this.lastTotalTimeSpan
        }
        this.lastTotalTimeSpan = this.getTimeSpanForTasks();
        return this.lastTotalTimeSpan
    },
    getProjectStartDate: function() {
        return this.getTotalTimeSpan().start
    },
    getProjectEndDate: function() {
        return this.getTotalTimeSpan().end
    },
    getTotalTaskCount: function(b) {
        var a = b === false ? 1 : 0;
        this.forEachTaskUnordered(function() {
            a++
        });
        return a
    },
    toArray: function() {
        var a = [];
        this.getRootNode().cascadeBy(function(b) {
            a.push(b)
        });
        return a
    },
    indent: function(a) {
        this.fireEvent("beforeindentationchange", this, a);
        a = Ext.isArray(a) ? a.slice() : [a];
        a.sort(function(d, c) {
            return d.data.index - c.data.index
        });
        this.suspendEvents(true);
        Ext.each(a,
        function(b) {
            b.indent()
        });
        this.resumeEvents();
        this.fireEvent("indentationchange", this, a)
    },
    outdent: function(a) {
        this.fireEvent("beforeindentationchange", this, a);
        a = Ext.isArray(a) ? a.slice() : [a];
        a.sort(function(d, c) {
            return c.data.index - d.data.index
        });
        this.suspendEvents(true);
        Ext.each(a,
        function(b) {
            b.outdent()
        });
        this.resumeEvents();
        this.fireEvent("indentationchange", this, a)
    },
    getTasksForResource: function(a) {
        return a.getTasks()
    },
    getEventsForResource: function(a) {
        return this.getTasksForResource(a)
    },
    getByInternalModelId: function(a) {
        return this.byIdMap[a] || this.byInternalIdMap[a]
    },
    forEachScheduledEvent: function(b, a) {
        a = a || this;
        this.forEachTaskUnordered(function(e) {
            var d = e.getStartDate(),
            c = e.getEndDate();
            if (d && c) {
                return b.call(a, e, d, c)
            }
        })
    },
    onTasksSorted: function() {
        if (this.lastTreeFilter) {
            this.filterTreeBy(this.lastTreeFilter)
        }
    },
    append: function(a) {
        this.getRootNode().appendChild(a)
    },
    resetEarlyDates: function(a) {
        this.earlyStartDates = {};
        this.earlyEndDates = {};
        if (!a) {
            this.fireEvent("resetearlydates")
        }
    },
    resetLateDates: function(a) {
        this.lateStartDates = {};
        this.lateEndDates = {};
        if (!a) {
            this.fireEvent("resetlatedates")
        }
    },
    getBySequenceNumber: function(a) {
        return this.getRootNode().getBySequenceNumber(a)
    },
    destroy: function() {
        this.setCalendar(null);
        this.setAssignmentStore(null);
        this.setDependencyStore(null);
        this.setResourceStore(null);
        if (this.calendarManagerListeners) {
            this.calendarManagerListeners.destroy()
        }
        this.callParent(arguments)
    },
    moveSeveralTasks: function(b) {
        var d = this.startBatchCascade();
        var a;
        while (a = b()) {
            var c = a.task;
            if (c.isLeaf() || !c.childNodes.length) {
                if (!d.affected[c.internalId]) {
                    d.addAffected(c);
                    a.method && c[a.method].apply(c, a.args);
                    if (this.cascadeChanges) {
                        this.cascadeChangesForTask(c)
                    }
                }
            } else {
                if (this.recalculateParents) {
                    d.addAffected(c)
                }
            }
        }
        this.endBatchCascade()
    },
    linearWalkDependentTasks: function(d, a, c) {
        var b = this;
        c = c || {
            self: true,
            ancestors: b.recalculateParents,
            descendants: b.moveParentAsGroup,
            successors: b.cascadeChanges,
            cycles: b.cycleResolutionStrategy
        };
        return Gnt.data.Linearizator.linearWalkBySpecification(d, a, c)
    },
    getLinearWalkingSequenceForDependentTasks: function(c, b) {
        var a = [];
        this.linearWalkDependentTasks(c,
        function(f, e, d, g) {
            a.push(Array.prototype.slice.call(arguments))
        },
        b);
        return a
    }
},
function() {
    this.override(Sch.data.mixin.FilterableTreeStore.prototype.inheritables() || {})
});
Ext.define("Gnt.data.ResourceStore", {
    requires: ["Gnt.model.Resource"],
    extend: "Sch.data.ResourceStore",
    model: "Gnt.model.Resource",
    alias: "store.gantt_resourcestore",
    taskStore: null,
    proxy: "memory",
    constructor: function(a) {
        this.callParent([a]);
        this.on({
            load: this.normalizeResources,
            remove: this.onResourceRemoved,
            write: this.onResourceStoreWrite,
            priority: 100
        })
    },
    normalizeResources: function() {
        this.each(function(b) {
            if (!b.normalized) {
                var a = b.getCalendarId();
                if (a) {
                    b.setCalendarId(a, true)
                }
                b.normalized = true
            }
        })
    },
    onResourceRemoved: function(a, c) {
        var b = this.getAssignmentStore();
        Ext.Array.each(c,
        function(d) {
            b.removeAssignmentsForResource(d)
        })
    },
    getTaskStore: function() {
        return this.taskStore || null
    },
    getAssignmentStore: function() {
        return this.assignmentStore = (this.assignmentStore || this.getTaskStore().getAssignmentStore())
    },
    getByInternalId: function(a) {
        return this.data.getByKey(a) || this.getById(a)
    },
    onResourceStoreWrite: function(c, b) {
        if (b.action !== "create") {
            return
        }
        var a = b.getRecords(),
        d = this.getAssignmentStore().getNewRecords(),
        e;
        Ext.each(a,
        function(f) {
            e = f.getId();
            if (!f.phantom && e !== f._phantomId) {
                Ext.each(d,
                function(g) {
                    var h = g.getResourceId();
                    if (h === f._phantomId) {
                        g.setResourceId(e)
                    }
                });
                delete f._phantomId
            }
        })
    }
});
Ext.define("Gnt.data.AssignmentStore", {
    extend: "Ext.data.Store",
    requires: ["Gnt.model.Assignment"],
    model: "Gnt.model.Assignment",
    alias: "store.gantt_assignmentstore",
    proxy: "memory",
    ignoreInitial: true,
    isLoadingRecords: false,
    isRemovingAll: false,
    taskStore: null,
    constructor: function(a) {
        a = a || {};
        this.callParent([a]);
        this.init();
        if (this.autoSync) {
            this.on("beforesync", this.onMyBeforeSync, this)
        }
        this.ignoreInitial = false
    },
    init: function() {
        this.on({
            add: this.onAssignmentAdd,
            update: this.onAssignmentUpdate,
            load: this.onAssignmentsLoad,
            datachanged: this.onAssignmentDataChanged,
            remove: this.onAssignmentRemove,
            priority: 100,
            scope: this
        })
    },
    onAssignmentsLoad: function() {
        var a = this.getTaskStore();
        a && a.fillTasksWithAssignmentInfo()
    },
    onAssignmentDataChanged: function() {
        var a = this.getTaskStore();
        if (a && (this.isLoadingRecords || this.isRemovingAll)) {
            a.fillTasksWithAssignmentInfo()
        }
    },
    removeAll: function() {
        this.isRemovingAll = true;
        this.callParent(arguments);
        this.isRemovingAll = false
    },
    loadRecords: function() {
        this.isLoadingRecords = true;
        this.callParent(arguments);
        this.isLoadingRecords = false
    },
    onAssignmentAdd: function(d, b) {
        if (this.ignoreInitial) {
            return
        }
        for (var c = 0; c < b.length; c++) {
            var e = b[c];
            var a = e.getTask();
            a && a.assignments.push(e)
        }
    },
    onAssignmentRemove: function(c, a) {
        var b = this.getTaskStore();
        if (!b) {
            return
        }
        Ext.Array.each(a,
        function(e) {
            var d = e.getTask(b);
            d && Ext.Array.remove(d.assignments, e)
        })
    },
    onAssignmentUpdate: function(f, g, b) {
        if (b != Ext.data.Model.COMMIT) {
            var c = this.getTaskStore();
            if (!c) {
                return
            }
            var e = g.previous;
            var a = g.getTask();
            if (e && g.taskIdField in e) {
                var d = c.getNodeById(e[g.taskIdField]);
                if (d !== a) {
                    if (d) {
                        Ext.Array.remove(d.assignments, g)
                    }
                    if (a && !Ext.Array.contains(a.assignments, g)) {
                        a.assignments.push(g)
                    }
                }
            }
        }
    },
    getTaskStore: function() {
        return this.taskStore
    },
    getResourceStore: function() {
        return this.getTaskStore().resourceStore
    },
    getByInternalId: function(a) {
        return this.data.getByKey(a) || this.getById(a)
    },
    removeAssignmentsForResource: function(b) {
        var c = b.getId();
        if (c) {
            var a = this.queryBy(function(d) {
                return d.getResourceId() == c
            }).items;
            this.remove(a)
        }
    },
    onMyBeforeSync: function(b, c) {
        var a = b.create;
        if (a) {
            for (var e, d = a.length - 1; d >= 0; d--) {
                e = a[d];
                if (!e.isPersistable()) {
                    Ext.Array.remove(a, e)
                }
            }
            if (a.length === 0) {
                delete b.create
            }
        }
        return Boolean((b.create && b.create.length > 0) || (b.update && b.update.length > 0) || (b.destroy && b.destroy.length > 0))
    }
});
Ext.define("Gnt.data.CrudManager", {
    extend: "Sch.data.CrudManager",
    calendarManager: null,
    taskStore: null,
    dependencyStore: null,
    resourceStore: null,
    assignmentStore: null,
    addRelatedStores: true,
    constructor: function(d) {
        d = d || {};
        var c = d.calendarManager,
        f = d.taskStore,
        e = d.assignmentStore,
        g = d.resourceStore,
        a = d.dependencyStore,
        i = [];
        if (d.addRelatedStores !== false) {
            if (!c && f) {
                c = f instanceof Ext.data.AbstractStore ? f.calendarManager: f.store.calendarManager
            }
            if (!e && f) {
                e = f instanceof Ext.data.AbstractStore ? f.getAssignmentStore() : f.store.getAssignmentStore()
            }
            if (!g && f) {
                g = f instanceof Ext.data.AbstractStore ? f.getResourceStore() : f.store.getResourceStore()
            }
            if (!a && f) {
                a = f instanceof Ext.data.AbstractStore ? f.getDependencyStore() : f.store.getDependencyStore()
            }
        }
        if (c) {
            if (c instanceof Ext.data.AbstractStore) {
                c = {
                    store: c,
                    storeId: c.storeId || "calendars",
                    phantomIdField: "PhantomId"
                }
            }
            if (!c.stores) {
                c.stores = {
                    storeId: "Days",
                    idProperty: "Id"
                }
            }
            this.mixins.observable.constructor.call(this);
            var h = c.store;
            h.on({
                load: function(k) {
                    var m = h.getProjectCalendar(),
                    l = m && m.getCalendarId(),
                    j = h.metaData && h.metaData.projectCalendar;
                    if (l != j) {
                        h.setProjectCalendar(j)
                    }
                }
            });
            this.on({
                beforeloadapply: function() {
                    h.suspendCalendarsEvents()
                },
                load: function() {
                    h.resumeCalendarsEvents()
                }
            });
            delete d.calendarManager;
            this.calendarManager = c;
            i.push(c)
        }
        if (g) {
            if (g instanceof Ext.data.AbstractStore) {
                g = {
                    store: g,
                    storeId: g.storeId || "resources"
                }
            }
            delete d.resourceStore;
            this.resourceStore = g;
            i.push(g)
        }
        if (e) {
            if (e instanceof Ext.data.AbstractStore) {
                e = {
                    store: e,
                    storeId: e.storeId || "assignments"
                }
            }
            delete d.assignmentStore;
            this.assignmentStore = e;
            i.push(e)
        }
        if (a) {
            if (a instanceof Ext.data.AbstractStore) {
                a = {
                    store: a,
                    storeId: a.storeId || "dependencies"
                }
            }
            delete d.dependencyStore;
            this.dependencyStore = a;
            i.push(a)
        }
        if (f) {
            if (f instanceof Ext.data.AbstractStore) {
                f = {
                    store: f,
                    storeId: f.storeId || "tasks",
                    phantomIdField: "PhantomId"
                }
            }
            delete d.taskStore;
            this.taskStore = f;
            i.push(f)
        }
        if (i.length) {
            var b = [];
            if (this.calendarManager) {
                b.push(this.calendarManager)
            }
            if (g) {
                b.push(this.resourceStore)
            }
            if (f) {
                b.push(this.taskStore)
            }
            if (e) {
                b.push(this.assignmentStore)
            }
            if (a) {
                b.push(this.dependencyStore)
            }
            if (b.length) {
                d.syncApplySequence = (d.syncApplySequence || d.stores || []).concat(b)
            }
            d.stores = (d.stores || []).concat(i)
        }
        this.callParent([d])
    },
    getCalendarManager: function() {
        return this.calendarManager && this.calendarManager.store
    },
    getResourceStore: function() {
        return this.resourceStore && this.resourceStore.store
    },
    getDependencyStore: function() {
        return this.dependencyStore && this.dependencyStore.store
    },
    getAssignmentStore: function() {
        return this.assignmentStore && this.assignmentStore.store
    },
    getTaskStore: function() {
        return this.taskStore && this.taskStore.store
    },
    prepareUpdated: function(e, h) {
        if (e[0] instanceof Gnt.model.Task) {
            e = Ext.Array.filter(e,
            function(i) {
                return ! i.isRoot()
            });
            var m = this.callParent([e, h]);
            if (this.resetIdsBeforeSync) {
                var f = e[0].segmentsField,
                c = Ext.ClassManager.get(e[0].segmentClassName).prototype,
                l = c.idProperty,
                k = c.phantomIdField;
                for (var b = 0; b < m.length; b++) {
                    var g = m[b][f];
                    if (g) {
                        for (var a = 0; a < g.length; a++) {
                            var d = g[a];
                            if (d[k]) {
                                delete d[l]
                            }
                        }
                    }
                }
            }
            return m
        }
        return this.callParent([e, h])
    },
    prepareAdded: function(g) {
        var a = this.callParent(arguments);
        if (this.resetIdsBeforeSync && g[0] instanceof Gnt.model.Task) {
            var c = g[0].segmentsField,
            e = Ext.ClassManager.get(g[0].segmentClassName).prototype.idProperty;
            for (var f = 0; f < a.length; f++) {
                var b = a[f][c];
                if (b) {
                    for (var d = 0; d < b.length; d++) {
                        delete b[d][e]
                    }
                }
            }
        }
        return a
    },
    applyChangesToTask: function(e, k) {
        if (k.hasOwnProperty(e.segmentsField)) {
            var d = e.getSegments(),
            h = e.segmentsField,
            m = d && d[0].phantomIdField,
            n = d && d[0].idProperty,
            g = k[h];
            if (g && g.length) {
                for (var c = g.length - 1; c >= 0; c--) {
                    var l = g[c],
                    o = l[m],
                    a = l[n],
                    f = null;
                    for (var b = 0; b < d.length; b++) {
                        f = d[b];
                        if ((f.get(m) == o) || (f.getId() == a)) {
                            this.applyChangesToRecord(f, l);
                            break
                        }
                    }
                }
                delete k[h]
            }
        }
    },
    applyChangesToRecord: function(b, c, a) {
        if (b instanceof Gnt.model.Task) {
            this.ignoreUpdates++;
            this.applyChangesToTask.apply(this, arguments);
            this.ignoreUpdates--
        }
        this.callParent(arguments)
    }
});
Ext.define("Gnt.template.Template", {
    extend: "Ext.XTemplate",
    isLegacyIE: Ext.isIE8m,
    getInnerTpl: Ext.emptyFn,
    innerTpl: null,
    dependencyTerminalMarkup: '<div class="sch-gantt-terminal sch-gantt-terminal-start"></div><div class="sch-gantt-terminal sch-gantt-terminal-end"></div>',
    constructor: function(a) {
        Ext.apply(this, a);
        var c = a.rtl ? "right": "left";
        var b = this.getInnerTpl(a) || "";
        this.callParent(['<div class="sch-event-wrap {ctcls} ' + Ext.baseCSSPrefix + 'unselectable" style="' + c + ':{offset}px">', '<tpl if="isRollup">', b, "<tpl else>", (a.leftLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-left"><label class="sch-gantt-label sch-gantt-label-left">{leftLabel}</label></div>': ""), (a.rightLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-right" style="left:{width}px"><label class="sch-gantt-label sch-gantt-label-right">{rightLabel}</label></div>': ""), (a.topLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-top"><label class="sch-gantt-label sch-gantt-label-top">{topLabel}</label></div>': ""), b, (a.bottomLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-bottom"><label class="sch-gantt-label sch-gantt-label-bottom">{bottomLabel}</label></div>': ""), "</tpl>", "</div>", {
            disableFormats: true
        }])
    }
});
Ext.define("Gnt.template.Task", {
    extend: "Gnt.template.Template",
    innerTpl: '<div class="sch-gantt-progress-bar" style="width:{progressBarWidth}px;{progressBarStyle}" unselectable="on">&#160;</div>',
    getInnerTpl: function(a) {
        var b = a.rtl ? "right": "left";
        return '<div id="' + a.prefix + '{id}" class="sch-gantt-item sch-gantt-task-bar {cls}" unselectable="on" style="width:{width}px;{style}"><tpl if="isRollup"><tpl else><tpl if="segments"><div class="sch-gantt-segment-connector"></div></tpl>' + ((a.resizeHandles === "both" || a.resizeHandles === "left") ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-start"></div>': "") + '<tpl for="segments"><div id="' + a.prefix + '{parent.Id}-segment-{[xindex-1]}" class="sch-gantt-task-segment {cls}" style="left:{left}px;width:{width}px;{style}" data-segmentIndex="{[xindex-1]}">' + this.innerTpl + ((a.resizeHandles === "both" || a.resizeHandles === "right") ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-end"></div>': "") + "</div></tpl>" + this.innerTpl + ((a.resizeHandles === "both" || a.resizeHandles === "right") ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-end"></div>': "") + (a.enableProgressBarResize ? '<div style="' + b + ':{progressBarWidth}px" class="sch-gantt-progressbar-handle"></div>': "") + (a.enableDependencyDragDrop ? this.dependencyTerminalMarkup: "") + "</tpl></div>"
    }
});
Ext.define("Gnt.template.Milestone", {
    extend: "Gnt.template.Template",
    innerTpl: (Ext.isIE8m ? ('<div style="border-width:{[Math.floor(values.side*0.7)]}px;{style}" class="sch-gantt-milestone-diamond-top {cls}" unselectable="on"></div><div style="border-width:{[Math.floor(values.side*0.7)]}px;{style}" class="sch-gantt-milestone-diamond-bottom {cls}" unselectable="on"></div>') : ('<img style="{[values.print ? "height:" + values.side + "px;border-left-width:" + values.side + "px" : ""]};{style}" src="' + Ext.BLANK_IMAGE_URL + '" class="sch-gantt-milestone-diamond {cls}" unselectable="on"/>')),
    getInnerTpl: function(a) {
        return "<div " + (this.isLegacyIE ? 'style="width:{[Math.floor(values.side*0.7)]}px"': "") + ' id="' + a.prefix + '{id}" class="sch-gantt-item sch-gantt-milestone-diamond-ct">' + this.innerTpl + '<tpl if="isRollup"><tpl else>' + (a.enableDependencyDragDrop ? this.dependencyTerminalMarkup: "") + "</tpl></div>"
    }
});
Ext.define("Gnt.template.ParentTask", {
    extend: "Gnt.template.Template",
    innerTpl: '<div class="sch-gantt-progress-bar" style="width:{progressBarWidth}px;{progressBarStyle}">&#160;</div><div class="sch-gantt-parenttask-arrow sch-gantt-parenttask-leftarrow"></div><div class="sch-gantt-parenttask-arrow sch-gantt-parenttask-rightarrow"></div>',
    getInnerTpl: function(a) {
        return '<div id="' + a.prefix + '{id}" class="sch-gantt-item sch-gantt-parenttask-bar {cls}" style="width:{width}px; {style}">' + this.innerTpl + ((a.enableDependencyDragDrop && a.allowParentTaskDependencies) ? this.dependencyTerminalMarkup: "") + "</div>"
    }
});
Ext.define("Gnt.template.RollupTask", {
    extend: "Ext.XTemplate",
    isLegacyIE: Ext.isIE8m,
    tplConfig: null,
    constructor: function(a) {
        Ext.apply(this, a);
        var b = ['<div class="sch-rollup-wrap">', '<tpl for=".">', "{[values.tpl.apply(values)]}", "</tpl>", "</div>"];
        this.tplConfig = Ext.apply(this.tplConfig || {},
        {
            disableFormats: true,
            applyRollup: this.applyRollup
        });
        this.callParent(b.concat([this.tplConfig]))
    }
});
Ext.define("Gnt.Tooltip", {
    extend: "Ext.ToolTip",
    alias: "widget.gantt_task_tooltip",
    requires: ["Ext.Template"],
    mixins: ["Gnt.mixin.Localizable"],
    mode: "startend",
    cls: "sch-tip",
    height: 40,
    autoHide: false,
    anchor: "b-tl",
    maskOnDisable: false,
    startEndTemplate: null,
    durationTemplate: null,
    initComponent: function() {
        this.rtl = this.gantt.rtl;
        if (this.mode === "startend" && !this.startEndTemplate) {
            this.startEndTemplate = new Ext.Template('<div class="sch-timetipwrap {cls}"><table cellpadding="0" cellspacing="0"><tr><td class="sch-gantt-tip-desc">' + this.L("startText") + '</td><td class="sch-gantt-tip-value">{startText}</td></tr><tr><td class="sch-gantt-tip-desc">' + this.L("endText") + '</td><td class="sch-gantt-tip-value">{endText}</td></tr></table></div>').compile()
        }
        if (this.mode === "duration" && !this.durationTemplate) {
            this.durationTemplate = new Ext.Template('<div class="sch-timetipwrap {cls}">', '<table cellpadding="0" cellspacing="0"><tr><td class="sch-gantt-tip-desc">' + this.L("startText") + '</td><td class="sch-gantt-tip-value"> {startText}</td></tr>', '<tr><td class="sch-gantt-tip-desc">' + this.L("durationText") + '</td><td class="sch-gantt-tip-value"> {duration} {unit}</td></tr>', "</table></div>").compile()
        }
        this.callParent(arguments)
    },
    update: function(e, b, d, a) {
        var c;
        if (this.mode === "duration") {
            c = this.getDurationContent(e, b, d, a)
        } else {
            c = this.getStartEndContent(e, b, d, a)
        }
        this.callParent([c])
    },
    getStartEndContent: function(h, b, f, a) {
        var c = this.gantt,
        e = c.getFormattedDate(h),
        d = e;
        if (b - h > 0) {
            d = c.getFormattedEndDate(b, h)
        }
        var g = {
            cls: f ? "sch-tip-ok": "sch-tip-notok",
            startText: e,
            endText: d,
            task: a
        };
        return this.startEndTemplate.apply(g)
    },
    getDurationContent: function(f, b, d, a) {
        var c = a.getDurationUnit() || Sch.util.Date.DAY;
        var e = a.calculateDuration(f, b, c);
        return this.durationTemplate.apply({
            cls: d ? "sch-tip-ok": "sch-tip-notok",
            startText: this.gantt.getFormattedDate(f),
            duration: parseFloat(Ext.Number.toFixed(e, 1)),
            unit: Sch.util.Date.getReadableNameOfUnit(c, e > 1),
            task: a
        })
    },
    show: function(a, b) {
        if (a && (a.dom || a.className)) {
            this.setTarget(a)
        }
        this.callParent([]);
        if (b !== undefined) {
            this.setX(b)
        }
    }
});
Ext.define("Gnt.feature.TaskDragDrop", {
    extend: "Ext.dd.DragZone",
    requires: ["Gnt.Tooltip", "Ext.dd.StatusProxy"],
    useTooltip: true,
    tooltipConfig: null,
    validatorFn: function(a, b, d, c) {
        return true
    },
    validatorFnScope: null,
    showExactDropPosition: false,
    containerScroll: false,
    dropAllowed: "sch-gantt-dragproxy",
    dropNotAllowed: "sch-gantt-dragproxy",
    valid: false,
    gantt: null,
    onDragEnter: Ext.emptyFn,
    onDragOut: Ext.emptyFn,
    tip: null,
    constructor: function(c, b) {
        b = b || {};
        Ext.apply(this, b);
        if (Ext.isIE && (Ext.isIE8 || Ext.ieVersion < 9) && window.top !== window) {
            Ext.dd.DragDropManager.notifyOccluded = true
        }
        this.proxy = this.proxy || new Ext.dd.StatusProxy({
            shadow: false,
            dropAllowed: "sch-gantt-dragproxy",
            dropNotAllowed: "sch-gantt-dragproxy",
            ensureAttachedToBody: Ext.emptyFn
        });
        this.gantt.rtl && this.proxy.addCls("sch-rtl");
        var d = this,
        a = d.gantt;
        if (d.useTooltip) {
            d.tip = new Gnt.Tooltip(Ext.apply({
                cls: "gnt-dragdrop-tip",
                gantt: a
            },
            d.tooltipConfig))
        }
        d.callParent([c, Ext.apply(b, {
            ddGroup: a.id + "-task-dd"
        })]);
        d.scroll = false;
        d.isTarget = true;
        d.ignoreSelf = false;
        d.addInvalidHandleClass("sch-resizable-handle");
        d.addInvalidHandleClass(Ext.baseCSSPrefix + "resizable-handle");
        d.addInvalidHandleClass("sch-gantt-terminal");
        d.addInvalidHandleClass("sch-gantt-progressbar-handle");
        d.addInvalidHandleClass("sch-rollup-task");
        a.ownerCt.el.appendChild(this.proxy.el);
        a.on({
            destroy: d.destroy,
            scope: d
        })
    },
    destroy: function() {
        if (this.tip) {
            this.tip.destroy()
        }
        this.callParent(arguments)
    },
    getDragData: function(s) {
        var q = this.gantt;
        var p = s.getTarget(q.eventSelector);
        if (p && !s.getTarget(".sch-gantt-baseline-item")) {
            var b = s.getTarget(".sch-gantt-task-segment");
            var v = q.resolveTaskRecord(p);
            var f;
            var r, d, j;
            if (b) {
                f = parseInt(b.getAttribute("data-segmentIndex"), 10);
                if (f === 0) {
                    r = p
                } else {
                    r = b
                }
            } else {
                r = p
            }
            var w = v.isMilestone(),
            i;
            if (f > 0) {
                v = v.getSegment(f)
            }
            if (q.fireEvent("beforetaskdrag", q, v, s) === false) {
                return null
            }
            var a = s.getXY();
            var o = r.cloneNode(true),
            t = this.showExactDropPosition ? 0 : q.getSnapPixelAmount(),
            m = Ext.fly(r).getXY();
            var c = [a[0] - m[0], a[1] - m[1]];
            o.id = Ext.id();
            var l = Ext.fly(r).getHeight();
            var n = Ext.fly(r).getWidth();
            var u = 0;
            Ext.fly(o).setHeight(l - u);
            if (Ext.isIE8m && w) {
                Ext.fly(o).setSize(l + 5, l + 5)
            }
            if (!q.rtl) {
                o.style.left = -c[0] + "px"
            } else {
                o.style.left = n - c[0] + "px"
            }
            if (f > 0) {
                var k = v.getPrevSegment();
                var h = v.getNextSegment();
                d = Sch.util.Date.max(k.getEndDate(), q.timeAxis.getStart());
                j = h ? Sch.util.Date.min(h.getStartDate(), q.timeAxis.getEnd()) : q.timeAxis.getEnd();
                i = {
                    left: q.getCoordinateFromDate(d, false) + c[0],
                    right: q.getCoordinateFromDate(j, false) - n + c[0]
                }
            } else {
                i = Ext.fly(q.findItemByChild(r)).getRegion()
            }
            this.constrainTo(i, Ext.fly(r).getRegion(), c[0], c[1]);
            this.valid = false;
            if (t >= 1) {
                this.setXConstraint(this.leftConstraint, this.rightConstraint, t)
            }
            return {
                sourceNode: r,
                repairXY: m,
                offsets: c,
                ddel: o,
                record: v,
                duration: Sch.util.Date.getDurationInMinutes(v.getStartDate(), v.getEndDate()),
                sourceDate: q.getDateFromCoordinate(a[0]),
                minDate: d,
                maxDate: j,
                origStart: v.getStartDate(),
                start: null
            }
        }
        return null
    },
    autoOffset: function(a, b) {
        this.setDelta(0, 0)
    },
    setXConstraint: function(c, b, a) {
        this.leftConstraint = c;
        this.rightConstraint = b;
        this.minX = c;
        this.maxX = b;
        if (a) {
            this.setXTicks(this.initPageX, a)
        }
        this.constrainX = true
    },
    setYConstraint: function(a, c, b) {
        this.topConstraint = a;
        this.bottomConstraint = c;
        this.minY = a;
        this.maxY = c;
        if (b) {
            this.setYTicks(this.initPageY, b)
        }
        this.constrainY = true
    },
    constrainTo: function(b, c, a, d) {
        this.resetConstraints();
        this.initPageX = b.left + a;
        this.initPageY = c.top + d;
        this.setXConstraint(b.left, b.right, this.xTickSize);
        this.setYConstraint(c.top - 1, c.top - 1, this.yTickSize)
    },
    onDragOver: function(m) {
        var i = this.dragData,
        c = i.record,
        d = this.gantt;
        if (!i.hidden) {
            Ext.fly(i.sourceNode).hide();
            i.hidden = true
        }
        var a = d.getDateFromCoordinate(m.getXY()[0]) - i.sourceDate;
        var o = new Date(i.origStart - 0 + a);
        var g = this.proxy.el;
        var j;
        if (i.minDate) {
            o = Sch.util.Date.constrain(new Date(i.origStart - 0 + a), i.minDate, i.maxDate)
        }
        if (d.timeAxis.isContinuous()) {
            j = d.timeAxis.roundDate(o, d.snapRelativeToEventStartDate ? i.origStart: false)
        } else {
            var n = g.getX() + (d.rtl ? g.getWidth() : 0) + d.getXOffset(c) - i.offsets[0];
            j = d.getDateFromXY([n, 0], "round")
        }
        if (this.showExactDropPosition && d.taskStore.skipWeekendsDuringDragDrop) {
            var b = Ext.fly(i.ddel.id);
            var k = 0;
            var l = c.skipNonWorkingTime(j, !c.isMilestone());
            if (o.getTime() != l.getTime()) {
                k = d.timeAxisViewModel.getDistanceBetweenDates(o, l)
            }
            var f = c.recalculateEndDate(l);
            if (o > d.timeAxis.getStart()) {
                b.setWidth(d.timeAxisViewModel.getDistanceBetweenDates(l, Sch.util.Date.min(f, d.timeAxis.getEnd())));
                if (k) {
                    g.setX(g.getX() + k)
                }
            }
        }
        if (!j || j - i.start === 0) {
            return
        }
        i.start = j;
        this.valid = this.validatorFn.call(this.validatorFnScope || d, c, j, i.duration, m) !== false;
        if (this.tip) {
            var h = c.calculateEndDate(j, c.getDuration(), c.getDurationUnit());
            this.updateTip(c, j, h, this.valid)
        }
    },
    startDrag: function() {
        var a = Ext.dd.ScrollManager;
        this.gantt.el.ddScrollConfig = {
            increment: a.increment,
            hthresh: a.hthresh,
            vthresh: -1
        };
        return this.callParent(arguments)
    },
    endDrag: function() {
        delete this.gantt.el.ddScrollConfig;
        return this.callParent(arguments)
    },
    onStartDrag: function() {
        var b = this.dragData.record;
        var a = this.tip;
        if (a) {
            a.enable();
            a.show(this.proxy.el);
            this.updateTip(b, b.getStartDate(), b.getEndDate())
        }
        this.gantt.fireEvent("taskdragstart", this.gantt, b)
    },
    updateTip: function(b, d, a, c) {
        c = c !== false;
        if (b.isMilestone() && d - Ext.Date.clearTime(d, true) === 0) {
            d = Sch.util.Date.add(d, Sch.util.Date.MILLI, -1);
            a = Sch.util.Date.add(a, Sch.util.Date.MILLI, -1)
        }
        this.tip.update(d, a, c, b)
    },
    afterRepair: function() {
        Ext.fly(this.dragData.sourceNode).show();
        if (this.tip) {
            this.tip.hide()
        }
        this.dragging = false
    },
    getRepairXY: function() {
        this.gantt.fireEvent("aftertaskdrop", this.gantt);
        return this.dragData.repairXY
    },
    onDragDrop: function(g, a) {
        var i = this,
        h = i.cachedTarget || Ext.dd.DragDropMgr.getDDById(a),
        f = i.dragData,
        d = i.gantt,
        c = f.record,
        b = f.start,
        j = true;
        f.ddCallbackArgs = [h, g, a];
        if (this.tip) {
            this.tip.disable()
        }
        if (this.valid && b && c.getStartDate() - b !== 0) {
            f.finalize = function() {
                i.finalize.apply(i, arguments)
            };
            j = d.fireEvent("beforetaskdropfinalize", d, f, g) !== false
        }
        if (j) {
            this.finalize(this.valid)
        }
    },
    finalize: function(c) {
        var e = this,
        f = this.dragData,
        b = this.gantt,
        a = f.record,
        h = f.start,
        d, g;
        if (c) {
            d = a.getStartDate();
            a.setStartDate(h, true, b.taskStore.skipWeekendsDuringDragDrop,
            function(j, i) {
                g = a.getStartDate();
                if (d < g || d > g) {
                    b.fireEvent("taskdrop", b, a);
                    if (Ext.isIE9) {
                        e.proxy.el.setStyle("visibility", "hidden");
                        Ext.Function.defer(e.onValidDrop, 10, e, f.ddCallbackArgs)
                    } else {
                        e.onValidDrop.apply(e, f.ddCallbackArgs)
                    }
                } else {
                    e.onInvalidDrop.apply(e, f.ddCallbackArgs)
                }
                b.fireEvent("aftertaskdrop", b, a)
            })
        } else {
            e.onInvalidDrop.apply(e, f.ddCallbackArgs);
            b.fireEvent("aftertaskdrop", b, a)
        }
    },
    onInvalidDrop: function(b, a, c) {
        if (Ext.isIE && !a) {
            a = b;
            b = b.getTarget() || document.body
        }
        return this.callParent([b, a, c])
    }
});
Ext.define("Gnt.feature.DependencyDragZone", {
    extend: "Ext.dd.DragZone",
    mixins: {
        observable: "Ext.util.Observable"
    },
    rtl: null,
    useLineProxy: null,
    terminalSelector: null,
    ganttView: null,
    fromText: null,
    toText: null,
    startText: null,
    endText: null,
    toolTipTpl: null,
    constructor: function(b, a) {
        this.mixins.observable.constructor.call(this, a);
        this.callParent(arguments)
    },
    initLineProxy: function(c, b) {
        var e = this.lineProxyEl = this.lineProxyEl || this.el.createChild({
            cls: "sch-gantt-connector-proxy"
        });
        var f = Ext.isIE9m ? 0 : 4;
        var d = this.rtl ? (b ? "r": "l") : (b ? "l": "r");
        var a = this.ganttView.getScroll();
        e.alignTo(c, d, [b ? -f: f, 0]);
        Ext.apply(this, {
            containerTop: this.el.getTop(),
            containerLeft: this.el.getLeft(),
            startXY: e.getXY(),
            startScrollLeft: a.left,
            startScrollTop: a.top
        })
    },
    onDrag: function(b, a) {
        if (this.useLineProxy) {
            this.updateLineProxy(b.getXY())
        }
    },
    updateLineProxy: function(n) {
        var a = this.lineProxyEl,
        k = this.ganttView.getScroll(),
        j = n[0] - this.startXY[0] + k.left - this.startScrollLeft,
        i = n[1] - this.startXY[1] + k.top - this.startScrollTop,
        b = Math.max(1, Math.sqrt(Math.pow(j, 2) + Math.pow(i, 2)) - 2),
        h = Math.atan2(i, j) - (Math.PI / 2),
        e;
        if (Ext.isIE9m) {
            var l = Math.cos(h),
            g = Math.sin(h),
            m = 'progid:DXImageTransform.Microsoft.Matrix(sizingMethod="auto expand", M11 = ' + l + ", M12 = " + ( - g) + ", M21 = " + g + ", M22 = " + l + ")",
            d,
            f;
            if (k.top !== this.startScrollTop) {
                d = this.startScrollTop - this.containerTop
            } else {
                d = k.top - this.containerTop
            }
            if (k.left !== this.startScrollLeft) {
                f = this.startScrollLeft - this.containerLeft
            } else {
                f = k.left - this.containerLeft
            }
            e = {
                height: b + "px",
                top: Math.min(0, i) + this.startXY[1] + d + (i < 0 ? 2 : 0) + "px",
                left: Math.min(0, j) + this.startXY[0] + f + (j < 0 ? 2 : 0) + "px",
                filter: m,
                "-ms-filter": m
            }
        } else {
            var c = "rotate(" + h + "rad)";
            e = {
                height: b + "px",
                "-o-transform": c,
                "-webkit-transform": c,
                "-ms-transform": c,
                "-moz-transform": c,
                transform: c
            }
        }
        a.setStyle(e)
    },
    onStartDrag: function() {
        this.el.addCls("sch-gantt-dep-dd-dragging");
        this.proxy.el.addCls("sch-dd-dependency-proxy");
        this.fireEvent("dndstart", this);
        if (this.useLineProxy) {
            var a = this.dragData;
            this.initLineProxy(a.sourceNode, a.isStart);
            this.lineProxyEl.show()
        }
    },
    getDragData: function(f) {
        var d = f.getTarget(this.terminalSelector);
        if (d) {
            var c = this.ganttView.resolveTaskRecord(d);
            if (this.fireEvent("beforednd", this, c) === false) {
                return null
            }
            var b = !!d.className.match("sch-gantt-terminal-start");
            var a = {
                fromLabel: this.fromText,
                fromTaskName: Ext.String.htmlEncode(c.getName()),
                fromSide: b ? this.startText: this.endText,
                toLabel: this.toText,
                toTaskName: "",
                toSide: ""
            };
            var g = Ext.core.DomHelper.createDom({
                html: this.toolTipTpl.apply(a)
            }).firstChild;
            return {
                fromId: c.getId() || c.internalId,
                tplData: a,
                isStart: b,
                repairXY: Ext.fly(d).getXY(),
                ddel: g,
                sourceNode: Ext.fly(d).up(this.ganttView.eventSelector)
            }
        }
        return false
    },
    afterRepair: function() {
        this.el.removeCls("sch-gantt-dep-dd-dragging");
        this.dragging = false;
        this.fireEvent("afterdnd", this)
    },
    onMouseUp: function() {
        this.el.removeCls("sch-gantt-dep-dd-dragging");
        if (this.lineProxyEl) {
            var b = Ext.isIE9m ? 0 : 400;
            var a = this.lineProxyEl;
            a.animate({
                to: {
                    height: 0
                },
                duration: b,
                callback: function() {
                    Ext.destroy(a)
                }
            });
            this.lineProxyEl = null
        }
    },
    getRepairXY: function() {
        return this.dragData.repairXY
    },
    destroy: function() {
        Ext.destroy(this.lineProxyEl);
        this.callParent(arguments)
    }
});
Ext.define("Gnt.feature.DependencyDropZone", {
    extend: "Ext.dd.DropZone",
    mixins: {
        observable: "Ext.util.Observable"
    },
    terminalSelector: null,
    dependencyStore: null,
    toText: null,
    startText: null,
    endText: null,
    ganttView: null,
    constructor: function(b, a) {
        this.mixins.observable.constructor.call(this, a);
        this.callParent(arguments)
    },
    getTargetFromEvent: function(a) {
        return a.getTarget(this.terminalSelector)
    },
    onNodeEnter: function(d, a, c, b) {
        Ext.fly(d).addCls("sch-gantt-terminal-drophover")
    },
    onNodeOut: function(d, a, c, b) {
        Ext.fly(d).removeCls("sch-gantt-terminal-drophover");
        this.toolTipTpl.overwrite(a.proxy.el.down(".sch-dd-dependency"), b.tplData)
    },
    onNodeOver: function(d, j, f, c) {
        var a = this.ganttView.resolveTaskRecord(d),
        i = a.getId() || a.internalId,
        b = d.className.match("sch-gantt-terminal-start");
        var h = {};
        Ext.apply(h, {
            toLabel: this.toText,
            toTaskName: Ext.String.htmlEncode(a.getName()),
            toSide: b ? this.startText: this.endText
        },
        c.tplData);
        this.toolTipTpl.overwrite(j.proxy.el.down(".sch-dd-dependency"), h);
        var g = this.resolveType(c.isStart, d);
        if (this.dependencyStore.isValidDependency(c.fromId, i, g)) {
            return this.dropAllowed
        } else {
            return this.dropNotAllowed
        }
    },
    onNodeDrop: function(i, a, h, f) {
        var d = this.resolveType(f.isStart, i),
        g,
        c = this.ganttView.resolveTaskRecord(i),
        b = c.getId() || c.internalId;
        this.el.removeCls("sch-gantt-dep-dd-dragging");
        g = this.dependencyStore.isValidDependency(f.fromId, b, d);
        if (g) {
            this.fireEvent("drop", this, f.fromId, b, d)
        }
        this.fireEvent("afterdnd", this);
        return g
    },
    resolveType: function(a, d) {
        var c = Gnt.model.Dependency.Type,
        b = d.className.match("sch-gantt-terminal-start");
        if (a && b) {
            return c.StartToStart
        }
        if (a && !b) {
            return c.StartToEnd
        }
        if (!a && b) {
            return c.EndToStart
        }
        return c.EndToEnd
    }
});
Ext.define("Gnt.feature.DependencyDragDrop", {
    extend: "Ext.util.Observable",
    mixins: {
        localizable: "Gnt.mixin.Localizable"
    },
    requires: ["Gnt.feature.DependencyDragZone", "Gnt.feature.DependencyDropZone", "Ext.XTemplate"],
    useLineProxy: true,
    dragZoneConfig: null,
    dropZoneConfig: null,
    toolTipTpl: ['<div class="sch-dd-dependency">', "<table><tbody>", "<tr>", '<td><span class="sch-dd-dependency-from">{fromLabel}:</span></td>', '<td><span class="sch-dd-dependency-from-name">{fromTaskName}</span> - {fromSide}</td>', "</tr>", "<tr>", '<td><span class="sch-dd-dependency-to">{toLabel}:</span></td>', '<td><span class="sch-dd-dependency-to-name">{toTaskName}</span> - {toSide}</td>', "</tr>", "</tbody></table>", "</div>"],
    terminalSelector: ".sch-gantt-terminal",
    el: null,
    rtl: null,
    ddGroup: null,
    ganttView: null,
    dependencyStore: null,
    constructor: function(b) {
        var a = b.ganttView;
        Ext.apply(this, b);
        this.ddGroup = a.id + "-sch-dependency-dd";
        this.el.on("mousemove", this.doSetup, this, {
            single: true
        });
        this.callParent(arguments)
    },
    doSetup: function() {
        var a = this;
        this.dragZone = new Gnt.feature.DependencyDragZone(this.el, Ext.apply({
            rtl: this.rtl,
            terminalSelector: this.terminalSelector,
            useLineProxy: this.useLineProxy,
            ddGroup: this.ddGroup,
            ganttView: this.ganttView,
            startText: this.L("startText"),
            endText: this.L("endText"),
            fromText: this.L("fromText"),
            toText: this.L("toText"),
            toolTipTpl: Ext.XTemplate.getTpl(this, "toolTipTpl")
        },
        this.dragZoneConfig));
        this.relayEvents(this.dragZone, ["beforednd", "dndstart", "afterdnd"]);
        this.dropZone = Ext.create("Gnt.feature.DependencyDropZone", this.el, Ext.apply({
            rtl: this.rtl,
            terminalSelector: this.terminalSelector,
            ddGroup: this.ddGroup,
            ganttView: this.ganttView,
            dependencyStore: this.dependencyStore,
            startText: this.L("startText"),
            endText: this.L("endText"),
            toText: this.L("toText"),
            toolTipTpl: Ext.XTemplate.getTpl(this, "toolTipTpl")
        },
        this.dropZoneConfig));
        this.relayEvents(this.dropZone, ["drop", "afterdnd"]);
        this.configureAllowedSourceTerminals();
        if (this.dependencyStore.allowedDependencyTypes) {
            this.dragZone.on("dndstart", this.configureAllowedTargetTerminals, this)
        } else {
            this.el.addCls(["sch-gantt-terminal-allow-target-start", "sch-gantt-terminal-allow-target-end"])
        }
    },
    configureAllowedSourceTerminals: function() {
        var b = this.dependencyStore.allowedDependencyTypes;
        var a = ["sch-gantt-terminal-allow-source-start", "sch-gantt-terminal-allow-source-end"];
        if (b) {
            a = [];
            if (Ext.Array.indexOf(b, "EndToEnd") > -1 || Ext.Array.indexOf(b, "EndToStart") > -1) {
                a.push("sch-gantt-terminal-allow-source-end")
            }
            if (Ext.Array.indexOf(b, "StartToStart") > -1 || Ext.Array.indexOf(b, "StartToEnd") > -1) {
                a.push("sch-gantt-terminal-allow-source-start")
            }
        }
        this.el.addCls(a)
    },
    configureAllowedTargetTerminals: function() {
        var b = this.dependencyStore.allowedDependencyTypes;
        var a = [];
        this.el.removeCls(["sch-gantt-terminal-allow-target-start", "sch-gantt-terminal-allow-target-end"]);
        if (Ext.Array.contains(b, "EndToEnd") || Ext.Array.contains(b, "StartToEnd")) {
            a.push("sch-gantt-terminal-allow-target-end")
        }
        if (Ext.Array.contains(b, "StartToStart") || Ext.Array.contains(b, "EndToStart")) {
            a.push("sch-gantt-terminal-allow-target-start")
        }
        this.el.addCls(a)
    },
    destroy: function() {
        if (this.dragZone) {
            this.dragZone.destroy()
        }
        if (this.dropZone) {
            this.dropZone.destroy()
        }
    }
});
Ext.define("Gnt.feature.DragCreator", {
    requires: ["Ext.Template", "Sch.util.DragTracker", "Gnt.Tooltip"],
    constructor: function(a) {
        Ext.apply(this, a || {});
        this.init()
    },
    disabled: false,
    showDragTip: true,
    tooltipConfig: null,
    dragTolerance: 2,
    validatorFn: Ext.emptyFn,
    validatorFnScope: null,
    setDisabled: function(a) {
        this.disabled = a;
        if (this.dragTip) {
            this.dragTip.setDisabled(a)
        }
    },
    getProxy: function() {
        if (!this.proxy) {
            this.proxy = this.template.append(this.ganttView.ownerCt.el, {},
            true)
        }
        return this.proxy
    },
    onBeforeDragStart: function(f) {
        var c = this.ganttView,
        b = f.getTarget("." + c.timeCellCls, 2);
        if (b) {
            var a = c.resolveTaskRecord(b);
            var d = c.getDateFromDomEvent(f);
            if (!this.disabled && b && !a.getStartDate() && !a.getEndDate() && c.fireEvent("beforedragcreate", c, a, d, f) !== false) {
                f.stopEvent();
                this.record = a;
                this.originalStart = d;
                this.rowRegion = c.getScheduleRegion(this.record, this.originalStart);
                this.dateConstraints = c.getDateConstraints(this.resourceRecord, this.originalStart);
                return true
            }
        }
        return false
    },
    onDragStart: function() {
        var c = this,
        a = c.ganttView,
        b = c.getProxy();
        c.start = c.originalStart;
        c.end = c.start;
        c.rowBoundaries = {
            top: c.rowRegion.top,
            bottom: c.rowRegion.bottom
        };
        b.setBox({
            top: c.rowBoundaries.top,
            right: c.tracker.startXY[0],
            bottom: c.rowBoundaries.bottom,
            left: c.tracker.startXY[0]
        });
        b.show();
        c.ganttView.fireEvent("dragcreatestart", c.ganttView);
        if (c.showDragTip) {
            c.dragTip.update(c.start, c.end, true, this.record);
            c.dragTip.enable();
            c.dragTip.show(b)
        }
    },
    onDrag: function(g) {
        var d = this,
        c = d.ganttView,
        b = d.tracker.getRegion().constrainTo(d.rowRegion),
        f = c.getStartEndDatesFromRegion(b, "round");
        if (!f) {
            return
        }
        d.start = f.start || d.start;
        d.end = f.end || d.end;
        var a = d.dateConstraints;
        if (a) {
            d.end = Sch.util.Date.constrain(d.end, a.start, a.end);
            d.start = Sch.util.Date.constrain(d.start, a.start, a.end)
        }
        d.valid = this.validatorFn.call(d.validatorFnScope || d, this.record, d.start, d.end, g) !== false;
        if (d.showDragTip) {
            d.dragTip.update(d.start, d.end, d.valid, this.record)
        }
        Ext.apply(b, d.rowBoundaries);
        this.getProxy().setBox(b)
    },
    onDragEnd: function(d) {
        var c = this,
        a = c.ganttView,
        b = false;
        c.createContext = {
            start: c.start,
            end: c.end,
            e: d,
            record: c.record,
            finalize: function() {
                c.finalize.apply(c, arguments)
            }
        };
        if (c.showDragTip) {
            c.dragTip.disable()
        }
        if (!c.start || !c.end || (c.end < c.start)) {
            c.valid = false
        }
        if (c.valid) {
            b = a.fireEvent("beforedragcreatefinalize", c, c.createContext, d) !== false
        }
        if (b) {
            c.finalize(c.valid)
        }
    },
    finalize: function(b) {
        var d = this,
        c = d.createContext,
        a = d.ganttView;
        if (b) {
            c.record.setStartEndDate(c.start, c.end, c.record.getTaskStore().skipWeekendsDuringDragDrop);
            a.fireEvent("dragcreateend", a, c.record, c.e)
        }
        d.proxy.hide();
        a.fireEvent("afterdragcreate", a)
    },
    init: function() {
        var c = this.ganttView,
        a = c.el,
        b = Ext.Function.bind;
        this.lastTime = new Date();
        this.template = this.template || Ext.create("Ext.Template", '<div class="sch-gantt-dragcreator-proxy"></div>', {
            compiled: true,
            disableFormats: true
        });
        c.on({
            destroy: this.onGanttDestroy,
            scope: this
        });
        this.tracker = new Sch.util.DragTracker({
            el: a,
            tolerance: this.dragTolerance,
            onBeforeStart: b(this.onBeforeDragStart, this),
            onStart: b(this.onDragStart, this),
            onDrag: b(this.onDrag, this),
            onEnd: b(this.onDragEnd, this)
        });
        if (this.showDragTip) {
            this.dragTip = new Gnt.Tooltip(Ext.apply({
                mode: "duration",
                cls: "sch-gantt-dragcreate-tip",
                gantt: c
            },
            this.tooltipConfig))
        }
    },
    onGanttDestroy: function() {
        if (this.dragTip) {
            this.dragTip.destroy()
        }
        if (this.tracker) {
            this.tracker.destroy()
        }
        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null
        }
    }
});
Ext.define("Gnt.feature.LabelEditor", {
    extend: "Ext.Editor",
    labelPosition: "",
    constructor: function(b, a) {
        this.ganttView = b;
        this.ganttView.on("afterrender", this.onGanttRender, this);
        Ext.apply(this, a);
        if (this.labelPosition === "left") {
            this.alignment = "r-r"
        } else {
            if (this.labelPosition === "right") {
                this.alignment = "l-l"
            }
        }
        this.delegate = ".sch-gantt-label-" + this.labelPosition;
        this.callParent([a])
    },
    edit: function(c) {
        var a = this.ganttView.getElementFromEventRecord(c);
        if (a) {
            var e = a.up(this.ganttView.eventWrapSelector);
            var d, b;
            this.record = c;
            if (!this.rendered) {
                this.render(this.ganttView.getSecondaryCanvasEl())
            }
            if (Ext.isIE) {
                d = this.ganttView.up("panel");
                b = d.handleFocusEnter;
                d.handleFocusEnter = Ext.emptyFn
            }
            this.startEdit(e.down(this.delegate), this.dataIndex ? c.get(this.dataIndex) : "");
            if (Ext.isIE) {
                d.handleFocusEnter = b
            }
        }
    },
    triggerEvent: "dblclick",
    delegate: null,
    dataIndex: null,
    shadow: false,
    completeOnEnter: true,
    cancelOnEsc: true,
    ignoreNoChange: true,
    onGanttRender: function(a) {
        if (!this.field.width) {
            this.autoSize = "width"
        }
        this.on({
            beforestartedit: function(c, b, d) {
                return a.fireEvent("labeledit_beforestartedit", a, this.record, d, c)
            },
            beforecomplete: function(c, d, b) {
                return a.fireEvent("labeledit_beforecomplete", a, d, b, this.record, c)
            },
            complete: function(c, d, b) {
                this.record.set(this.dataIndex, d);
                a.fireEvent("labeledit_complete", a, d, b, this.record, c)
            },
            scope: this
        });
        a.el.on(this.triggerEvent,
        function(c, b) {
            this.edit(a.resolveTaskRecord(b))
        },
        this, {
            delegate: this.delegate
        })
    }
});
Ext.define("Gnt.feature.ProgressBarResize", {
    requires: ["Ext.ToolTip", "Ext.resizer.Resizer"],
    constructor: function(a) {
        Ext.apply(this, a || {});
        var b = this.ganttView;
        b.on({
            destroy: this.cleanUp,
            scope: this
        });
        b.el.on("mousedown", this.onMouseDown, this, {
            delegate: ".sch-gantt-progressbar-handle"
        });
        this.callParent(arguments)
    },
    useTooltip: true,
    increment: 10,
    tip: null,
    resizable: null,
    ganttView: null,
    onMouseDown: function(d, b) {
        var c = this.ganttView,
        f = c.resolveTaskRecord(b);
        if (c.fireEvent("beforeprogressbarresize", c, f) !== false) {
            var a = Ext.fly(b).prev(".sch-gantt-progress-bar");
            d.stopEvent();
            a.addCls("active");
            this.resizable = this.createResizable(a, f, d);
            c.fireEvent("progressbarresizestart", c, f);
            Ext.getBody().on("mouseup", this.onBodyMouseUp, this, {
                single: true,
                delay: 1
            })
        }
    },
    createResizable: function(b, g, d) {
        var i = d.getTarget(),
        h = this.ganttView.rtl,
        f = b.up(this.ganttView.eventSelector),
        j = f.getWidth() - 2 * this.ganttView.eventBorderWidth,
        c = j * this.increment / 100;
        var a = Ext.create("Ext.resizer.Resizer", {
            target: b,
            taskRecord: g,
            handles: h ? "w": "e",
            minWidth: 0,
            maxWidth: j,
            minHeight: 1,
            widthIncrement: c,
            listeners: {
                resizedrag: this.partialResize,
                resize: this.afterResize,
                scope: this
            }
        });
        a.resizeTracker.onMouseDown(d, a[h ? "west": "east"].dom);
        f.addCls("sch-gantt-resizing");
        if (this.useTooltip) {
            this.tip = Ext.create("Ext.ToolTip", {
                autoHide: false,
                anchor: "b",
                html: "%"
            });
            this.tip.setTarget(b);
            this.tip.update(g.getPercentDone() + "%");
            this.tip.show()
        }
        return a
    },
    partialResize: function(c, b) {
        var a = Math.round(b * 100 / (c.maxWidth * this.increment)) * this.increment;
        if (this.tip) {
            this.tip.body.update(a + "%")
        }
    },
    afterResize: function(f, b, c, g) {
        var i = f.taskRecord;
        if (this.tip) {
            this.tip.destroy();
            this.tip = null
        }
        var a = f.taskRecord.getPercentDone();
        if (Ext.isNumber(b)) {
            var d = Math.round(b * 100 / (f.maxWidth * this.increment)) * this.increment;
            f.taskRecord.setPercentDone(d)
        }
        if (a === f.taskRecord.getPercentDone()) {
            this.ganttView.refreshNode(this.ganttView.indexOf(f.taskRecord))
        }
        f.destroy();
        this.resizable = null;
        this.ganttView.fireEvent("afterprogressbarresize", this.ganttView, i)
    },
    onBodyMouseUp: function() {
        if (this.resizable) {
            this.afterResize(this.resizable)
        }
    },
    cleanUp: function() {
        if (this.tip) {
            this.tip.destroy()
        }
    }
});
Ext.define("Gnt.feature.TaskResize", {
    requires: ["Ext.resizer.Resizer", "Gnt.Tooltip"],
    constructor: function(a) {
        Ext.apply(this, a);
        var b = this.ganttView;
        b.on({
            destroy: this.cleanUp,
            scope: this
        });
        b.mon(b.el, "mousedown", this.onMouseDown, this, {
            delegate: ".sch-resizable-handle"
        });
        this.callParent(arguments)
    },
    showDuration: true,
    showExactResizePosition: false,
    useTooltip: true,
    tooltipConfig: null,
    validatorFn: Ext.emptyFn,
    validatorFnScope: null,
    taskRec: null,
    taskEl: null,
    isStart: null,
    ganttView: null,
    resizable: null,
    onMouseDown: function(g, d) {
        var c = this.ganttView;
        var h = g.getTarget(".sch-gantt-task-segment");
        var b = g.getTarget(c.eventSelector);
        var a = c.resolveTaskRecord(b);
        if (h) {
            b = h;
            a = a.getSegment(parseInt(h.getAttribute("data-segmentIndex"), 10))
        }
        var f = a.isResizable();
        if (g.button !== 0 || f === false || typeof f === "string" && !b.className.match(f)) {
            return
        }
        if (c.fireEvent("beforetaskresize", c, a, g) === false) {
            return
        }
        g.stopEvent();
        this.taskEl = Ext.get(b);
        this.taskRec = a;
        this.isStart = !!d.className.match("sch-resizable-handle-start");
        c.el.on({
            mousemove: this.onMouseMove,
            mouseup: this.onMouseUp,
            scope: this,
            single: true
        })
    },
    onMouseMove: function(j, p) {
        var h = this.ganttView,
        f = this.taskRec,
        l = this.taskEl,
        m = h.rtl,
        a = this.isStart,
        d = (m && !a) || (!m && a),
        c = h.getSnapPixelAmount(),
        b = l.getWidth(),
        o,
        n;
        c = Math.max(1, c);
        var i = {
            otherEdgeX: d ? l.getRight() : l.getLeft(),
            target: l,
            record: f,
            isStart: a,
            isWest: d,
            handles: d ? "w": "e",
            minHeight: 1,
            minWidth: c,
            widthIncrement: c,
            listeners: {
                resizedrag: this.partialResize,
                resize: this.afterResize,
                scope: this
            }
        };
        if (f instanceof Gnt.model.TaskSegment && (n = this.taskEl.next(".sch-gantt-task-segment"))) {
            i.maxWidth = m ? n.getRight() - l.getRight() : n.getLeft() - l.getLeft()
        }
        i.constrainRegion = l.up(h.getItemSelector()).getRegion();
        l.addCls("sch-gantt-resizing");
        this.ganttView.fireEvent("taskresizestart", this.ganttView, this.taskRec);
        var k = l.down(".sch-gantt-progress-bar");
        if (k) {
            k.setWidth(100 * k.getWidth() / l.getWidth() + "%")
        }
        this.resizable = Ext.create("Ext.resizer.Resizer", i);
        this.resizable.resizeTracker.onMouseDown(j, this.resizable[d ? "west": "east"].dom);
        if (this.useTooltip) {
            if (!this.tip) {
                this.tip = Ext.create("Gnt.Tooltip", Ext.apply({
                    mode: this.showDuration ? "duration": "startend",
                    gantt: this.ganttView
                },
                this.tooltipConfig))
            }
            this.tip.show(l, j.getX() - 15);
            this.tip.update(f.getStartDate(), f.getEndDate(), true, f);
            Ext.getBody().on("mouseup",
            function() {
                this.tip.hide()
            },
            this, {
                single: true
            })
        }
    },
    onMouseUp: function(c, a) {
        var b = this.ganttView;
        b.el.un({
            mousemove: this.onMouseMove,
            scope: this,
            single: true
        })
    },
    partialResize: function(k, j, l, p) {
        var h = this.ganttView,
        f = k.isWest,
        o = k.record,
        g;
        if (f) {
            g = h.getDateFromCoordinate(k.otherEdgeX - Math.min(j, this.resizable.maxWidth), !this.showExactResizePosition ? "round": null)
        } else {
            g = h.getDateFromCoordinate(k.otherEdgeX + Math.min(j, this.resizable.maxWidth), !this.showExactResizePosition ? "round": null)
        }
        if (!g || k.date - g === 0) {
            return
        }
        var b, a, d;
        if (this.showExactResizePosition) {
            var n = h.timeAxis.roundDate(g, h.snapRelativeToEventStartDate ? o.getStartDate() : false);
            n = o.skipNonWorkingTime(n, !o.isMilestone());
            var s = k.target.el,
            c;
            if (f) {
                b = o.skipNonWorkingTime(n, !o.isMilestone());
                d = b;
                c = h.timeAxisViewModel.getDistanceBetweenDates(b, o.getEndDate());
                s.setWidth(c);
                var q = h.timeAxisViewModel.getDistanceBetweenDates(g, b);
                s.setX(s.getX() + q)
            } else {
                var r = Gnt.util.Data.cloneModelSet([o])[0];
                var i = o.getTaskStore();
                r.setTaskStore(i);
                r.setCalendar(o.getCalendar());
                r.setEndDateWithoutPropagation(n, false, i.skipWeekendsDuringDragDrop);
                a = r.getEndDate();
                d = a;
                c = h.timeAxisViewModel.getDistanceBetweenDates(o.getStartDate(), a);
                s.setWidth(c)
            }
        } else {
            b = k.isStart ? g: k.record.getStartDate();
            a = k.isStart ? k.record.getEndDate() : g;
            d = g
        }
        k.date = d;
        h.fireEvent("partialtaskresize", h, o, b, a, k.el, p);
        if (this.useTooltip) {
            var m = this.validatorFn.call(this.validatorFnScope || this, o, b, a) !== false;
            this.tip.update(b, a, m, o)
        }
    },
    afterResize: function(n, l, d, i) {
        if (this.useTooltip) {
            this.tip.hide()
        }
        var j = this,
        f = n.record,
        c = f.getStartDate(),
        o = f.getEndDate(),
        a = n.isStart ? n.date: c,
        b = n.isStart ? o: n.date,
        g = j.ganttView,
        m = false,
        k = true;
        j.resizeContext = {
            record: f,
            start: a,
            end: b,
            oldStart: f.getStartDate(),
            finalize: function() {
                j.finalize.apply(j, arguments)
            }
        };
        if (a && b && (a - c || b - o) && j.validatorFn.call(j.validatorFnScope || j, f, a, b, i) !== false) {
            k = g.fireEvent("beforetaskresizefinalize", j, j.resizeContext, i) !== false;
            m = true
        } else {
            g.refreshKeepingScroll()
        }
        if (k) {
            j.finalize(m)
        }
    },
    finalize: function(i) {
        var e = this,
        g = e.ganttView,
        c = e.resizeContext,
        d = c.record,
        a = d.task || d,
        b = g.taskStore.skipWeekendsDuringDragDrop,
        f, h;
        if (i) {
            if (c.start - c.oldStart !== 0) {
                f = d.getStartDate();
                h = c.start <= c.end ? c.start: c.end;
                d.setStartDate(h, false, b,
                function(k, j) {
                    h = d.getStartDate();
                    if (! (h < f || h > f)) {
                        g.refreshNode(g.store.indexOf(a))
                    }
                    g.fireEvent("aftertaskresize", g, a, e.isStart)
                })
            } else {
                f = d.getEndDate();
                h = c.start <= c.end ? c.end: c.start;
                d.setEndDate(h, false, b,
                function(k, j) {
                    h = d.getEndDate();
                    if (! (h < f || h > f)) {
                        g.refreshNode(g.store.indexOf(a))
                    }
                    g.fireEvent("aftertaskresize", g, a, e.isStart)
                })
            }
        } else {
            g.refreshNode(g.store.indexOf(a));
            g.fireEvent("aftertaskresize", g, a, e.isStart)
        }
        e.resizable.destroy();
        e.resizeContext = null
    },
    cleanUp: function() {
        if (this.tip) {
            this.tip.destroy()
        }
    }
});
Ext.define("Gnt.feature.WorkingTime", {
    extend: "Sch.plugin.Zones",
    requires: ["Ext.data.Store", "Sch.model.Range"],
    expandToFitView: true,
    calendar: null,
    init: function(a) {
        if (!this.calendar) {
            Ext.Error.raise("Required attribute 'calendar' missed during initialization of 'Gnt.feature.WorkingTime'")
        }
        this.bindCalendar(this.calendar);
        Ext.apply(this, {
            store: new Ext.data.Store({
                model: "Sch.model.Range"
            })
        });
        this.callParent(arguments);
        a.on("viewchange", this.onViewChange, this);
        this.onViewChange()
    },
    bindCalendar: function(b) {
        var a = {
            datachanged: this.refresh,
            update: this.refresh,
            scope: this,
            delay: 1
        };
        if (this.calendar) {
            this.calendar.un(a)
        }
        if (b) {
            b.on(a)
        }
        this.calendar = b
    },
    onViewChange: function() {
        var a = Sch.util.Date;
        if (a.compareUnits(this.timeAxis.unit, a.WEEK) > 0) {
            this.setDisabled(true)
        } else {
            this.setDisabled(false);
            this.refresh()
        }
    },
    refresh: function() {
        var a = this.schedulerView;
        this.store.removeAll(true);
        this.store.add(this.calendar.getHolidaysRanges(a.timeAxis.getStart(), a.timeAxis.getEnd(), true))
    },
    destroy: function() {
        this.bindCalendar(null);
        this.callParent(arguments)
    }
});
Ext.define("Gnt.plugin.DependencyEditor", {
    extend: "Ext.form.Panel",
    alias: "plugin.gantt_dependencyeditor",
    ptype: "gantt_dependencyeditor",
    mixins: ["Ext.AbstractPlugin", "Gnt.mixin.Localizable"],
    lockableScope: "top",
    header: false,
    requires: ["Ext.util.Filter", "Ext.form.field.Display", "Ext.form.field.ComboBox", "Ext.form.field.Number", "Gnt.model.Dependency", "Ext.data.ArrayStore"],
    hideOnBlur: true,
    showLag: false,
    border: false,
    width: 260,
    frame: true,
    labelWidth: 60,
    triggerEvent: "dependencydblclick",
    constrain: false,
    initComponent: function() {
        Ext.apply(this, {
            defaults: {
                width: 240
            },
            floating: true,
            hideMode: "offsets"
        });
        this.callParent(arguments);
        this.addCls("sch-gantt-dependencyeditor")
    },
    getState: function() {
        if (this.rendered) {
            return this.callParent(arguments)
        }
    },
    init: function(a) {
        a.on(this.triggerEvent, this.onDependencyDblClick, this);
        a.on("afterrender", this.onGanttRender, this, {
            delay: 50
        });
        this.gantt = a;
        this.taskStore = a.getTaskStore();
        this.add(this.buildFields())
    },
    onGanttRender: function() {
        this.render(Ext.getBody());
        this.collapse(Ext.Component.DIRECTION_TOP, true);
        this.hide();
        if (this.hideOnBlur) {
            this.on({
                show: function() {
                    this.mon(Ext.getBody(), {
                        click: this.onMouseClick,
                        scope: this
                    })
                },
                hide: function() {
                    this.mun(Ext.getBody(), {
                        click: this.onMouseClick,
                        scope: this
                    })
                },
                delay: 50
            })
        }
    },
    show: function(b, c) {
        this.dependencyRecord = b;
        this.getForm().loadRecord(b);
        this.fromLabel.setValue(Ext.String.htmlEncode(this.dependencyRecord.getSourceTask().getName()));
        this.toLabel.setValue(Ext.String.htmlEncode(this.dependencyRecord.getTargetTask().getName()));
        if (this.typeField) {
            var a = this.taskStore && this.taskStore.getDependencyStore(),
            d = a && a.allowedDependencyTypes;
            this.typeField.store.filter();
            this.typeField.setReadOnly(d && d.length < 2)
        }
        this.callParent([]);
        this.el.setXY(c);
        this.expand(!this.constrain);
        if (this.constrain) {
            this.doConstrain(Ext.util.Region.getRegion(Ext.getBody()))
        }
    },
    buildFields: function() {
        var c = this,
        b = this.taskStore && this.taskStore.getDependencyStore(),
        d = Gnt.model.Dependency;
        var a = [this.fromLabel = new Ext.form.DisplayField({
            fieldLabel: this.L("fromText")
        }), this.toLabel = new Ext.form.DisplayField({
            fieldLabel: this.L("toText")
        }), this.typeField = this.buildTypeField()];
        if (this.showLag) {
            a.push(this.lagField = new Ext.form.NumberField({
                name: b ? b.model.prototype.lagField: d.prototype.lagField,
                fieldLabel: this.L("lagText")
            }))
        }
        return a
    },
    onDependencyDblClick: function(c, a, d, b) {
        if (a != this.dependencyRecord) {
            this.show(a, d.getXY())
        }
    },
    filterAllowedTypes: function(b) {
        var c = this.taskStore && this.taskStore.getDependencyStore();
        if (!c || !c.allowedDependencyTypes) {
            return true
        }
        var f = c.allowedDependencyTypes;
        var g = c.model.Type;
        for (var d = 0,
        a = f.length; d < a; d++) {
            var e = g[f[d]];
            if (b.getId() == e) {
                return true
            }
        }
        return false
    },
    buildTypeField: function() {
        var b = this.taskStore ? this.taskStore.getDependencyStore().model: Gnt.model.Dependency;
        var c = b.Type;
        this.typesFilter = new Ext.util.Filter({
            filterFn: this.filterAllowedTypes,
            scope: this
        });
        var a = new Ext.data.ArrayStore({
            fields: [{
                name: "id",
                type: "int"
            },
            "text"],
            data: [[c.EndToStart, this.L("endToStartText")], [c.StartToStart, this.L("startToStartText")], [c.EndToEnd, this.L("endToEndText")], [c.StartToEnd, this.L("startToEndText")]]
        });
        a.filter(this.typesFilter);
        return new Ext.form.field.ComboBox({
            name: b.prototype.typeField,
            fieldLabel: this.L("typeText"),
            triggerAction: "all",
            queryMode: "local",
            editable: false,
            valueField: "id",
            displayField: "text",
            store: a
        })
    },
    onMouseClick: function(a) {
        if (this.collapsed || a.within(this.getEl()) || a.getTarget("." + Ext.baseCSSPrefix + "layer") || a.getTarget(".sch-ignore-click")) {
            return
        }
        this.collapse()
    },
    afterCollapse: function() {
        delete this.dependencyRecord;
        this.hide();
        this.callParent(arguments);
        if (this.hideOnBlur) {
            this.mun(Ext.getBody(), "click", this.onMouseClick, this)
        }
    }
});
Ext.define("Gnt.plugin.TaskContextMenu", {
    extend: "Ext.menu.Menu",
    alias: "plugin.gantt_taskcontextmenu",
    ptype: "gantt_taskcontextmenu",
    mixins: ["Ext.AbstractPlugin", "Gnt.mixin.Localizable"],
    lockableScope: "top",
    requires: ["Gnt.model.Dependency", "Gnt.model.Task"],
    plain: true,
    triggerEvent: ["itemcontextmenu", "containercontextmenu"],
    grid: null,
    rec: null,
    triggerEventXY: null,
    lastHighlightedItem: null,
    taskEditorInjected: false,
    getState: function() {
        if (this.rendered) {
            return this.callParent(arguments)
        }
    },
    createMenuItems: function() {
        return [{
            handler: this.deleteTask,
            requiresTask: true,
            itemId: "deleteTask",
            text: this.L("deleteTask")
        },
        {
            handler: this.editLeftLabel,
            requiresTask: true,
            itemId: "editLeftLabel",
            text: this.L("editLeftLabel")
        },
        {
            handler: this.editRightLabel,
            requiresTask: true,
            itemId: "editRightLabel",
            text: this.L("editRightLabel")
        },
        {
            handler: this.toggleMilestone,
            requiresTask: true,
            itemId: "toggleMilestone",
            text: this.L("convertToMilestone")
        },
        {
            handler: this.splitTask,
            requiresTask: true,
            itemId: "splitTask",
            isValidAction: function(b, a) {
                return b && !b.isMilestone() && b.isLeaf() && a && a.getTarget(".sch-gantt-task-bar")
            },
            text: this.L("splitTask")
        },
        {
            text: this.L("add"),
            itemId: "addTaskMenu",
            menu: {
                plain: true,
                defaults: {
                    scope: this
                },
                items: [{
                    handler: this.addTaskAboveAction,
                    requiresTask: true,
                    itemId: "addTaskAbove",
                    text: this.L("addTaskAbove")
                },
                {
                    handler: this.addTaskBelowAction,
                    itemId: "addTaskBelow",
                    text: this.L("addTaskBelow")
                },
                {
                    handler: this.addMilestone,
                    itemId: "addMilestone",
                    requiresTask: true,
                    text: this.L("addMilestone")
                },
                {
                    handler: this.addSubtask,
                    requiresTask: true,
                    itemId: "addSubtask",
                    text: this.L("addSubtask")
                },
                {
                    handler: this.addSuccessor,
                    requiresTask: true,
                    itemId: "addSuccessor",
                    text: this.L("addSuccessor")
                },
                {
                    handler: this.addPredecessor,
                    requiresTask: true,
                    itemId: "addPredecessor",
                    text: this.L("addPredecessor")
                }]
            }
        },
        {
            text: this.L("deleteDependency"),
            requiresTask: true,
            itemId: "deleteDependencyMenu",
            isValidAction: function(a) {
                return a && a.getAllDependencies().length > 0
            },
            menu: {
                plain: true,
                listeners: {
                    beforeshow: this.populateDependencyMenu,
                    mouseover: this.onDependencyMouseOver,
                    mouseleave: this.onDependencyMouseOut,
                    scope: this
                }
            }
        }]
    },
    buildMenuItems: function() {
        this.items = this.createMenuItems()
    },
    initComponent: function() {
        this.defaults = this.defaults || {};
        this.defaults.scope = this;
        this.buildMenuItems();
        this.callParent(arguments)
    },
    init: function(a) {
        this.grid = a;
        this.bindTriggerEvents()
    },
    bindTriggerEvents: function() {
        var c = this.triggerEvent,
        b = this.grid || this.getCmp();
        if (!Ext.isArray(c)) {
            c = [c]
        }
        for (var a = c.length - 1; a >= 0; a--) {
            b.on(c[a], this.onTriggerEvent, this)
        }
    },
    populateDependencyMenu: function(f) {
        if (f.up("menuitem").isDisabled()) {
            return
        }
        var d = this.grid,
        b = d.getTaskStore(),
        e = this.rec.getAllDependencies(),
        a = d.dependencyStore;
        f.removeAll();
        if (e.length === 0) {
            return false
        }
        var c = this.rec.getId() || this.rec.internalId;
        Ext.each(e,
        function(i) {
            var h = i.getSourceId(),
            g = b.getNodeById(h == c ? i.getTargetId() : h);
            if (g) {
                f.add({
                    depId: i.internalId,
                    text: Ext.util.Format.ellipsis(Ext.String.htmlEncode(g.getName()), 30),
                    scope: this,
                    handler: function(k) {
                        var j;
                        a.each(function(l) {
                            if (l.internalId == k.depId) {
                                j = l;
                                return false
                            }
                        });
                        a.remove(j)
                    }
                })
            }
        },
        this)
    },
    onDependencyMouseOver: function(d, a, b) {
        if (a) {
            var c = this.grid.getSchedulingView();
            if (this.lastHighlightedItem) {
                c.unhighlightDependency(this.lastHighlightedItem.depId)
            }
            this.lastHighlightedItem = a;
            c.highlightDependency(a.depId)
        }
    },
    onDependencyMouseOut: function(b, a) {
        if (this.lastHighlightedItem) {
            this.grid.getSchedulingView().unhighlightDependency(this.lastHighlightedItem.depId)
        }
    },
    onTriggerEvent: function() {
        var a = this.getTriggerEventContext.apply(this, arguments);
        this.activateMenu(a.record, a.e)
    },
    getTriggerEventContext: function() {
        var a = {};
        for (var c = 0,
        b = arguments.length - 1; c <= b; c++) {
            if (arguments[c] instanceof Gnt.model.Task) {
                a.record = arguments[c];
                break
            }
        }
        for (c = arguments.length - 1; c >= 0; c--) {
            if (arguments[c] instanceof Ext.EventObjectImpl) {
                a.e = arguments[c];
                break
            }
        }
        return a
    },
    activateMenu: function(b, a) {
        if (this.grid.isReadOnly() || this.grid.taskStore.getRootNode() === b) {
            return
        }
        a.stopEvent();
        this.rec = b;
        this.triggerEventXY = a.getXY();
        this.configureMenuItems(a);
        this.showAt(a.getXY());
        this.focus()
    },
    configureMenuItems: function(a) {
        if (this.grid.taskEditor && !this.taskEditorInjected) {
            this.insert(0, {
                text: this.L("taskInformation"),
                requiresTask: true,
                handler: function() {
                    this.grid.taskEditor.showTask(this.rec)
                },
                scope: this
            });
            this.taskEditorInjected = true
        }
        var b = this.rec;
        Ext.each(this.query("menuitem"),
        function(d) {
            if (d.requiresTask) {
                d.setDisabled(!b)
            }
            if (d.isValidAction) {
                d.setDisabled(!d.isValidAction(b, a))
            }
        });
        var c = this.down("#toggleMilestone");
        if (b && c) {
            c.setText(b.isMilestone() ? this.L("convertToRegular") : this.L("convertToMilestone"))
        }
    },
    copyTask: function(c) {
        var b = this.grid.getTaskStore().model;
        var a = new b({
            leaf: true
        });
        a.setPercentDone(0);
        a.setName(this.L("newTaskText", this.texts));
        a.set(a.startDateField, (c && c.getStartDate()) || null);
        a.set(a.endDateField, (c && c.getEndDate()) || null);
        a.set(a.durationField, (c && c.getDuration()) || null);
        a.set(a.durationUnitField, (c && c.getDurationUnit()) || "d");
        return a
    },
    addTaskAbove: function(a) {
        var b = this.rec;
        if (b) {
            b.addTaskAbove(a)
        } else {
            this.grid.taskStore.getRootNode().appendChild(a)
        }
    },
    addTaskBelow: function(a) {
        var b = this.rec;
        if (b) {
            b.addTaskBelow(a)
        } else {
            this.grid.taskStore.getRootNode().appendChild(a)
        }
    },
    deleteTask: function() {
        var a = this.grid.getSelectionModel();
        a.selected.each(function(b) {
            b.parentNode ? b.parentNode.removeSubtask(b) : b.remove()
        })
    },
    editLeftLabel: function() {
        this.grid.getSchedulingView().editLeftLabel(this.rec)
    },
    editRightLabel: function() {
        this.grid.getSchedulingView().editRightLabel(this.rec)
    },
    addTaskAboveAction: function() {
        this.addTaskAbove(this.copyTask(this.rec))
    },
    addTaskBelowAction: function() {
        this.addTaskBelow(this.copyTask(this.rec))
    },
    addSubtask: function() {
        var a = this.rec;
        a.addSubtask(this.copyTask(a))
    },
    addSuccessor: function() {
        var a = this.rec;
        a.addSuccessor(this.copyTask(a))
    },
    addPredecessor: function() {
        var a = this.rec;
        a.addPredecessor(this.copyTask(a))
    },
    addMilestone: function() {
        var b = this.rec,
        a = this.copyTask(b);
        b.addTaskBelow(a);
        a.setStartEndDate(b.getEndDate(), b.getEndDate())
    },
    toggleMilestone: function() {
        if (this.rec.isMilestone()) {
            this.rec.convertToRegular()
        } else {
            this.rec.convertToMilestone()
        }
    },
    splitTask: function() {
        var c = this.rec;
        var b = this.grid.getSchedulingView(),
        a = Ext.Date.clearTime(b.getDateFromX(this.triggerEventXY[0]), true),
        d = b.timeAxis.roundDate(a, b.snapRelativeToEventStartDate ? c.getStartDate() : false);
        c.split(d)
    }
});
Ext.define("Gnt.plugin.exporter.mixin.DependencyPainter", {
    taskBoxes: null,
    dependencyPainter: null,
    dependenciesHtml: "",
    ganttView: null,
    initDependencyPainter: function() {
        var a = this;
        a.dependencyPainter = a.normalView.dependencyView.painter;
        a.ganttView = a.dependencyPainter.ganttView;
        a.taskBoxes = {}
    },
    getLineCoordinates: function() {
        var a = this;
        return a.dependencyPainter.getLineCoordinates.apply(a.dependencyPainter, arguments)
    },
    renderDependencies: function(b) {
        var a = this;
        a.dependenciesHtml = a.normalView.dependencyView.lineTpl.apply(a.getDependencyTplData(b))
    },
    fillTaskBox: function(b) {
        var c = this,
        a = c.normalView.dependencyView.painter;
        if (b.hasIncomingDependencies() || b.hasOutgoingDependencies()) {
            c.taskBoxes[b.getId()] = a.getTaskBox(b)
        }
    },
    getRenderData: function(c) {
        var d = this,
        b = c.getSourceTask(),
        a = c.getTargetTask();
        if (b && a) {
            return {
                fromBox: d.taskBoxes[b.getId()],
                toBox: d.taskBoxes[a.getId()]
            }
        }
    },
    getDependencyTplData: function(a) {
        a = a || this.normalView.dependencyView.store.getRange();
        return this.dependencyPainter.getDependencyTplData.call(this, a)
    }
});
Ext.define("Gnt.plugin.exporter.MultiPage", {
    extend: "Sch.plugin.exporter.MultiPage",
    mixins: ["Gnt.plugin.exporter.mixin.DependencyPainter"],
    depsTopOffset: 0,
    normalGridOffset: 0,
    collectNormalRow: function(c, a) {
        var b = this,
        d = b.callParent(arguments);
        b.fillTaskBox(d.record);
        return d
    },
    setComponent: function() {
        var a = this;
        a.callParent(arguments);
        a.initDependencyPainter()
    },
    onRowsCollected: function() {
        var a = this;
        a.renderDependencies();
        a.depsTopOffset = 0;
        a.normalGridOffset = 0;
        a.callParent(arguments)
    },
    commitPage: function(a) {
        var b = this;
        b.callParent(arguments);
        b.depsTopOffset -= a.rowsHeight
    },
    startPage: function(c, a) {
        var b = this;
        b.normalGridOffset = c.normalGridOffset;
        if (a) {
            b.depsTopOffset = 0
        }
        b.callParent(arguments)
    },
    buildPageFrame: function(a, c) {
        var b = this;
        var d = b.callParent(arguments);
        d.normalHidden = b.normalGrid.hidden;
        d.lockedHidden = b.lockedGrid.hidden;
        return d
    },
    preparePageToCommit: function() {
        var h = this,
        j = h.callParent(arguments),
        e = j.select(".sch-dependencyview-ct").first(),
        a = j.select("." + Ext.baseCSSPrefix + "splitter").first(),
        i = h.pageFrames[h.columnPageIndex - 1],
        c = function(m) {
            var l = j.select("#" + m).first();
            return l && l.dom
        };
        if (a) {
            if (i.lockedHidden) {
                a.hide()
            } else {
                a.setHeight("100%")
            }
        }
        if (!i.normalHidden) {
            e.dom.innerHTML = h.dependenciesHtml;
            e.applyStyles({
                top: h.depsTopOffset + "px"
            });
            var g = h.normalGrid,
            b = g.getView().id;
            var d = c(b);
            if (d) {
                var f = g.el.down(h.tableSelector).getWidth();
                d.style.width = f + "px";
                d.style.overflow = "hidden"
            }
        }
        if (!i.lockedHidden) {
            var k = c(h.lockedView.id);
            if (k) {
                k.style.overflow = "hidden"
            }
        }
        return j
    }
});
Ext.define("Gnt.plugin.exporter.MultiPageVertical", {
    extend: "Sch.plugin.exporter.MultiPageVertical",
    mixins: ["Gnt.plugin.exporter.mixin.DependencyPainter"],
    depsTopOffset: 0,
    collectNormalRow: function(c, a) {
        var b = this,
        d = b.callParent(arguments);
        b.fillTaskBox(d.record);
        return d
    },
    setComponent: function() {
        var a = this;
        a.callParent(arguments);
        a.initDependencyPainter()
    },
    onRowsCollected: function() {
        var a = this;
        a.renderDependencies();
        a.depsTopOffset = 0;
        a.callParent(arguments)
    },
    commitPage: function(a) {
        var b = this;
        b.callParent(arguments);
        b.depsTopOffset -= a.rowsHeight
    },
    preparePageToCommit: function() {
        var h = this,
        i = h.callParent(arguments),
        e = i.select(".sch-dependencyview-ct").first(),
        a = i.select("." + Ext.baseCSSPrefix + "splitter").first(),
        c = function(l) {
            var k = i.select("#" + l).first();
            return k && k.dom
        };
        e.dom.innerHTML = h.dependenciesHtml;
        e.applyStyles({
            top: h.depsTopOffset + "px",
            left: "0px"
        });
        a && a.setHeight("100%");
        var g = h.normalGrid,
        f = g.el.down(h.tableSelector).getWidth(),
        b = g.getView().id;
        var d = c(b);
        d.style.width = f + "px";
        d.style.overflow = "hidden";
        var j = c(h.lockedView.id);
        j.style.overflow = "hidden";
        return i
    }
});
Ext.define("Gnt.plugin.exporter.SinglePage", {
    extend: "Sch.plugin.exporter.SinglePage",
    mixins: ["Gnt.plugin.exporter.mixin.DependencyPainter"],
    setComponent: function() {
        this.callParent(arguments);
        this.initDependencyPainter()
    },
    collectNormalRow: function(c, a) {
        var b = this,
        d = b.callParent(arguments);
        b.fillTaskBox(d.record);
        return d
    },
    onRowsCollected: function() {
        var a = this;
        a.renderDependencies();
        this.callParent(arguments)
    },
    preparePageToCommit: function() {
        var d = this,
        h = d.callParent(arguments),
        b = h.select(".sch-dependencyview-ct").first(),
        e = h.select("." + Ext.baseCSSPrefix + "splitter").first();
        b.dom.innerHTML = d.dependenciesHtml;
        b.applyStyles({
            top: "0px",
            left: "0px"
        });
        e && e.setHeight("100%");
        var f = d.component.normalGrid,
        a = f.el.down(d.tableSelector).getWidth(),
        g = f.getView().id,
        c = h.select("#" + g).first().dom;
        c.style.width = a + "px";
        return h
    }
});
Ext.define("Gnt.plugin.Export", {
    extend: "Sch.plugin.Export",
    alias: "plugin.gantt_export",
    alternateClassName: "Gnt.plugin.PdfExport",
    requires: ["Gnt.plugin.exporter.SinglePage", "Gnt.plugin.exporter.MultiPage", "Gnt.plugin.exporter.MultiPageVertical"],
    buildExporters: function() {
        return ["Gnt.plugin.exporter.SinglePage", "Gnt.plugin.exporter.MultiPage", "Gnt.plugin.exporter.MultiPageVertical"]
    },
    showExportDialog: function() {
        this.exportDialogConfig.scrollerDisabled = true;
        this.callParent(arguments)
    }
});
Ext.define("Gnt.plugin.Printable", {
    extend: "Sch.plugin.Printable",
    alias: "plugin.gantt_printable",
    getGridContent: function(e) {
        var j = e.getSchedulingView();
        j._print = true;
        var a = this.callParent(arguments),
        h = j.dependencyView,
        n = h.painter.getDependencyTplData(j.dependencyStore.getRange()),
        d = '<div class="' + h.getDependencyCanvas().dom.className + '">' + h.lineTpl.apply(n) + "</div>",
        m = a.normalRows;
        if (Ext.select(".sch-gantt-critical-chain").first()) {
            var b = Ext.DomHelper.createDom({
                tag: "div",
                html: d
            }).cloneNode(true);
            b = Ext.get(b);
            var p = Ext.DomHelper.createDom({
                tag: "div",
                html: m
            }).cloneNode(true);
            p = Ext.get(p);
            var q = j.getCriticalPaths(),
            c = j.dependencyStore,
            o,
            g,
            f,
            k;
            Ext.each(q,
            function(i) {
                for (g = 0, f = i.length; g < f; g++) {
                    o = i[g];
                    this.highlightTask(o, e, p);
                    if (g < (f - 1)) {
                        k = c.getAt(c.findBy(function(l) {
                            return l.getTargetId() === (o.getId() || o.internalId) && l.getSourceId() === (i[g + 1].getId() || i[g + 1].internalId)
                        }));
                        this.highlightDependency(k, b, h)
                    }
                }
            },
            this);
            m = p.dom.innerHTML;
            d = b.dom.innerHTML
        }
        a.normalRows = d + m;
        delete j._print;
        return a
    },
    highlightTask: function(b, a, e) {
        var d = a.getSchedulingView().getElementFromEventRecord(b),
        c = d.id;
        if (d) {
            e.select("#" + c).first().parent("tr").addCls("sch-gantt-task-highlighted")
        }
    },
    highlightDependency: function(c, b, a) {
        var d = c instanceof Ext.data.Model ? c.internalId: c;
        return b.select(".sch-dep-" + d).addCls(a.selectedCls)
    }
});
Ext.define("Gnt.view.DependencyPainter", {
    ganttView: null,
    rowHeight: null,
    arrowOffset: 8,
    lineWidth: 2,
    xOffset: 6,
    constructor: function(a) {
        a = a || {};
        Ext.apply(this, a)
    },
    setRowHeight: function(a) {
        this.rowHeight = a
    },
    getTaskBox: function(s) {
        var i = Sch.util.Date,
        k = s.getStartDate(),
        r = s.getEndDate(),
        o = this.ganttView,
        n = o.bufferedRenderer,
        f = o.timeAxis.getStart(),
        d = o.timeAxis.getEnd();
        if (!s.isVisible() || !k || !r || !i.intersectSpans(k, r, f, d)) {
            return null
        }
        if (o.store.indexOf(s) < 0) {
            var m = o.taskStore;
            if (!n) {
                return null
            }
            if (m.isTreeFiltered() && !m.lastTreeFilter.filter.call(m.lastTreeFilter.scope || m, s)) {
                return null
            }
        }
        var g, c = o.getXFromDate(i.max(k, f)),
        b = o.getXFromDate(i.min(r, d)),
        a = o.getNodeByRecord(s);
        if (a || n) {
            var v = o.getXOffset(s),
            p,
            j,
            w = s.isMilestone(),
            u = true;
            if (c > v) {
                c -= v
            }
            b += v;
            var h = o.el;
            var l = o.getScroll().top - (o.bufferedRenderer ? o.bufferedRenderer.bodyTop: 0);
            if (a) {
                var t = o.getEventNodeByRecord(s);
                if (!t) {
                    return null
                }
                g = Ext.fly(t).getOffsetsTo(h);
                p = g[1] + l + (w && Ext.isIE8 ? 3 : 0);
                j = p + Ext.fly(t).getHeight();
                if (w) {
                    b += 1
                }
            } else {
                var q = o.all.elements;
                var e = o.store.getAt(o.all.startIndex);
                if (s.isAbove(e)) {
                    a = q[o.all.startIndex];
                    g = Ext.fly(a).getOffsetsTo(h);
                    g[1] -= o.getRowHeight()
                } else {
                    a = q[o.all.endIndex];
                    g = Ext.fly(a).getOffsetsTo(h);
                    g[1] += o.getRowHeight()
                }
                p = g[1] + l;
                j = p + this.rowHeight;
                u = false
            }
            return {
                top: p,
                end: b,
                bottom: j,
                start: c,
                rendered: u
            }
        }
    },
    getRenderData: function(g) {
        var f = g.getSourceTask(),
        d = g.getTargetTask();
        if (!f || !f.getTreeStore() || !d || !d.getTreeStore()) {
            return null
        }
        var a = this.getTaskBox(f);
        var e = this.getTaskBox(d);
        var c = this.ganttView;
        if (c.bufferRender && a && !a.rendered && e && !e.rendered) {
            var h = c.store.getAt(c.all.startIndex);
            var b = c.store.getAt(c.all.endIndex);
            if ((f.isAbove(h) && d.isAbove(h)) || (b.isAbove(f) && b.isAbove(d))) {
                return null
            }
        }
        return {
            fromBox: a,
            toBox: e
        }
    },
    getDependencyTplData: function(m) {
        var g = this,
        j = g.ganttView;
        if (m instanceof Ext.data.Model) {
            m = [m]
        }
        if (m.length === 0 || j.store.getCount() === 0) {
            return
        }
        var a = [],
        k,
        h,
        f,
        b;
        for (var e = 0,
        c = m.length; e < c; e++) {
            b = m[e];
            var d = this.getRenderData(b);
            if (d) {
                h = d.fromBox;
                f = d.toBox;
                if (h && f) {
                    k = g.getLineCoordinates(h, f, b);
                    if (k) {
                        a.push({
                            dependency: b,
                            id: b.internalId,
                            cls: b.getCls(),
                            lineCoordinates: k
                        })
                    }
                }
            }
        }
        return a
    },
    getLineCoordinates: function(r, p, k) {
        var g, s, q = [0, r.top - 1 + ((r.bottom - r.top) / 2)],
        a = [0, p.top - 1 + ((p.bottom - p.top) / 2)],
        c = a[1] > q[1],
        h = k.self.Type,
        e = this.arrowOffset + this.xOffset,
        d = k.getType(),
        n = [],
        b = k.getTargetTask().isMilestone(),
        l,
        j,
        t;
        switch (d) {
        case h.StartToEnd:
            q[0] = r.start;
            a[0] = p.end + e;
            g = "l";
            s = "r";
            break;
        case h.StartToStart:
            q[0] = r.start;
            a[0] = p.start - e;
            g = "l";
            s = "l";
            break;
        case h.EndToStart:
            q[0] = r.end;
            a[0] = p.start - e;
            g = "r";
            s = "l";
            break;
        case h.EndToEnd:
            q[0] = r.end;
            a[0] = p.end + e;
            g = "r";
            s = "r";
            break;
        default:
            throw "Invalid dependency type: " + k.getType()
        }
        n.push(q);
        var o = q[0] + (g === "r" ? this.xOffset: -this.xOffset);
        if (c && d === h.EndToStart && r.end < (p.start + 5)) {
            l = Math.min(p.start, p.end) + this.xOffset;
            n.push([l, q[1]]);
            n.push([l, p.top - this.arrowOffset - (b ? 2 : 0)])
        } else {
            if (g !== s && ((g === "r" && o > a[0]) || (g === "l" && o < a[0]))) {
                j = p[s === "l" ? "start": "end"];
                t = a[1] + (c ? -1 : 1) * (this.rowHeight / 2);
                n.push([o, q[1]]);
                n.push([o, t]);
                n.push([a[0], t]);
                n.push(a);
                n.push([j + (a[0] < j ? -this.arrowOffset: this.arrowOffset) - (b && s === "l" && !Ext.isIE8m ? 2 : 0), a[1]])
            } else {
                j = p[s === "l" ? "start": "end"];
                if (g === "r") {
                    l = Math.max(o, a[0])
                } else {
                    l = Math.min(o, a[0])
                }
                n.push([l, q[1]]);
                n.push([l, a[1]]);
                n.push([j + (l < j ? -this.arrowOffset: this.arrowOffset) - (b && s === "l" ? 2 : 0), a[1]])
            }
        }
        var f = [];
        for (var m = 0; m < n.length - 1; m++) {
            f.push({
                x1: n[m][0],
                y1: n[m][1],
                x2: n[m + 1][0],
                y2: n[m + 1][1]
            })
        }
        return f
    }
});
Ext.define("Gnt.view.Dependency", {
    extend: "Ext.util.Observable",
    requires: ["Ext.XTemplate", "Gnt.feature.DependencyDragDrop", "Gnt.view.DependencyPainter"],
    lineWidth: 1,
    dragZoneConfig: null,
    dropZoneConfig: null,
    dependencyPainterClass: "Gnt.view.DependencyPainter",
    ganttView: null,
    painter: null,
    taskStore: null,
    store: null,
    dnd: null,
    lineTpl: null,
    renderTimer: null,
    enableDependencyDragDrop: true,
    renderAllDepsBuffered: false,
    dependencyCls: "sch-dependency",
    selectedCls: "sch-dependency-selected",
    constructor: function(a) {
        this.callParent(arguments);
        var c = this.ganttView;
        if (c.bufferedRenderer) {
            c.on({
                itemadd: this.renderAllDependenciesBuffered,
                scope: this
            })
        }
        c.on({
            refresh: this.renderAllDependenciesBuffered,
            itemupdate: this.onTaskUpdated,
            scope: this
        });
        this.bindTaskStore(c.getTaskStore());
        this.bindDependencyStore(a.store);
        if (!this.lineTpl) {
            var d = this.rtl;
            var b = d ? "right": "left";
            this.lineTpl = new Ext.XTemplate('<tpl for=".">' + ('<tpl for="lineCoordinates"><div class="{0} {[ parent.dependency.isHighlighted ? "{1}" : "" ]} {[values.x1==values.x2 ? "sch-dependency-line-v" : "sch-dependency-line-h"]} {lineCls} sch-dep-{parent.id} {0}-line {[this.getSuffixedCls(parent.cls, "-line")]}" style="' + b + ":{[Math.min(values.x1, values.x2)]}px;top:{[Math.min(values.y1, values.y2)]}px;width:{[Math.abs(values.x1-values.x2)+" + this.lineWidth + "]}px;height:{[Math.abs(values.y1-values.y2)+" + this.lineWidth + ']}px"></div></tpl><div style="' + b + ':{[values.lineCoordinates[values.lineCoordinates.length - 1].x2]}px;top:{[values.lineCoordinates[values.lineCoordinates.length - 1].y2]}px" class="{0}-arrow-ct {0} {[ values.dependency.isHighlighted ? "{1}" : "" ]} sch-dep-{id} {[this.getSuffixedCls(values.cls, "-arrow-ct")]}"><img src="' + Ext.BLANK_IMAGE_URL + '" class="{0}-arrow {0}-arrow-{[this.getArrowDirection(values.lineCoordinates)]} {[this.getSuffixedCls(values.cls, "-arrow")]}" /></div>').replace(/\{0\}/g, this.dependencyCls).replace(/\{1\}/g, this.selectedCls) + "</tpl>", {
                disableFormats: true,
                getArrowDirection: function(f) {
                    var e = f[f.length - 1];
                    if (e.y2 < e.y1) {
                        return "up"
                    }
                    if (e.x1 === e.x2) {
                        return "down"
                    } else {
                        if ((!d && e.x1 > e.x2) || (d && e.x1 < e.x2)) {
                            return "left"
                        } else {
                            return "right"
                        }
                    }
                },
                getSuffixedCls: function(e, f) {
                    if (e && e.indexOf(" ") != -1) {
                        return e.replace(/^\s*(.*)\s*$/, "$1").split(/\s+/).join(f + " ") + f
                    } else {
                        return e + f
                    }
                }
            })
        }
        this.painter = Ext.create(this.dependencyPainterClass, Ext.apply({
            rowHeight: c.getRowHeight(),
            ganttView: c
        },
        a));
        if (this.enableDependencyDragDrop) {
            this.dnd = Ext.create("Gnt.feature.DependencyDragDrop", {
                el: c.getEl(),
                rtl: c.rtl,
                ganttView: c,
                dragZoneConfig: this.dragZoneConfig,
                dropZoneConfig: this.dropZoneConfig,
                dependencyStore: this.store
            });
            this.dnd.on("drop", this.onDependencyDrop, this);
            this.relayEvents(this.dnd, ["beforednd", "dndstart", "afterdnd", "drop"])
        }
        if (c.rendered) {
            this.renderAllDependenciesBuffered()
        }
        this.initDependencyListeners()
    },
    initDependencyListeners: function() {
        var a = this;
        a.ganttView.mon(a.ganttView.getEl(), {
            dblclick: a.onDependencyClick,
            click: a.onDependencyClick,
            contextmenu: a.onDependencyClick,
            scope: a,
            delegate: "." + a.dependencyCls
        })
    },
    createDependencyCanvas: function(a) {
        return Ext.fly(a).insertFirst({
            cls: "sch-dependencyview-ct " + (this.lineWidth === 1 ? " sch-dependencyview-thin ": "")
        })
    },
    getDependencyCanvas: function() {
        var b = this,
        c = b.ganttView.getNodeContainer() || b.ganttView.scrollerEl,
        a = c && Ext.fly(c).child("div.sch-dependencyview-ct");
        if (c && !a) {
            a = b.createDependencyCanvas(c)
        }
        return a
    },
    bindDependencyStore: function(a) {
        this.depStoreListeners = {
            refresh: this.renderAllDependenciesBuffered,
            clear: this.renderAllDependenciesBuffered,
            load: this.renderAllDependenciesBuffered,
            add: this.onDependencyAdd,
            update: this.onDependencyUpdate,
            remove: this.onDependencyDelete,
            scope: this
        };
        a.on(this.depStoreListeners);
        this.store = a
    },
    unBindDependencyStore: function() {
        if (this.depStoreListeners) {
            this.store.un(this.depStoreListeners)
        }
    },
    bindTaskStore: function(a) {
        var b = this.ganttView;
        this.taskStoreListeners = {
            cascade: this.onTaskStoreCascade,
            noderemove: this.renderAllDependenciesBuffered,
            nodeinsert: this.renderAllDependenciesBuffered,
            nodeappend: this.renderAllDependenciesBuffered,
            nodemove: this.renderAllDependenciesBuffered,
            nodeexpand: this.renderAllDependenciesBuffered,
            nodecollapse: this.renderAllDependenciesBuffered,
            sort: this.renderAllDependenciesBuffered,
            scope: this
        };
        a.on(this.taskStoreListeners);
        this.taskStore = a
    },
    onTaskStoreCascade: function(a, b) {
        if (b && b.nbrAffected > 0) {
            this.renderAllDependenciesBuffered()
        }
    },
    unBindTaskStore: function(a) {
        a = a || this.taskStore;
        if (!a) {
            return
        }
        if (this.ganttViewListeners) {
            this.ganttView.un(this.ganttViewListeners)
        }
        a.un(this.taskStoreListeners)
    },
    onDependencyClick: function(b, a) {
        var c = this.getRecordForDependencyEl(a);
        this.fireEvent("dependency" + b.type, this, c, b, a)
    },
    highlightDependency: function(a) {
        if (! (a instanceof Ext.data.Model)) {
            a = this.getDependencyRecordByInternalId(a)
        }
        if (a) {
            a.isHighlighted = true;
            this.getElementsForDependency(a).addCls(this.selectedCls)
        }
    },
    unhighlightDependency: function(a) {
        if (! (a instanceof Ext.data.Model)) {
            a = this.getDependencyRecordByInternalId(a)
        }
        if (a) {
            a.isHighlighted = false;
            this.getElementsForDependency(a).removeCls(this.selectedCls)
        }
    },
    getElementsForDependency: function(c) {
        var a = this,
        d = c instanceof Ext.data.Model ? c.internalId: c,
        b = a.getDependencyCanvas();
        return b && b.select(".sch-dep-" + d)
    },
    depRe: new RegExp("sch-dep-([^\\s]+)"),
    getDependencyRecordByInternalId: function(d) {
        var c, b, a;
        for (b = 0, a = this.store.getCount(); b < a; b++) {
            c = this.store.getAt(b);
            if (c.internalId == d) {
                return c
            }
        }
        return null
    },
    getRecordForDependencyEl: function(c) {
        var a = c.className.match(this.depRe),
        d = null;
        if (a && a[1]) {
            var b = a[1];
            d = this.getDependencyRecordByInternalId(b)
        }
        return d
    },
    renderAllDependenciesBuffered: function() {
        var b = this,
        c;
        var a = b.ganttView.up("{isHidden()}");
        if (a) {
            clearTimeout(b.renderTimer);
            b.renderTimer = null;
            a.on("show", b.renderAllDependenciesBuffered, b, {
                single: true
            });
            return
        }
        if (b.renderTimer) {
            return
        }
        c = b.getDependencyCanvas();
        b.renderTimer = setTimeout(function() {
            b.renderTimer = null;
            if (!b.ganttView.isDestroyed) {
                b.renderAllDependencies()
            }
        },
        0)
    },
    renderAllDependencies: function() {
        var a = this,
        b = a.getDependencyCanvas();
        if (!b) {
            return
        }
        a.renderDependencies(this.store.data.items, true);
        a.fireEvent("refresh", this)
    },
    getDependencyElements: function() {
        var a = this,
        b = a.getDependencyCanvas();
        return b && b.select("." + a.dependencyCls)
    },
    renderDependencies: function(e, b) {
        var c = this,
        d = c.getDependencyCanvas(),
        a;
        if (!d) {
            return
        }
        if (e && !Ext.isArray(e)) {
            e = [e]
        }
        if (e && e.length > 0) {
            a = c.painter.getDependencyTplData(e);
            c.lineTpl[b ? "overwrite": "append"](d, a)
        } else {
            if (b) {
                d.update()
            }
        }
    },
    renderTaskDependencies: function(d) {
        var c = [];
        if (d instanceof Ext.data.Model) {
            d = [d]
        }
        for (var a = 0,
        b = d.length; a < b; a++) {
            c = c.concat(d[a].getAllDependencies())
        }
        this.renderDependencies(c)
    },
    onDependencyUpdate: function(b, a) {
        this.removeDependencyElements(a, false);
        this.renderDependencies(a)
    },
    onDependencyAdd: function(a, b) {
        this.renderDependencies(b)
    },
    removeDependencyElements: function(a, b) {
        if (b !== false) {
            this.getElementsForDependency(a).fadeOut({
                remove: true
            })
        } else {
            this.getElementsForDependency(a).remove()
        }
    },
    onDependencyDelete: function(a, b) {
        Ext.Array.each(b,
        function(c) {
            this.removeDependencyElements(c)
        },
        this)
    },
    dimEventDependencies: function(a) {
        var b = this,
        c = b.getDependencyCanvas();
        c && c.select(b.depRe + a).setOpacity(0.2)
    },
    clearSelectedDependencies: function() {
        var a = this,
        b = a.getDependencyCanvas();
        b.select("." + a.selectedCls).removeCls(a.selectedCls);
        a.store.each(function(c) {
            c.isHighlighted = false
        })
    },
    onTaskUpdated: function(a) {
        if (!this.taskStore.cascading && (!a.previous || a.startDateField in a.previous || a.endDateField in a.previous)) {
            this.updateDependencies(a)
        }
    },
    updateDependencies: function(b) {
        if (b instanceof Ext.data.Model) {
            b = [b]
        }
        var a = this;
        Ext.each(b,
        function(c) {
            Ext.each(c.getAllDependencies(),
            function(d) {
                a.removeDependencyElements(d, false)
            })
        });
        this.renderTaskDependencies(b)
    },
    onNewDependencyCreated: function() {},
    onDependencyDrop: function(g, d, a, e) {
        var f = this,
        c = f.taskStore,
        b;
        if (c && c.getNodeById) {
            b = c.getNodeById(d)
        } else {
            if (c) {
                b = c.getById(d)
            }
        }
        b && b.linkTo(a, e, null, Ext.Function.bind(f.onNewDependencyCreated, f))
    },
    destroy: function() {
        if (this.dnd) {
            this.dnd.destroy()
        }
        this.unBindTaskStore();
        this.unBindDependencyStore()
    },
    setRowHeight: function(a, b) {
        this.rowHeight = a;
        this.painter.setRowHeight(a);
        if (!b) {
            this.renderAllDependencies()
        }
    }
});
Ext.define("Gnt.view.Gantt", {
    extend: "Sch.view.TimelineGridView",
    alias: ["widget.ganttview"],
    requires: ["Ext.dd.ScrollManager", "Gnt.view.Dependency", "Gnt.model.Task", "Gnt.template.Task", "Gnt.template.ParentTask", "Gnt.template.Milestone", "Gnt.template.RollupTask", "Gnt.feature.TaskDragDrop", "Gnt.feature.ProgressBarResize", "Gnt.feature.TaskResize", "Sch.view.Horizontal"],
    uses: ["Gnt.feature.LabelEditor", "Gnt.feature.DragCreator"],
    mixins: ["Sch.mixin.FilterableTreeView"],
    _cmpCls: "sch-ganttview",
    barMargin: 4,
    scheduledEventName: "task",
    trackOver: false,
    toggleOnDblClick: false,
    eventSelector: ".sch-gantt-item",
    eventWrapSelector: ".sch-event-wrap",
    progressBarResizer: null,
    taskResizer: null,
    taskDragDrop: null,
    dragCreator: null,
    dependencyView: null,
    resizeConfig: null,
    createConfig: null,
    dragDropConfig: null,
    progressBarResizeConfig: null,
    dependencyViewConfig: null,
    externalGetRowClass: null,
    outsideLabelsGatherWidth: 200,
    constructor: function(a) {
        a = a || {};
        if (a) {
            this.externalGetRowClass = a.getRowClass;
            delete a.getRowClass
        }
        this.callParent(arguments);
        this.on("boxready", this.onMyBoxReady, this);
        this.initTreeFiltering()
    },
    onRender: function() {
        this.configureLabels();
        this.setupGanttEvents();
        this.setupTemplates();
        this.callParent(arguments)
    },
    onMyBoxReady: function() {
        if (Ext.supports.Touch && this.getNodeContainer()) {
            this.getDependencyView().getDependencyCanvas().insertBefore(this.getNodeContainer())
        }
    },
    getDependencyStore: function() {
        return this.dependencyStore
    },
    configureFeatures: function() {
        if (this.enableProgressBarResize !== false) {
            this.progressBarResizer = Ext.create("Gnt.feature.ProgressBarResize", Ext.apply({
                ganttView: this
            },
            this.progressBarResizeConfig || {}));
            this.on({
                beforeprogressbarresize: this.onBeforeTaskProgressBarResize,
                progressbarresizestart: this.onTaskProgressBarResizeStart,
                afterprogressbarresize: this.onTaskProgressBarResizeEnd,
                scope: this
            })
        }
        if (this.resizeHandles !== "none") {
            this.taskResizer = Ext.create("Gnt.feature.TaskResize", Ext.apply({
                ganttView: this,
                validatorFn: this.resizeValidatorFn || Ext.emptyFn,
                validatorFnScope: this
            },
            this.resizeConfig || {}));
            this.on({
                beforedragcreate: this.onBeforeDragCreate,
                beforetaskresize: this.onBeforeTaskResize,
                taskresizestart: this.onTaskResizeStart,
                aftertaskresize: this.onTaskResizeEnd,
                scope: this
            })
        }
        if (this.enableTaskDragDrop) {
            this.taskDragDrop = Ext.create("Gnt.feature.TaskDragDrop", this.ownerCt.el, Ext.apply({
                gantt: this,
                validatorFn: this.dndValidatorFn || Ext.emptyFn,
                validatorFnScope: this
            },
            this.dragDropConfig));
            this.on({
                beforetaskdrag: this.onBeforeTaskDrag,
                taskdragstart: this.onDragDropStart,
                aftertaskdrop: this.onDragDropEnd,
                scope: this
            })
        }
        if (this.enableDragCreation) {
            this.dragCreator = Ext.create("Gnt.feature.DragCreator", Ext.apply({
                ganttView: this,
                validatorFn: this.createValidatorFn || Ext.emptyFn,
                validatorFnScope: this
            },
            this.createConfig))
        }
    },
    getTemplateForTask: function(b, a) {
        if (b.isMilestone(a)) {
            return this.milestoneTemplate
        }
        if (b.isLeaf()) {
            return this.eventTemplate
        }
        return this.parentEventTemplate
    },
    refreshParentNode: function(a) {
        var c = a.parentNode;
        if (c) {
            var b = this.store.indexOf(c);
            if (b != -1) {
                this.refreshNode(b)
            }
        }
    },
    setShowRollupTasks: function(a) {
        this.showRollupTasks = a;
        var b = {};
        this.taskStore.getRootNode().cascadeBy(function(f) {
            if (f.getRollup()) {
                var e = f.parentNode;
                b[e.internalId] = e
            }
        });
        for (var d in b) {
            var c = this.store.indexOf(b[d]);
            if (c >= 0) {
                this.refreshNode(c)
            }
        }
    },
    getRollupRenderData: function(e) {
        var a = [];
        var j = this.timeAxis,
        k = j.getStart(),
        n = j.getEnd();
        for (var h = 0; h < e.childNodes.length; h++) {
            var f = e.childNodes[h];
            if (f.getRollup()) {
                var q = f.getStartDate(),
                d = f.getEndDate() || Sch.util.Date.add(q, f.getDurationUnit() || Sch.util.Date.DAY, 1);
                if (Sch.util.Date.intersectSpans(q, d, k, n)) {
                    var g = {},
                    o = f.isMilestone();
                    g.isRollup = true;
                    g.id = "rollup_" + f.getId();
                    var c = d > n,
                    b = Sch.util.Date.betweenLesser(q, k, n),
                    m = Math.floor(this.getXFromDate(b ? q: k)),
                    p = Math.floor(this.getXFromDate(c ? n: d)),
                    l = o ? 0 : p - m;
                    g.offset = (o ? (p || m) - this.getXOffset(f) : m);
                    g.tpl = o ? this.milestoneTemplate: this.eventTemplate;
                    g.cls = f.getCls();
                    g.ctcls = "";
                    g.record = f;
                    if (o) {
                        g.side = Math.round(0.5 * this.getRowHeight());
                        g.ctcls += " sch-gantt-milestone"
                    } else {
                        g.width = Math.max(1, l);
                        if (c) {
                            g.ctcls += " sch-event-endsoutside "
                        }
                        if (!b) {
                            g.ctcls += " sch-event-startsoutside "
                        }
                        g.ctcls += " sch-gantt-task"
                    }
                    g.cls += " sch-rollup-task";
                    a.push(g)
                }
            }
        }
        return a
    },
    getLabelRenderData: function(b) {
        var e = this.leftLabelField,
        a = this.rightLabelField,
        f = this.topLabelField,
        c = this.bottomLabelField,
        d = {};
        if (e) {
            d.leftLabel = Ext.util.Format.htmlEncode(e.renderer.call(e.scope || this, b.data[e.dataIndex], b))
        }
        if (a) {
            d.rightLabel = Ext.util.Format.htmlEncode(a.renderer.call(a.scope || this, b.data[a.dataIndex], b))
        }
        if (f) {
            d.topLabel = Ext.util.Format.htmlEncode(f.renderer.call(f.scope || this, b.data[f.dataIndex], b))
        }
        if (c) {
            d.bottomLabel = Ext.util.Format.htmlEncode(c.renderer.call(c.scope || this, b.data[c.dataIndex], b))
        }
        return d
    },
    columnRenderer: function(U, p, z) {
        var V = z.getStartDate(),
        j = this.timeAxis,
        v = Sch.util.Date,
        y = {},
        q = "",
        L = "",
        B = j.getStart(),
        T = j.getEnd(),
        G = z.isMilestone(),
        F = z.isLeaf(),
        f = false,
        n,
        b,
        C;
        if (V) {
            var Z = z.getEndDate() || v.add(V, z.getDurationUnit() || v.DAY, 1),
            a = j.getAt(0),
            M = (a.getEndDate() - a.getStartDate()) / this.timeAxisViewModel.getTickWidth(),
            H = M * this.outsideLabelsGatherWidth,
            r = v.intersectSpans(V, Z, B, T),
            g = this.outsideLabelsGatherWidth > 0,
            d = g && v.intersectSpans(V, Z, T, new Date(T.getTime() + H)),
            x = g && v.intersectSpans(V, Z, new Date(B.getTime() - H), B);
            if (r || d || x) {
                C = Z > T;
                b = v.betweenLesser(V, B, T);
                var K, A, e;
                if (r) {
                    K = Math.floor(this.getXFromDate(b ? V: B));
                    A = Math.floor(this.getXFromDate(C ? T: Z));
                    e = G ? 0 : A - K
                } else {
                    b = true;
                    e = 0;
                    if (d) {
                        K = Math.floor(this.getXFromDate(T) + (V - T) / M)
                    } else {
                        K = Math.floor(this.getXFromDate(B) - (B - Z) / M)
                    }
                }
                var ac = G ? (A || K) - this.getXOffset(z) : K;
                var J = Math.min(z.getPercentDone() || 0, 100) / 100,
                W,
                Q,
                ad;
                var ab = z.getSegments(),
                u;
                if (ab) {
                    var l = 0,
                    E = ab.length,
                    aa, w;
                    for (aa = 0; aa < E; aa++) {
                        w = ab[aa];
                        l += (w.getEndDate() - w.getStartDate()) * J
                    }
                    u = [];
                    var S, h, o, c;
                    for (aa = 0; aa < E; aa++) {
                        w = ab[aa];
                        var k = {},
                        P = w.getCls() || "";
                        c = w.getEndDate() || z.getStartDate();
                        o = w.getStartDate();
                        if (v.betweenLesser(o, B, T)) {
                            S = Math.floor(this.getXFromDate(o));
                            if (v.betweenLesser(c, B, T)) {
                                h = Math.floor(this.getXFromDate(c))
                            } else {
                                h = Math.floor(this.getXFromDate(T))
                            }
                        } else {
                            S = Math.floor(this.getXFromDate(B));
                            if (v.betweenLesser(c, B, T)) {
                                h = Math.floor(this.getXFromDate(c))
                            } else {
                                if (o > T && c > T) {
                                    S = h = Math.floor(this.getXFromDate(T)) + 100
                                } else {
                                    if (o < B && c < B) {
                                        S = h = Math.floor(this.getXFromDate(B)) - 100
                                    } else {
                                        h = Math.floor(this.getXFromDate(T))
                                    }
                                }
                            }
                        }
                        k.left = S - K;
                        k.width = h - S;
                        if (!W) {
                            l -= (c - o);
                            if (l <= 0) {
                                W = v.add(c, v.MILLI, l);
                                P += " sch-segment-in-progress";
                                Q = Math.floor(this.getXFromDate(W));
                                k.progressBarWidth = Math.min(Math.abs(Q - S), k.width)
                            } else {
                                k.progressBarWidth = w.width
                            }
                        } else {
                            k.progressBarWidth = 0
                        }
                        k.percentDone = J * 100;
                        Ext.apply(k, w.data);
                        k.cls = P;
                        k.SegmentIndex = aa;
                        u.push(k)
                    }
                    u[0].cls += " sch-gantt-task-segment-first";
                    u[E - 1].cls += " sch-gantt-task-segment-last"
                } else {
                    W = new Date((Z - V) * J + V.getTime());
                    if (W < B) {
                        W = B
                    } else {
                        if (W > T) {
                            W = T
                        }
                    }
                }
                Q = Math.floor(this.getXFromDate(W));
                ad = Math.min(Math.abs(Q - K), e);
                y = Ext.apply({},
                {
                    id: z.internalId,
                    offset: ac,
                    width: Math.max(1, e),
                    ctcls: "",
                    cls: "",
                    print: this._print,
                    record: z,
                    percentDone: J * 100,
                    progressBarWidth: Math.max(0, ad - 2 * this.eventBorderWidth),
                    segments: u
                },
                z.data);
                n = this.eventRenderer.call(this.eventRendererScope || this, z, y, z.store) || {};
                Ext.apply(y, this.getLabelRenderData(z));
                f = true;
                Ext.apply(y, n);
                var m = " sch-event-resizable-" + z.getResizable();
                if (G) {
                    y.side = Math.round((this.enableBaseline ? 0.4 : 0.5) * this.getRowHeight());
                    L += " sch-gantt-milestone"
                } else {
                    y.width = Math.max(1, e);
                    if (C) {
                        L += " sch-event-endsoutside "
                    }
                    if (!b) {
                        L += " sch-event-startsoutside "
                    }
                    if (F) {
                        L += " sch-gantt-task"
                    } else {
                        L += " sch-gantt-parent-task"
                    }
                }
                if (z.dirty) {
                    m += " sch-dirty "
                }
                if (z.isDraggable() === false) {
                    m += " sch-event-fixed "
                }
                if (z.isSegmented()) {
                    m += " sch-event-segmented "
                }
                y.cls = (y.cls || "") + (z.getCls() || "") + m;
                y.ctcls += " " + L;
                if (this.showRollupTasks) {
                    var t = this.getRollupRenderData(z);
                    if (t.length > 0) {
                        q += this.rollupTemplate.apply(t)
                    }
                }
                q += this.getTemplateForTask(z).apply(y)
            }
        }
        if (this.enableBaseline) {
            var N = z.getBaselineStartDate(),
            R = z.getBaselineEndDate();
            if (!n) {
                n = this.eventRenderer.call(this, z, y, z.store) || {}
            }
            if (N && R && v.intersectSpans(N, R, B, T)) {
                C = R > T;
                b = v.betweenLesser(N, B, T);
                var s = z.isBaselineMilestone(),
                X = Math.floor(this.getXFromDate(b ? N: B)),
                O = Math.floor(this.getXFromDate(C ? T: R)),
                I = Math.max(1, s ? 0 : O - X),
                Y = this.getTemplateForTask(z, true),
                ae = {
                    progressBarStyle: n.baseProgressBarStyle || "",
                    id: z.internalId + "-base",
                    progressBarWidth: Math.min(100, z.getBaselinePercentDone()) * I / 100,
                    percentDone: z.getBaselinePercentDone(),
                    offset: s ? (O || X) - this.getXOffset(z, true) : X,
                    print: this._print,
                    width: Math.max(1, I),
                    baseline: true
                };
                L = "";
                if (s) {
                    ae.side = Math.round(0.4 * this.getRowHeight());
                    L = "sch-gantt-milestone-baseline sch-gantt-baseline-item"
                } else {
                    if (z.isLeaf()) {
                        L = "sch-gantt-task-baseline sch-gantt-baseline-item"
                    } else {
                        L = "sch-gantt-parenttask-baseline sch-gantt-baseline-item"
                    }
                }
                if (C) {
                    L += " sch-event-endsoutside "
                }
                if (!b) {
                    L += " sch-event-startsoutside "
                }
                ae.ctcls = L + " " + (n.basecls || "");
                if (!f) {
                    Ext.apply(ae, this.getLabelRenderData(z))
                }
                q += Y.apply(ae)
            }
        }
        return q
    },
    setupTemplates: function() {
        var a = {
            leftLabel: this.leftLabelField,
            rightLabel: this.rightLabelField,
            topLabel: this.topLabelField,
            bottomLabel: this.bottomLabelField,
            prefix: this.eventPrefix,
            resizeHandles: this.resizeHandles,
            enableDependencyDragDrop: this.enableDependencyDragDrop !== false,
            allowParentTaskDependencies: this.allowParentTaskDependencies !== false,
            enableProgressBarResize: this.enableProgressBarResize,
            rtl: this.rtl
        };
        var b;
        if (!this.eventTemplate) {
            b = this.taskBodyTemplate ? Ext.apply({
                innerTpl: this.taskBodyTemplate
            },
            a) : a;
            this.eventTemplate = Ext.create("Gnt.template.Task", b)
        }
        if (!this.parentEventTemplate) {
            b = this.parentTaskBodyTemplate ? Ext.apply({
                innerTpl: this.parentTaskBodyTemplate
            },
            a) : a;
            this.parentEventTemplate = Ext.create("Gnt.template.ParentTask", b)
        }
        if (!this.milestoneTemplate) {
            b = this.milestoneBodyTemplate ? Ext.apply({
                innerTpl: this.milestoneBodyTemplate
            },
            a) : a;
            this.milestoneTemplate = Ext.create("Gnt.template.Milestone", b)
        }
        if (!this.rollupTemplate) {
            this.rollupTemplate = Ext.create("Gnt.template.RollupTask", a)
        }
    },
    getDependencyView: function() {
        return this.dependencyView
    },
    getTaskStore: function() {
        return this.taskStore
    },
    initDependencies: function() {
        if (this.dependencyStore) {
            var b = this,
            a = Ext.create("Gnt.view.Dependency", Ext.apply({
                containerEl: b.el,
                ganttView: b,
                enableDependencyDragDrop: b.enableDependencyDragDrop,
                allowParentTaskDependencies: b.allowParentTaskDependencies,
                store: b.dependencyStore,
                rtl: b.rtl
            },
            this.dependencyViewConfig));
            a.on({
                beforednd: b.onBeforeDependencyDrag,
                dndstart: b.onDependencyDragStart,
                drop: b.onDependencyDrop,
                afterdnd: b.onAfterDependencyDragDrop,
                scope: b
            });
            b.dependencyView = a;
            b.relayEvents(a, ["dependencyclick", "dependencycontextmenu", "dependencydblclick"])
        }
    },
    setupGanttEvents: function() {
        var a = this.taskStore;
        if (this.toggleParentTasksOnClick) {
            this.on({
                taskclick: function(b, d) {
                    if (!d.isLeaf() && (!a.isTreeFiltered() || a.allowExpandCollapseWhileFiltered)) {
                        var e = this;
                        var c = function() {
                            this.fireEvent.apply(this, ["taskdblclick"].concat(Array.prototype.slice.apply(arguments)))
                        };
                        this.on("taskclick", c);
                        setTimeout(function() {
                            e.un("taskclick", c)
                        },
                        300);
                        d.isExpanded() ? d.collapse() : d.expand()
                    }
                }
            })
        }
    },
    configureLabels: function() {
        var a = {
            renderer: function(b) {
                return b
            },
            dataIndex: undefined
        };
        Ext.Array.forEach(["left", "right", "top", "bottom"],
        function(c) {
            var b = this[c + "LabelField"];
            if (b) {
                if (Ext.isString(b)) {
                    b = this[c + "LabelField"] = {
                        dataIndex: b
                    }
                }
                Ext.applyIf(b, a);
                if (b.editor) {
                    b.editor = Ext.create("Gnt.feature.LabelEditor", this, {
                        labelPosition: c,
                        field: b.editor,
                        dataIndex: b.dataIndex
                    })
                }
            }
        },
        this);
        this.on("labeledit_beforestartedit", this.onBeforeLabelEdit, this)
    },
    onBeforeTaskDrag: function(b, a) {
        return ! this.readOnly && a.isDraggable() !== false && (this.allowParentTaskMove || a.isLeaf())
    },
    onDragDropStart: function() {
        if (this.tip) {
            this.tip.on("beforeshow", this.falseReturningFn)
        }
    },
    falseReturningFn: function() {
        return false
    },
    onDragDropEnd: function() {
        if (this.tip) {
            this.tip.un("beforeshow", this.falseReturningFn)
        }
    },
    onTaskProgressBarResizeStart: function() {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable()
        }
    },
    onTaskProgressBarResizeEnd: function() {
        if (this.tip) {
            this.tip.enable()
        }
    },
    onTaskResizeStart: function() {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable()
        }
        if (this.scrollManager) {
            this.scrollManager.scroller.setDisabled(true)
        }
    },
    onTaskResizeEnd: function() {
        if (this.tip) {
            this.tip.enable()
        }
        if (this.scrollManager) {
            this.scrollManager.scroller.setDisabled(false)
        }
    },
    onBeforeDragCreate: function() {
        return ! this.readOnly
    },
    onBeforeTaskResize: function(a, b) {
        return ! this.readOnly && b.getSchedulingMode() !== "EffortDriven"
    },
    onBeforeTaskProgressBarResize: function() {
        return ! this.readOnly
    },
    onBeforeLabelEdit: function() {
        return ! this.readOnly
    },
    onBeforeEdit: function() {
        return ! this.readOnly
    },
    afterRender: function() {
        this.initDependencies();
        this.callParent(arguments);
        this.el.on("mousemove", this.configureFeatures, this, {
            single: true
        });
        Ext.dd.ScrollManager.register(this.el)
    },
    resolveTaskRecord: function(a) {
        var b = this.findItemByChild(a);
        if (b) {
            return this.getRecord(this.findItemByChild(a))
        }
        return null
    },
    resolveEventRecord: function(a) {
        return this.resolveTaskRecord(a)
    },
    resolveEventRecordFromResourceRow: function(a) {
        return this.resolveTaskRecord(a)
    },
    highlightTask: function(c, b) {
        if (! (c instanceof Ext.data.Model)) {
            c = this.taskStore.getNodeById(c)
        }
        if (c) {
            c.isHighlighted = true;
            var e = this.getNode(c);
            if (e) {
                Ext.fly(e).addCls("sch-gantt-task-highlighted")
            }
            if (b !== false) {
                for (var d = 0,
                a = c.successors.length; d < a; d++) {
                    var f = c.successors[d];
                    this.highlightDependency(f);
                    this.highlightTask(f.getTargetTask(), b)
                }
            }
        }
    },
    unhighlightTask: function(b, e) {
        if (! (b instanceof Ext.data.Model)) {
            b = this.taskStore.getNodeById(b)
        }
        if (b) {
            b.isHighlighted = false;
            var d = this.getNode(b);
            if (d) {
                Ext.fly(d).removeCls("sch-gantt-task-highlighted")
            }
            if (e !== false) {
                for (var c = 0,
                a = b.successors.length; c < a; c++) {
                    var f = b.successors[c];
                    this.unhighlightDependency(f);
                    this.unhighlightTask(f.getTargetTask(), e)
                }
            }
        }
    },
    getRowClass: function(b) {
        var a = "";
        if (b.isHighlighted) {
            a = "sch-gantt-task-highlighted"
        }
        if (this.externalGetRowClass) {
            a += " " + (this.externalGetRowClass.apply(this, arguments) || "")
        }
        return a
    },
    clearSelectedTasksAndDependencies: function() {
        this.getDependencyView().clearSelectedDependencies();
        this.el.select("tr.sch-gantt-task-highlighted").removeCls("sch-gantt-task-highlighted");
        this.taskStore.getRootNode().cascadeBy(function(a) {
            a.isHighlighted = false
        })
    },
    getCriticalPaths: function() {
        return this.taskStore.getCriticalPaths()
    },
    highlightCriticalPaths: function() {
        this.clearSelectedTasksAndDependencies();
        var f = this.getCriticalPaths(),
        c = this.getDependencyView(),
        e,
        d,
        b,
        a;
        Ext.each(f,
        function(i) {
            for (d = 0, b = i.length; d < b; d++) {
                e = i[d];
                this.highlightTask(e, false);
                if (d < b - 1) {
                    for (var h = 0,
                    g = e.predecessors.length; h < g; h++) {
                        if (e.predecessors[h].getSourceId() == i[d + 1].getInternalId()) {
                            a = e.predecessors[h];
                            break
                        }
                    }
                    c.highlightDependency(a)
                }
            }
        },
        this);
        this.addCls("sch-gantt-critical-chain")
    },
    unhighlightCriticalPaths: function() {
        this.el.removeCls("sch-gantt-critical-chain");
        this.clearSelectedTasksAndDependencies()
    },
    getXOffset: function(b, a) {
        var c = 0;
        if (b.isMilestone(a)) {
            c = Math.floor(this.getRowHeight() * Math.sqrt(2) / 4) - 2
        }
        return c
    },
    onDestroy: function() {
        if (this.dependencyView) {
            this.dependencyView.destroy()
        }
        if (this.rendered) {
            Ext.dd.ScrollManager.unregister(this.el)
        }
        this.callParent(arguments)
    },
    highlightDependency: function(a) {
        this.dependencyView.highlightDependency(a)
    },
    unhighlightDependency: function(a) {
        this.dependencyView.unhighlightDependency(a)
    },
    onBeforeDependencyDrag: function(b, a) {
        return this.fireEvent("beforedependencydrag", this, a)
    },
    onDependencyDragStart: function(a) {
        this.fireEvent("dependencydragstart", this);
        if (this.tip) {
            this.tip.disable()
        }
        this.preventOverCls = true
    },
    onDependencyDrop: function(b, c, a, d) {
        this.fireEvent("dependencydrop", this, this.taskStore.getNodeById(c), this.taskStore.getNodeById(a), d)
    },
    onAfterDependencyDragDrop: function() {
        this.fireEvent("afterdependencydragdrop", this);
        if (this.tip) {
            this.tip.enable()
        }
        this.preventOverCls = false
    },
    getLeftEditor: function() {
        return this.leftLabelField.editor
    },
    getRightEditor: function() {
        return this.rightLabelField.editor
    },
    getTopEditor: function() {
        return this.topLabelField.editor
    },
    getBottomEditor: function() {
        return this.bottomLabelField.editor
    },
    editLeftLabel: function(a) {
        var b = this.leftLabelField && this.leftLabelField.editor;
        if (b) {
            b.edit(a)
        }
    },
    editRightLabel: function(a) {
        var b = this.rightLabelField && this.rightLabelField.editor;
        if (b) {
            b.edit(a)
        }
    },
    editTopLabel: function(a) {
        var b = this.topLabelField && this.topLabelField.editor;
        if (b) {
            b.edit(a)
        }
    },
    editBottomLabel: function(a) {
        var b = this.bottomLabelField && this.bottomLabelField.editor;
        if (b) {
            b.edit(a)
        }
    },
    getOuterElementFromEventRecord: function(a) {
        var b = this.callParent([a]);
        return b && b.up(this.eventWrapSelector) || null
    },
    getDependenciesForTask: function(a) {
        return a.getAllDependencies()
    },
    onUpdate: function(c, a, b, d) {
        this.callParent(arguments);
        var e = a.previous;
        if (e && (a.rollupField in e || a.getRollup())) {
            this.refreshParentNode(a)
        }
    },
    handleScheduleEvent: function(c) {
        var a = c.getTarget("." + this.timeCellCls, 3);
        if (a) {
            var b = this.findRowByChild(a);
            if (c.type.indexOf("pinch") >= 0) {
                this.fireEvent("schedule" + c.type, this, c)
            } else {
                this.fireEvent("schedule" + c.type, this, this.getDateFromDomEvent(c, "floor"), this.indexOf(b), c)
            }
        }
    },
    scrollEventIntoView: function(d, e, b, m, n) {
        n = n || this;
        var i = this;
        var j = this.taskStore;
        var k = function(p, o) {
            i.up("panel").scrollTask.cancel();
            i.scrollElementIntoView(p, o, b);
            if (e) {
                if (typeof e === "boolean") {
                    p.highlight()
                } else {
                    p.highlight(null, e)
                }
            }
            m && m.call(n)
        };
        if (!d.isVisible()) {
            d.bubble(function(o) {
                o.expand()
            })
        }
        var l;
        var c = d.getStartDate();
        var h = d.getEndDate();
        var a = Boolean(c && h);
        if (a) {
            var g = this.timeAxis;
            if (!g.dateInAxis(c) || !g.dateInAxis(h)) {
                var f = g.getEnd() - g.getStart();
                g.setTimeSpan(new Date(c.getTime() - f / 2), new Date(h.getTime() + f / 2))
            }
            l = this.getElementFromEventRecord(d)
        } else {
            l = this.getNode(d);
            if (l) {
                l = Ext.fly(l).down(this.getCellSelector())
            }
        }
        if (l) {
            k(l, a)
        } else {
            if (this.bufferedRenderer) {
                Ext.Function.defer(function() {
                    i.bufferedRenderer.scrollTo(j.getIndexInTotalDataset(d), false,
                    function() {
                        var o = i.getElementFromEventRecord(d);
                        if (o) {
                            k(o, true)
                        } else {
                            m && m.call(n)
                        }
                    })
                },
                10)
            }
        }
    }
});
Ext.define("Gnt.view.ResourceHistogram", {
    extend: "Sch.view.TimelineGridView",
    alias: "widget.resourcehistogramview",
    requires: ["Ext.XTemplate", "Ext.util.Format", "Sch.util.Date", "Gnt.model.Resource"],
    _cmpCls: "gnt-resourcehistogramview",
    scheduledEventName: "bar",
    eventSelector: ".gnt-resourcehistogram-bar",
    barTpl: null,
    barRenderer: Ext.emptyFn,
    lineTpl: null,
    limitLineTpl: null,
    _barCls: "gnt-resourcehistogram-bar",
    _limitLineCls: "gnt-resourcehistogram-limitline",
    _limitLineVerticalCls: "gnt-resourcehistogram-limitline-vertical",
    _lineCls: "gnt-resourcehistogram-line",
    barCls: null,
    limitLineCls: null,
    lineCls: null,
    limitLineWidth: 1,
    rowHeight: 60,
    showLimitLinesThreshold: 10,
    showVerticalLimitLines: true,
    labelMode: false,
    labelPercentFormat: "0",
    labelUnitsFormat: "0.0",
    histogram: null,
    unitHeight: null,
    availableRowHeight: null,
    initComponent: function(a) {
        if (this.barCls) {
            this.eventSelector = "." + this.barCls
        }
        if (!this.barTpl) {
            this.barTpl = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" class="gnt-resourcehistogram-bar ' + (this.barCls || "") + ' {cls}" gnt-bar-index="{index}" style="left:{left}px;top:{top}px;height:{height}px;width:{width}px">', "<tpl if=\"text !== ''\">", '<span class="gnt-resourcehistogram-bar-text" style="bottom:' + Math.floor(this.rowHeight / 2) + 'px">{text}</span>', "</tpl>", "</div>", "</tpl>")
        }
        if (!this.lineTpl) {
            this.lineTpl = new Ext.XTemplate('<tpl for=".">', '<div class="gnt-resourcehistogram-line ' + (this.lineCls || "") + ' {cls}" style="top:{top}px;"></div>', "</tpl>")
        }
        if (!this.limitLineTpl) {
            this.limitLineTpl = new Ext.XTemplate('<tpl for=".">', '<div class="gnt-resourcehistogram-limitline ' + (this.limitLineCls || "") + ' {cls}" style="left:{left}px;top:{top}px;width:{width}px;height:{height}px"></div>', "</tpl>")
        }
        this.callParent(arguments);
        this.unitHeight = this.getAvailableRowHeight() / (this.scaleMax - this.scaleMin + this.scaleStep)
    },
    renderLines: function(a) {
        return this.lineTpl.apply(this.prepareLines(a))
    },
    prepareLines: function(f) {
        var g = f.scaleMin,
        d = f.scaleLabelStep,
        a = this.getAvailableRowHeight(),
        e = [],
        k = this._lineCls,
        j = k + "min";
        if (f.scalePoints) {
            var h;
            for (var c = 0,
            b = f.scalePoints.length; c < b; c++) {
                h = f.scalePoints[c];
                e.push({
                    value: h.value,
                    top: h.top || Math.round(a - this.unitHeight * (h.value - f.scaleMin)),
                    cls: h.cls + (h.label ? " " + k + "-label": "") + (c === 0 ? " " + k + "-min": (c == b ? " " + k + "-max": ""))
                })
            }
        } else {
            while (g <= f.scaleMax) {
                e.push({
                    value: g,
                    top: Math.round(a - this.unitHeight * (g - f.scaleMin)),
                    cls: j
                });
                g += f.scaleStep;
                j = g % d ? "": k + "-label";
                if (g == f.scaleMax) {
                    j += " " + k + "-max"
                }
            }
            if (e.length && e[e.length - 1].value !== f.scaleMax) {
                e.push({
                    value: f.scaleMax,
                    top: Math.round(a - this.unitHeight * (f.scaleMax - f.scaleMin)),
                    cls: (f.scaleMax % d ? "": k + "-label") + " " + k + "-max"
                })
            }
        }
        return e
    },
    renderLimitLines: function(b, a) {
        return this.limitLineTpl.apply(this.prepareLimitLines(b, a))
    },
    getLimitLinesConnector: function(b, a) {
        return {
            left: b.right,
            width: 1,
            top: Math.min(b.top, a.top),
            height: Math.abs(b.top - a.top) + this.limitLineWidth,
            cls: this._limitLineCls + "-top " + this._limitLineVerticalCls
        }
    },
    pushLimitLine: function(b, a, c) {
        var d = b[b.length - 1];
        if (c) {
            if (d) {
                d.width = c.right - d.left;
                d.right = c.right
            } else {
                a.left = c.left;
                a.width = a.right - c.left
            }
            c = null
        }
        if (d && this.showVerticalLimitLines) {
            if (!d.visible) {
                b.pop()
            }
            b.push(this.getLimitLinesConnector(d, a))
        }
        b.push(a)
    },
    prepareLimitLines: function(o, j) {
        if (!j) {
            return
        }
        var n = [],
        a = this.getAvailableRowHeight(),
        q = this._limitLineCls,
        k,
        r,
        f;
        for (var h = 0,
        e = j.length; h < e; h++) {
            var m = o.calendar.convertMSDurationToUnit(j[h].allocationMS, o.scaleUnit);
            var d = true;
            if (m * this.unitHeight > a) {
                m = o.scaleMax + o.scaleStep;
                d = false
            } else {
                if (m <= 0) {
                    m = 0;
                    d = false
                }
            }
            var c = this.getXFromDate(j[h].startDate || o.getStart(), true);
            var p = this.getXFromDate(j[h].endDate || o.getEnd(), true);
            if (c < 0) {
                c = 0;
                if (p < 0) {
                    continue
                }
            } else {
                if (p < 0) {
                    p = this.getXFromDate(o.getEnd(), true)
                }
            }
            r = {
                left: c,
                width: p - c,
                right: p,
                top: "",
                height: 0,
                cls: "",
                visible: d
            };
            r.top = Math.round(a - (m - o.scaleMin) * this.unitHeight);
            if (d) {
                r.cls += " " + q + "-top"
            }
            f = n[n.length - 1] || k;
            var g = r.width <= this.showLimitLinesThreshold;
            if (f && (r.top == f.top || (g && !d))) {
                f.width = p - f.left;
                f.right = p;
                r = null;
                if (n[n.length - 1]) {
                    k = null
                } else {
                    if (k.width > this.showLimitLinesThreshold) {
                        this.pushLimitLine(n, k);
                        k = null
                    }
                }
            } else {
                if (g && d) {
                    if (k) {
                        var b = k.width + r.width;
                        k.top = Math.round(r.top * r.width / b + k.top * k.width / b);
                        k.width = p - k.left;
                        k.right = p
                    } else {
                        k = r
                    }
                    if (k.width > this.showLimitLinesThreshold) {
                        this.pushLimitLine(n, k);
                        r = k = null
                    }
                } else {
                    this.pushLimitLine(n, r, k);
                    r = k = null
                }
            }
        }
        r && this.pushLimitLine(n, r, k);
        f = n[n.length - 1];
        if (f && !f.visible) {
            n.pop()
        }
        return n
    },
    renderBars: function(b, a, c) {
        return this.barTpl.apply(this.prepareBars(b, a, c))
    },
    prepareBars: function(j, e, f) {
        if (!e) {
            return
        }
        var h = [],
        a = this.getAvailableRowHeight(),
        k = this._barCls,
        b,
        g;
        for (var d = 0,
        c = e.length; d < c; d++) {
            if (e[d].totalAllocation) {
                g = j.calendar.convertMSDurationToUnit(e[d].allocationMS, j.scaleUnit);
                b = Ext.apply({
                    id: f + "-" + d,
                    index: d,
                    left: this.getXFromDate(e[d].startDate, true),
                    width: this.getXFromDate(e[d].endDate, true) - this.getXFromDate(e[d].startDate, true),
                    height: a,
                    top: 0,
                    text: "",
                    cls: ""
                },
                this.barRenderer(f, e[d]));
                if (this.labelMode) {
                    switch (this.labelMode) {
                    case "percent":
                        b.text = Ext.util.Format.number(e[d].totalAllocation, this.labelPercentFormat) + "%";
                        break;
                    case "units":
                        b.text = Ext.util.Format.number(g, this.labelUnitsFormat) + Sch.util.Date.getShortNameOfUnit(j.scaleUnit);
                        break;
                    default:
                        b.text = this.labelMode.apply({
                            allocation: g,
                            percent: e[d].totalAllocation
                        })
                    }
                }
                if (g <= j.scaleMax + j.scaleStep) {
                    b.height = g >= j.scaleMin ? Math.round((g - j.scaleMin) * this.unitHeight) : 0;
                    b.top = a - b.height
                } else {
                    b.cls = k + "-partofbar"
                }
                if (e[d].totalAllocation > 100 || e[d].totalOverAllocationMS > 0) {
                    b.cls = k + "-overwork"
                }
                h.push(b)
            }
        }
        return h
    },
    getAvailableRowHeight: function() {
        if (this.availableRowHeight) {
            return this.availableRowHeight
        }
        this.availableRowHeight = this.rowHeight - this.cellTopBorderWidth - this.cellBottomBorderWidth;
        return this.availableRowHeight
    },
    resolveEventRecord: function(c) {
        var e = this.findItemByChild(c);
        if (e) {
            var g = this.getRecord(e);
            if (g) {
                var a = {
                    resource: g
                };
                var f = this.histogram.allocationData[g.getInternalId()];
                var b = c.getAttribute("gnt-bar-index");
                var d = f.bars[b];
                if (d) {
                    a.startDate = d.startDate;
                    a.endDate = d.endDate;
                    a.assignments = d.assignments;
                    a.allocationMS = d.allocationMS;
                    a.totalAllocation = d.totalAllocation
                }
                return a
            }
        }
        return null
    },
    resolveEventRecordFromResourceRow: function(a) {
        return this.resolveEventRecord(a)
    },
    getDataForTooltipTpl: function(a) {
        return a
    }
});
Ext.define("Gnt.column.Scale", {
    extend: "Ext.grid.column.Template",
    alias: "widget.scalecolumn",
    tpl: null,
    sortable: false,
    scalePoints: null,
    scaleStep: 2,
    scaleLabelStep: 4,
    scaleMin: 0,
    scaleMax: 24,
    width: 40,
    availableHeight: 48,
    scaleCellCls: "gnt-scalecolumn",
    initComponent: function() {
        this.tdCls = (this.tdCls || "") + " " + this.scaleCellCls;
        if (!this.tpl) {
            this.tpl = new Ext.XTemplate('<div class="' + this.scaleCellCls + '-wrap" style="height:{scaleHeight}px;">', '<tpl for="scalePoints">', "<tpl if=\"label !== ''\">", '<span class="' + this.scaleCellCls + '-label-line {cls}" style="top:{top}px"><span class="' + this.scaleCellCls + '-label">{label}</span></span>', "<tpl else>", '<span class="' + this.scaleCellCls + '-line {cls}" style="top:{top}px"></span>', "</tpl>", "</tpl>", "</div>")
        }
        this.setAvailableHeight(this.availableHeight, true);
        this.callParent(arguments)
    },
    setAvailableHeight: function(a, b) {
        this.availableHeight = a;
        if (!this.scalePoints) {
            this.scaleStepHeight = this.availableHeight / (this.scaleMax - this.scaleMin + this.scaleStep);
            this.scalePoints = this.buildScalePoints()
        } else {
            if (b) {
                this.scalePoints.sort(function(d, c) {
                    return d.value > c.value ? 1 : -1
                });
                this.scaleMin = this.scalePoints[0].value;
                this.scaleMax = this.scalePoints[this.scalePoints.length - 1].value;
                this.scaleStep = (this.scaleMax - this.scaleMin) / 10
            }
            this.scaleStepHeight = this.availableHeight / (this.scaleMax - this.scaleMin + this.scaleStep);
            this.updateScalePointsTops()
        }
    },
    defaultRenderer: function(c, d, a) {
        var b = {
            record: Ext.apply({},
            a.data, a.getAssociatedData()),
            scaleHeight: this.availableHeight,
            scalePoints: this.scalePoints
        };
        return this.tpl.apply(b)
    },
    buildScalePoints: function() {
        var g = this.scaleMin,
        h = g,
        c = this.scaleStep,
        f = this.scaleLabelStep,
        d = this.scaleStepHeight,
        b = this.availableHeight,
        a = this.scaleCellCls,
        i = a + "-min",
        j = [];
        var e = function(m, l, k) {
            return {
                top: Math.round(b - (m - g) * d),
                value: m,
                label: l != "undefined" ? l: "",
                cls: k || ""
            }
        };
        while (h < this.scaleMax) {
            j.push(e(h, h % f || h === g ? "": h, i));
            i = "";
            h += c
        }
        j.push(e(this.scaleMax, this.scaleMax, a + "-max"));
        return j
    },
    updateScalePointsTops: function() {
        var d = this.scaleStepHeight,
        e = this.availableHeight,
        a;
        for (var c = 0,
        b = this.scalePoints.length; c < b; c++) {
            a = this.scalePoints[c];
            a.top = Math.round(e - a.value * d)
        }
    }
});
Ext.define("Gnt.field.mixin.TaskField", {
    taskField: "",
    task: null,
    taskStore: null,
    suppressTaskUpdate: 0,
    highlightTaskUpdates: true,
    highlightColor: "#009900",
    lastHighlight: 0,
    instantUpdate: true,
    setTask: function(a) {
        if (!a) {
            return
        }
        this.destroyTaskListener();
        this.updateReadOnly(a);
        this.task = a;
        a.on("taskupdated", this.onTaskUpdateProcess, this);
        if (!a.getCalendar(true) && !a.getTaskStore(true)) {
            a.taskStore = a.getTaskStore(true) || this.taskStore;
            if (!a.taskStore) {
                throw "Configuration issue: Gnt.data.taskStore instance should be provided."
            }
            if (!a.getCalendar(true) && !a.taskStore.getCalendar()) {
                throw "Configuration issue: Gnt.data.Calendar instance should be provided."
            }
        }
        this.setSuppressTaskUpdate(true);
        if (this.onSetTask) {
            this.onSetTask(a)
        }
        this.setSuppressTaskUpdate(false)
    },
    setSuppressTaskUpdate: function(a) {
        a ? this.suppressTaskUpdate++:this.suppressTaskUpdate--
    },
    getSuppressTaskUpdate: function() {
        return this.suppressTaskUpdate
    },
    updateReadOnly: function(a) {
        if (!this.disabled) {
            if (this.editable === false) {
                if (!a.isEditable(a[this.taskField])) {
                    this.setReadOnly(true)
                } else {
                    if (this.inputEl) {
                        this.setReadOnly(false);
                        this.inputEl.dom.readOnly = true
                    }
                }
            } else {
                this.setReadOnly(!a.isEditable(a[this.taskField]))
            }
        }
    },
    onTaskUpdateProcess: function(a, d) {
        if (d !== this) {
            var c = this.getValue();
            this.updateReadOnly(a);
            this.setSuppressTaskUpdate(true);
            if (this.onTaskUpdate) {
                this.onTaskUpdate(a, d)
            } else {
                if (this.onSetTask) {
                    this.onSetTask(a)
                }
            }
            this.setSuppressTaskUpdate(false);
            if (this.highlightTaskUpdates) {
                var e = this.getValue(),
                b = Ext.isDate(c);
                if (b && (c - e !== 0) || (!b && String(c) !== String(e))) {
                    this.highlightField()
                }
            }
        }
    },
    highlightField: function(a, b) {
        if (this.rendered && (new Date() - this.lastHighlight > 1000)) {
            this.lastHighlight = new Date();
            this.inputEl.highlight(a || this.highlightColor, b || {
                attr: "color"
            })
        }
    },
    destroyTaskListener: function() {
        if (this.task) {
            this.task.un("taskupdated", this.onTaskUpdateProcess, this)
        }
    }
});
Ext.define("Gnt.field.EndDate", {
    extend: "Ext.form.field.Date",
    requires: ["Sch.util.Date"],
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.enddatefield",
    adjustMilestones: true,
    keepDuration: false,
    taskField: "endDateField",
    validateStartDate: true,
    constructor: function(a) {
        a = a || {};
        Ext.apply(this, a);
        if (a.task && !a.value) {
            a.value = a.task.getEndDate()
        }
        this.setSuppressTaskUpdate(true);
        this.callParent([a]);
        this.setSuppressTaskUpdate(false);
        if (this.task) {
            this.setTask(this.task)
        }
    },
    destroy: function() {
        this.destroyTaskListener();
        this.callParent()
    },
    onSetTask: function() {
        this.setValue(this.task.getEndDate())
    },
    rawToValue: function(a) {
        if (!a) {
            return null
        }
        return this.visibleToValue(this.parseDate(a))
    },
    valueToRaw: function(a) {
        if (!a) {
            return a
        }
        return Ext.Date.format(this.valueToVisible(a), this.format)
    },
    valueToVisible: function(b, a) {
        a = a || this.task;
        return a.getDisplayEndDate(this.format, this.adjustMilestones, b, true)
    },
    visibleToValue: function(a) {
        if (a && this.task) {
            if (!Ext.Date.formatContainsHourInfo(this.format) && a - Ext.Date.clearTime(a, true) === 0) {
                a = this.task.getCalendar().getCalendarDay(a).getAvailabilityEndFor(a) || Sch.util.Date.add(a, Sch.util.Date.DAY, 1)
            }
        } else {
            a = null
        }
        return a
    },
    getErrors: function(a) {
        var b = this.callParent(arguments);
        if (b && b.length) {
            return b
        }
        if (this.validateStartDate) {
            a = this.rawToValue(a);
            if (this.task && a) {
                if (a < this.task.getStartDate()) {
                    return [this.L("endBeforeStartText")]
                }
            }
        }
        return []
    },
    onExpand: function() {
        var a = this.valueToVisible(this.getValue());
        if (!this.isValid()) {
            a = this.getRawValue();
            if (a) {
                a = Ext.Date.parse(a, this.format)
            }
        }
        this.picker.setValue(Ext.isDate(a) ? a: new Date())
    },
    onSelect: function(d, a) {
        var c = this.task.getEndDate();
        if (Ext.Date.formatContainsHourInfo(this.format) && c) {
            a.setHours(c.getHours());
            a.setMinutes(c.getMinutes())
        }
        var e = this;
        var b = e.getValue();
        var g = this.visibleToValue(a);
        var f = Ext.Date.format(a, this.format);
        if (b != g) {
            if (this.getErrors(f).length > 0) {
                e.setRawValue(f);
                e.collapse();
                e.validate()
            } else {
                e.setValue(g, true);
                e.fireEvent("select", e, g);
                e.collapse()
            }
        }
    },
    applyChanges: function(a) {
        a = a || this.task;
        var b = a.getTaskStore(true) || this.taskStore;
        if (this.value) {
            a.setEndDate(this.value, this.keepDuration, b.skipWeekendsDuringDragDrop)
        } else {
            a.setEndDate(null)
        }
    },
    setVisibleValue: function(a) {
        this.setValue(this.rawToValue(Ext.Date.format(a, this.format)))
    },
    getVisibleValue: function() {
        if (!this.getValue()) {
            return null
        }
        return Ext.Date.parse(this.valueToRaw(this.getValue()), this.format)
    },
    setValue: function(b, a) {
        this.callParent([b]);
        if ((a || this.instantUpdate) && !this.getSuppressTaskUpdate() && this.task) {
            this.applyChanges();
            var c = this.task.getEndDate();
            if (c - this.getValue() !== 0) {
                this.callParent([c])
            }
            this.task.fireEvent("taskupdated", this.task, this)
        }
    },
    getValue: function() {
        return this.value
    },
    checkChange: function() {
        if (!this.suspendCheckChange) {
            var c = this,
            b = c.rawToValue((c.inputEl ? c.inputEl.getValue() : c.rawValue || "")),
            a = c.lastValue;
            if (!c.isEqual(b, a) && !c.isDestroyed) {
                c.lastValue = b;
                c.fireEvent("change", c, b, a);
                c.onChange(b, a)
            }
        }
    },
    assertValue: function() {
        var c = this,
        d = c.rawValue,
        f = c.getRawValue(),
        a = c.getValue(),
        e = c.rawToValue(f),
        b = c.focusTask;
        if (b) {
            b.cancel()
        }
        if ((d != f) || (e - a !== 0)) {
            if (!c.validateOnBlur || c.isValid()) {
                c.setValue(e, true)
            }
        }
    },
    beforeBlur: function() {
        this.assertValue()
    }
});
Ext.define("Gnt.field.StartDate", {
    extend: "Ext.form.field.Date",
    requires: ["Sch.util.Date"],
    mixins: ["Gnt.field.mixin.TaskField"],
    alias: "widget.startdatefield",
    adjustMilestones: true,
    keepDuration: true,
    taskField: "startDateField",
    constructor: function(a) {
        a = a || {};
        if (a.task && !a.value) {
            a.value = a.task.getStartDate()
        }
        this.setSuppressTaskUpdate(true);
        this.callParent([a]);
        this.setSuppressTaskUpdate(false);
        if (this.task) {
            this.setTask(this.task)
        }
    },
    destroy: function() {
        this.destroyTaskListener();
        this.callParent()
    },
    onSetTask: function() {
        this.setValue(this.task.getStartDate())
    },
    rawToValue: function(a) {
        if (!a) {
            return null
        }
        return this.visibleToValue(this.parseDate(a))
    },
    valueToRaw: function(a) {
        if (!a) {
            return a
        }
        return Ext.Date.format(this.valueToVisible(a), this.format)
    },
    valueToVisible: function(b, a) {
        a = a || this.task;
        return a.getDisplayStartDate(this.format, this.adjustMilestones, b, true)
    },
    visibleToValue: function(c) {
        var b = this.task;
        if (b && c) {
            var d = b.getEndDate();
            var a = !this.lastValue || this.lastValue - Ext.Date.clearTime(this.lastValue, true) === 0;
            if (this.adjustMilestones && b.isMilestone() && c - Ext.Date.clearTime(c, true) === 0 && a) {
                c = b.getCalendar().getCalendarDay(c).getAvailabilityEndFor(c) || c
            }
        }
        return c
    },
    onExpand: function() {
        var a = this.valueToVisible(this.getValue());
        if (!this.isValid()) {
            a = this.getRawValue();
            if (a) {
                a = Ext.Date.parse(a, this.format)
            }
        }
        this.picker.setValue(Ext.isDate(a) ? a: new Date())
    },
    onSelect: function(d, a) {
        var c = this.task.getStartDate();
        if (Ext.Date.formatContainsHourInfo(this.format) && c) {
            a.setHours(c.getHours());
            a.setMinutes(c.getMinutes())
        }
        var e = this,
        f = Ext.Date.format(a, this.format),
        b = e.getValue(),
        g = this.visibleToValue(a),
        h = this.getErrors(f);
        if (b != g) {
            if (h && h.length) {
                e.setRawValue(f);
                e.collapse();
                e.validate()
            } else {
                e.setValue(g);
                e.fireEvent("select", e, g);
                e.collapse()
            }
        }
    },
    applyChanges: function(a) {
        a = a || this.task;
        var b = a.getTaskStore(true) || this.taskStore;
        a.setStartDate(this.value, this.keepDuration, b.skipWeekendsDuringDragDrop)
    },
    setVisibleValue: function(a) {
        this.setValue(this.rawToValue(Ext.Date.format(a, this.format)))
    },
    getVisibleValue: function() {
        if (!this.getValue()) {
            return null
        }
        return Ext.Date.parse(this.valueToRaw(this.getValue()), this.format)
    },
    setValue: function(d, c) {
        this.callParent([d]);
        var b = this.task;
        if ((c || this.instantUpdate) && !this.getSuppressTaskUpdate() && b && b.taskStore && d) {
            this.applyChanges();
            var a = b.getStartDate();
            if (a - this.getValue() !== 0) {
                this.callParent([a])
            }
            b.fireEvent("taskupdated", b, this)
        }
    },
    getValue: function() {
        return this.value
    },
    checkChange: function() {
        if (!this.suspendCheckChange) {
            var c = this,
            b = c.rawToValue((c.inputEl ? c.inputEl.getValue() : Ext.valueFrom(c.rawValue, ""))),
            a = c.lastValue;
            if (!c.isEqual(b, a) && !c.isDestroyed) {
                c.lastValue = b;
                c.fireEvent("change", c, b, a);
                c.onChange(b, a)
            }
        }
    },
    assertValue: function() {
        var c = this,
        d = c.rawValue,
        f = c.getRawValue(),
        a = c.getValue(),
        e = c.rawToValue(f),
        b = c.focusTask;
        if (b) {
            b.cancel()
        }
        if ((d != f) || (e - a !== 0)) {
            if (!c.validateOnBlur || c.isValid()) {
                c.setValue(e, true)
            }
        }
    },
    beforeBlur: function() {
        this.assertValue()
    }
});
Ext.define("Gnt.field.Duration", {
    extend: "Ext.form.field.Number",
    requires: ["Gnt.util.DurationParser"],
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.durationfield",
    alternateClassName: "Gnt.widget.DurationField",
    disableKeyFilter: true,
    allowExponential: false,
    minValue: 0,
    durationUnit: "h",
    useAbbreviation: false,
    getDurationUnitMethod: "getDurationUnit",
    setDurationMethod: "setDuration",
    getDurationMethod: "getDuration",
    taskField: "durationField",
    durationParser: null,
    durationParserConfig: null,
    constructor: function(a) {
        var b = this;
        Ext.apply(this, a);
        this.durationParser = new Gnt.util.DurationParser(Ext.apply({
            parseNumberFn: function() {
                return b.parseValue.apply(b, arguments)
            },
            allowDecimals: this.decimalPrecision > 0
        },
        this.durationParserConfig));
        this.setSuppressTaskUpdate(true);
        this.callParent(arguments);
        this.setSuppressTaskUpdate(false);
        this.invalidText = this.L("invalidText");
        if (this.task) {
            this.setTask(this.task)
        }
    },
    destroy: function() {
        this.destroyTaskListener();
        this.callParent()
    },
    onSetTask: function() {
        this.durationUnit = this.task[this.getDurationUnitMethod]();
        var a = this.getDurationMethod ? this.task[this.getDurationMethod]() : this.task.get(this.task[this.taskField]);
        this.setValue(a);
        this.setSpinUpEnabled(a == null || a < this.maxValue, true);
        this.setSpinDownEnabled(a > this.minValue, true)
    },
    rawToValue: function(b) {
        var a = this.parseDuration(b);
        if (!a) {
            return null
        }
        this.durationUnit = a.unit;
        return a.value != null ? a.value: null
    },
    valueToVisible: function(c, d) {
        if (Ext.isNumber(c)) {
            var b = parseInt(c, 10),
            a = Ext.Number.toFixed(c, this.decimalPrecision);
            return String(b == a ? b: a).replace(".", this.decimalSeparator) + " " + Sch.util.Date[this.useAbbreviation ? "getShortNameOfUnit": "getReadableNameOfUnit"](d || this.durationUnit, c !== 1)
        }
        return ""
    },
    valueToRaw: function(a) {
        return this.valueToVisible(a, this.durationUnit, this.decimalPrecision, this.useAbbreviation)
    },
    parseDuration: function(b) {
        if (b == null) {
            return null
        }
        var a = this;
        var c = this.durationParser.parse(b);
        if (!c) {
            return null
        }
        c.unit = c.unit || this.durationUnit;
        return c
    },
    getDurationValue: function() {
        return this.parseDuration(this.getRawValue())
    },
    getErrors: function(b) {
        var a;
        if (b) {
            a = this.parseDuration(b);
            if (!a) {
                return [this.L("invalidText")]
            }
            b = a.value
        }
        return this.callParent(arguments)
    },
    checkChange: function() {
        if (!this.suspendCheckChange) {
            var d = this,
            c = d.getDurationValue(),
            a = d.lastValue;
            var b = c && !a || !c && a || c && a && (c.value != a.value || c.unit != a.unit);
            if (b && !d.isDestroyed) {
                d.lastValue = c;
                d.fireEvent("change", d, c, a);
                d.onChange(c, a)
            }
        }
    },
    getValue: function() {
        return this.value
    },
    applyChanges: function(a) {
        a = a || this.task;
        a[this.setDurationMethod](this.getValue(), this.durationUnit)
    },
    setValue: function(b, a) {
        var c = b;
        if (Ext.isObject(b)) {
            this.durationUnit = b.unit;
            c = b.value
        }
        this.callParent([c]);
        if ((a || this.instantUpdate) && !this.getSuppressTaskUpdate() && this.task) {
            this.applyChanges();
            this.task.fireEvent("taskupdated", this.task, this)
        }
    },
    assertValue: function() {
        var d = this,
        a = d.getValue(),
        e = d.durationUnit,
        c = d.getDurationValue();
        if (this.isValid()) {
            var b = c && !a || !c && a || c && (c.value != a || c.unit != e);
            if (b) {
                d.setValue(c, true)
            }
        }
    },
    beforeBlur: function() {
        this.assertValue()
    },
    onSpinUp: function() {
        var a = this;
        if (!a.readOnly) {
            var b = a.getValue() || 0;
            a.setSpinValue(Ext.Number.constrain(b + a.step, a.minValue, a.maxValue))
        }
    },
    onSpinDown: function() {
        var a = this;
        if (!a.readOnly) {
            var b = a.getValue() || 0;
            a.setSpinValue(Ext.Number.constrain(b - a.step, a.minValue, a.maxValue))
        }
    }
});
Ext.define("Gnt.field.Effort", {
    extend: "Gnt.field.Duration",
    requires: ["Gnt.util.DurationParser"],
    alias: "widget.effortfield",
    alternateClassName: "Gnt.widget.EffortField",
    mixins: ["Gnt.mixin.Localizable"],
    taskField: "effortField",
    getDurationUnitMethod: "getEffortUnit",
    setDurationMethod: "setEffort",
    getDurationMethod: "getEffort",
    constructor: function() {
        this.callParent(arguments);
        this.invalidText = this.L("invalidText")
    }
});
Ext.define("Gnt.field.SchedulingMode", {
    extend: "Ext.form.field.ComboBox",
    mixins: ["Gnt.field.mixin.TaskField"],
    alias: "widget.schedulingmodefield",
    alternateClassName: "Gnt.widget.SchedulingmodeField",
    taskField: "schedulingModeField",
    store: [["Normal", "Normal"], ["Manual", "Manual"], ["FixedDuration", "Fixed duration"], ["EffortDriven", "Effort driven"], ["DynamicAssignment", "Dynamic assignment"]],
    pickerAlign: "tl-bl?",
    matchFieldWidth: true,
    editable: false,
    forceSelection: true,
    triggerAction: "all",
    constructor: function(a) {
        var b = this;
        Ext.apply(this, a);
        this.setSuppressTaskUpdate(true);
        this.callParent(arguments);
        this.setSuppressTaskUpdate(false);
        if (this.task) {
            this.setTask(this.task)
        }
        this.on("change", this.onFieldChange, this)
    },
    destroy: function() {
        this.destroyTaskListener();
        this.callParent()
    },
    onSetTask: function() {
        this.setValue(this.task.getSchedulingMode())
    },
    valueToVisible: function(e, b) {
        var c = this,
        d = [];
        var a = this.findRecordByValue(e);
        if (a) {
            d.push(a.data)
        } else {
            if (Ext.isDefined(c.valueNotFoundText)) {
                d.push(c.valueNotFoundText)
            }
        }
        return c.displayTpl.apply(d)
    },
    applyChanges: function(a) {
        a = a || this.task;
        a.setSchedulingMode(this.getValue())
    },
    getValue: function() {
        return this.value
    },
    onFieldChange: function(a) {
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task && this.value) {
            this.applyChanges();
            this.task.fireEvent("taskupdated", this.task, this)
        }
    }
});
Ext.define("Gnt.field.Calendar", {
    extend: "Ext.form.field.ComboBox",
    requires: ["Ext.data.Store", "Gnt.model.Calendar", "Gnt.data.Calendar"],
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.calendarfield",
    alternateClassName: "Gnt.widget.CalendarField",
    taskField: "calendarIdField",
    pickerAlign: "tl-bl?",
    matchFieldWidth: true,
    editable: true,
    triggerAction: "all",
    valueField: "Id",
    displayField: "Name",
    queryMode: "local",
    forceSelection: true,
    allowBlank: true,
    constructor: function(a) {
        var b = this;
        Ext.apply(this, a);
        this.store = this.store || {
            xclass: "Ext.data.Store",
            model: "Gnt.model.Calendar"
        };
        if (! (this.store instanceof Ext.data.Store)) {
            this.store = Ext.create(this.store)
        }
        this.setSuppressTaskUpdate(true);
        this.callParent(arguments);
        this.setSuppressTaskUpdate(false);
        this.updateCalendarsStore();
        this.mon(Ext.data.StoreManager, {
            add: function(d, c, e) {
                if (c instanceof Gnt.data.Calendar) {
                    this.updateCalendarsStore()
                }
            },
            remove: function(d, c, e) {
                if (c instanceof Gnt.data.Calendar) {
                    this.updateCalendarsStore()
                }
            },
            scope: this
        });
        this.on({
            show: this.setReadOnlyIfEmpty,
            scope: this
        });
        if (this.task) {
            this.setTask(this.task)
        }
        this.on("change", this.onFieldChange, this)
    },
    destroy: function() {
        this.destroyTaskListener();
        this.callParent()
    },
    updateCalendarsStore: function() {
        this.store.loadData(this.getCalendarData())
    },
    setReadOnlyIfEmpty: function() {
        this.setReadOnly(!this.store.count())
    },
    getCalendarData: function() {
        var a = [];
        Ext.Array.each(Gnt.data.Calendar.getAllCalendars(),
        function(b) {
            a.push({
                Id: b.calendarId,
                Name: b.name || b.calendarId
            })
        });
        return a
    },
    onSetTask: function() {
        this.setReadOnlyIfEmpty();
        this.setValue(this.task.getCalendarId())
    },
    onTaskUpdate: function(a, b) {
        this.setReadOnlyIfEmpty();
        this.setValue(this.task.getCalendarId())
    },
    valueToVisible: function(e, b) {
        var c = this,
        d = [];
        var a = this.findRecordByValue(e);
        if (a) {
            d.push(a.data)
        } else {
            if (Ext.isDefined(c.valueNotFoundText)) {
                d.push(c.valueNotFoundText)
            }
        }
        return c.displayTpl.apply(d)
    },
    getValue: function() {
        return this.value || ""
    },
    applyChanges: function(a) {
        a = a || this.task;
        a.setCalendarId(this.value)
    },
    getErrors: function(b) {
        if (b) {
            var a = this.findRecordByDisplay(b);
            if (a) {
                if (this.task && !this.task.isCalendarApplicable(a.getId())) {
                    return [this.L("calendarNotApplicable")]
                }
            }
        }
        return this.callParent(arguments)
    },
    onFieldChange: function(b, a) {
        if (undefined === a || null === a || "" === a) {
            this.value = ""
        }
        if (!this.getSuppressTaskUpdate() && this.task) {
            if (this.task.getCalendarId() != this.value) {
                this.applyChanges();
                this.task.fireEvent("taskupdated", this.task, this)
            }
        }
    },
    assertValue: function() {
        var a = this.getRawValue();
        if (!a && this.value) {
            this.setValue("")
        } else {
            this.callParent(arguments)
        }
    }
});
Ext.define("Gnt.field.Percent", {
    extend: "Ext.form.field.Number",
    alias: "widget.percentfield",
    mixins: ["Gnt.mixin.Localizable"],
    alternateClassName: "Gnt.widget.PercentField",
    disableKeyFilter: false,
    minValue: 0,
    maxValue: 100,
    allowExponential: false,
    baseChars: "0123456789%",
    constructor: function() {
        this.callParent(arguments);
        this.invalidText = this.L("invalidText")
    },
    valueToRaw: function(a) {
        if (Ext.isNumber(a)) {
            return parseFloat(Ext.Number.toFixed(a, this.decimalPrecision)) + "%"
        }
        return ""
    },
    getErrors: function(b) {
        var a = this.parseValue(b);
        if (a === null) {
            if (b !== null && b !== "") {
                return [this.invalidText]
            } else {
                a = ""
            }
        }
        return this.callParent([a])
    }
});
Ext.define("Gnt.field.Dependency", {
    extend: "Ext.form.field.Text",
    alternateClassName: "Gnt.widget.DependencyField",
    alias: "widget.dependencyfield",
    requires: ["Gnt.util.DependencyParser"],
    mixins: ["Gnt.mixin.Localizable"],
    type: "predecessors",
    separator: ";",
    task: null,
    dependencyParser: null,
    dependencyParserConfig: null,
    useSequenceNumber: false,
    constructor: function(a) {
        var b = this;
        Ext.apply(this, a);
        this.dependencyParser = new Gnt.util.DependencyParser(Ext.apply({
            parseNumberFn: function() {
                return Gnt.widget.DurationField.prototype.parseValue.apply(b, arguments)
            }
        },
        this.dependencyParserConfig));
        this.callParent(arguments);
        this.addCls("gnt-field-dependency")
    },
    isPredecessor: function() {
        return this.type === "predecessors"
    },
    setTask: function(a) {
        this.task = a;
        this.setRawValue(this.getDisplayValue(a))
    },
    getDependencies: function() {
        return this.dependencyParser.parse(this.getRawValue())
    },
    getTaskIdFromDependency: function(c) {
        var b = this.task.getTaskStore(),
        d = c.taskId,
        a;
        if (this.useSequenceNumber) {
            a = b.getBySequenceNumber(d);
            d = a && a.getInternalId()
        }
        return d
    },
    getErrors: function(n) {
        if (!n) {
            return []
        }
        var e = this.dependencyParser.parse(n);
        if (!e) {
            return [this.L("invalidFormatText")]
        }
        var g = this.getDependencies(),
        m = this.isPredecessor(),
        s = this.task,
        u = s.getTaskStore().dependencyStore,
        l = s[m ? "predecessors": "successors"],
        h = this.dependencyParser.types,
        d = u.allowedDependencyTypes,
        f = u.model.Type,
        a;
        var t = [];
        for (var r = 0; r < g.length; r++) {
            var p = g[r];
            a = this.getTaskIdFromDependency(p);
            if (!a) {
                return [this.L("invalidDependencyText")]
            }
            if (u.allowedDependencyTypes && !u.isValidDependencyType(p.type)) {
                var b = "";
                for (var q = 0,
                o = d.length; q < o; q++) {
                    b += h[f[d[q]]] + ","
                }
                return [Ext.String.format(this.L("invalidDependencyType"), h[p.type], b.substring(0, b.length - 1))]
            }
            var c = new u.model();
            c.setSourceId(m ? a: s.getInternalId());
            c.setTargetId(m ? s.getInternalId() : a);
            c.setType(p.type);
            c.setLag(p.lag);
            c.setLagUnit(p.lagUnit);
            t.push(c)
        }
        for (r = 0; r < t.length; r++) {
            if (!u.isValidDependency(t[r], t, l)) {
                return [this.invalidDependencyText]
            }
        }
        return this.callParent([e.value])
    },
    getDisplayValue: function(b) {
        var j = this.isPredecessor(),
        a = b.getTaskStore().getDependencyStore(),
        m = j ? b.getIncomingDependencies(true) : b.getOutgoingDependencies(true),
        k = this.dependencyParser.types,
        f = Gnt.model.Dependency.Type.EndToStart,
        l = [],
        n;
        for (var e = 0; e < m.length; e++) {
            var h = m[e];
            n = j ? h.getSourceTask() : h.getTargetTask();
            if (n && h.isValid(false)) {
                var g = h.getType(),
                c = h.getLag(),
                d = h.getLagUnit();
                l.push(Ext.String.format("{0}{1}{2}{3}{4}", this.useSequenceNumber ? n.getSequenceNumber() : n.getInternalId(), c || g !== f ? k[g] : "", c > 0 ? "+": "", c || "", c && d !== "d" ? d: ""))
            }
        }
        return l.join(this.separator)
    },
    isDirty: function(c) {
        c = c || this.task;
        if (!c) {
            return false
        }
        var a = this.isPredecessor(),
        d = c.getTaskStore().dependencyStore,
        h = a ? c.getIncomingDependencies() : c.getOutgoingDependencies(),
        f = c.getInternalId();
        for (var e = 0,
        b = h.length; e < b; e++) {
            if (h[e].dirty || h[e].phantom) {
                return true
            }
        }
        if (d) {
            var g = a ? "getTargetId": "getSourceId";
            h = d.getRemovedRecords();
            for (e = 0, b = h.length; e < b; e++) {
                if (h[e][g]() == f) {
                    return true
                }
            }
        }
        return false
    },
    applyChanges: function(d) {
        d = d || this.task;
        var n = d.getTaskStore().dependencyStore,
        h = this.getDependencies(),
        a = [],
        k = this.isPredecessor(),
        m = k ? d.getIncomingDependencies(true) : d.getOutgoingDependencies(true),
        c = [];
        for (var g = 0,
        f = h.length; g < f; g++) {
            a.push(this.getTaskIdFromDependency(h[g]))
        }
        for (g = 0; g < m.length; g++) {
            if (!Ext.Array.contains(a, m[g][k ? "getSourceId": "getTargetId"]())) {
                c.push(m[g])
            }
        }
        if (c.length > 0) {
            n.remove(c)
        }
        var o = [];
        for (g = 0; g < h.length; g++) {
            var e = h[g];
            var b = this.getTaskIdFromDependency(e);
            var j = n.getByTaskIds(b, d.getInternalId());
            if (j) {
                j.beginEdit();
                j.setType(e.type);
                j.setLag(e.lag);
                j.setLagUnit(e.lagUnit);
                j.endEdit()
            } else {
                j = new n.model();
                j.setSourceId(k ? b: d.getInternalId());
                j.setTargetId(k ? d.getInternalId() : b);
                j.setType(e.type);
                j.setLag(e.lag);
                j.setLagUnit(e.lagUnit);
                o.push(j)
            }
        }
        if (o.length > 0) {
            n.add(o)
        }
        if (o.length || c.length) {
            d.triggerUIUpdate()
        }
    }
});
Ext.define("Gnt.field.Milestone", {
    extend: "Ext.form.field.ComboBox",
    requires: "Ext.data.JsonStore",
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.milestonefield",
    instantUpdate: false,
    allowBlank: false,
    forceSelection: true,
    displayField: "text",
    valueField: "value",
    queryMode: "local",
    constructor: function(a) {
        Ext.apply(this, a);
        this.store = new Ext.data.JsonStore({
            fields: ["value", "text"],
            data: [{
                value: 0,
                text: this.L("no")
            },
            {
                value: 1,
                text: this.L("yes")
            }]
        });
        this.setSuppressTaskUpdate(true);
        this.callParent(arguments);
        this.setSuppressTaskUpdate(false);
        if (this.task) {
            this.setTask(this.task)
        }
        this.on("change", this.onFieldChange, this)
    },
    destroy: function() {
        this.destroyTaskListener();
        this.callParent()
    },
    onSetTask: function() {
        this.setValue(this.task.isMilestone() ? 1 : 0)
    },
    valueToVisible: function(a) {
        return a ? this.L("yes") : this.L("no")
    },
    onFieldChange: function(a) {
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            if (this.task.isMilestone() != Boolean(this.value)) {
                this.applyChanges();
                this.task.fireEvent("taskupdated", this.task, this)
            }
        }
    },
    getValue: function() {
        return this.value
    },
    applyChanges: function(a) {
        a = a || this.task;
        if (this.getValue()) {
            a.convertToMilestone()
        } else {
            a.convertToRegular()
        }
    }
});
Ext.define("Gnt.field.ConstraintType", {
    extend: "Ext.form.field.ComboBox",
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    uses: ["Gnt.constraint.Base"],
    alias: "widget.constrainttypefield",
    alternateClassName: "Gnt.widget.ConstraintType.Field",
    taskField: "constraintTypeField",
    pickerAlign: "tl-bl?",
    matchFieldWidth: false,
    editable: false,
    forceSelection: true,
    triggerAction: "all",
    constructor: function(a) {
        var b = this;
        b.setSuppressTaskUpdate(true);
        b.callParent(arguments);
        b.setSuppressTaskUpdate(false);
        b.task && b.setTask(b.task)
    },
    initComponent: function() {
        var a = this;
        a.store = a.store || Gnt.field.ConstraintType.buildDefaultConstraintTypeList(a.L("none"));
        a.callParent(arguments);
        this.on("change", this.onFieldChange, this)
    },
    destroy: function() {
        this.destroyTaskListener();
        this.callParent()
    },
    onSetTask: function() {
        this.setValue(this.task.getConstraintType())
    },
    valueToVisible: function(e, b) {
        var c = this,
        d = [];
        var a = this.findRecordByValue(!Ext.isEmpty(e) ? e: null);
        if (a) {
            d.push(a.data)
        } else {
            if (Ext.isDefined(c.valueNotFoundText)) {
                d.push(c.valueNotFoundText)
            }
        }
        return c.displayTpl.apply(d)
    },
    applyChanges: function(a) {
        var c = this,
        b, d = c.getValue();
        a = a || c.task;
        b = Gnt.constraint.Base.getConstraintClass(d);
        a.setConstraint(d, b && b.getInitialConstraintDate(a) || null)
    },
    onFieldChange: function(b) {
        var a = this;
        if (!a.getSuppressTaskUpdate() && a.task && b) {
            a.applyChanges();
            a.task.fireEvent("taskupdated", a.task, a)
        }
    },
    statics: {
        buildDefaultConstraintTypeList: function(b) {
            var a = [];
            Ext.Array.each(Ext.ClassManager.getNamesByExpression("gntconstraint.*"),
            function(c) {
                var e = Ext.ClassManager.get(c),
                d = e.alias[0],
                f = d.split(".").pop();
                e && (a.push([f, e.L("name")]))
            });
            a = Ext.Array.sort(a,
            function(d, c) {
                return d[1] > c[1] ? 1 : -1
            });
            b && a.unshift([null, b]);
            return a
        }
    }
});
Ext.define("Gnt.field.ConstraintDate", {
    extend: "Ext.form.field.Date",
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.constraintdatefield",
    taskField: "constraintDateField",
    constructor: function(a) {
        var b = this;
        b.setSuppressTaskUpdate(true);
        b.callParent([a]);
        b.setSuppressTaskUpdate(false)
    },
    destroy: function() {
        var a = this;
        a.destroyTaskListener();
        a.callParent()
    },
    initComponent: function() {
        var a = this;
        a.callParent(arguments);
        a.task && a.setTask(a.task)
    },
    onSetTask: function(a) {
        var d = this,
        c = a.getConstraintDate(),
        b = a.getConstraintClass(),
        e = d.format || Ext.Date.defaultFormat;
        if (b) {
            d.setValue(b.getDisplayableConstraintDateForFormat(c, e, a))
        } else {
            d.setValue(c)
        }
    },
    setValue: function(c) {
        var b = this,
        a = b.task;
        b.callParent([c]);
        if (!b.getSuppressTaskUpdate() && a && c) {
            b.applyChanges();
            a.fireEvent("taskupdated", a, b)
        }
    },
    onExpand: function() {
        var a = this,
        b = a.getValue();
        a.getPicker().setValue(Ext.isDate(b) ? b: new Date())
    },
    onSelect: function(d, a) {
        var e = this,
        f = e.format,
        b = e.task,
        c = b && b.getConstraintDate();
        if (c && Ext.Date.formatContainsHourInfo(f)) {
            a.setHours(c.getHours());
            a.setMinutes(c.getMinutes());
            a.setSeconds(c.getSeconds())
        }
        e.callParent([d, a])
    },
    applyChanges: function(a) {
        var c = this,
        e = c.format || Ext.Date.defaultFormat,
        b, d;
        a = a || c.task;
        b = a.getConstraintClass();
        d = c.getValue();
        if (b && !Ext.isEmpty(d)) {
            d = b.adjustConstraintDateFromDisplayableWithFormat(d, e, a)
        } else {
            if (Ext.isEmpty(d)) {
                d = null
            }
        }
        a.setConstraintDate(d)
    }
});
Ext.define("Gnt.column.ResourceName", {
    extend: "Ext.grid.column.Column",
    alias: "widget.resourcenamecolumn",
    mixins: ["Gnt.mixin.Localizable"],
    dataIndex: "ResourceName",
    flex: 1,
    align: "left",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        Ext.apply(this, a);
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.AssignmentUnits", {
    extend: "Ext.grid.column.Number",
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.assignmentunitscolumn",
    dataIndex: "Units",
    format: "0 %",
    align: "left",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.scope = this;
        this.callParent(arguments)
    },
    renderer: function(b, c, a) {
        if (b) {
            return Ext.util.Format.number(b, this.format)
        }
    }
});
Ext.define("Gnt.widget.AssignmentGrid", {
    extend: "Ext.grid.Panel",
    alias: "widget.assignmentgrid",
    requires: ["Gnt.model.Resource", "Gnt.model.Assignment", "Gnt.column.ResourceName", "Gnt.column.AssignmentUnits", "Ext.grid.plugin.CellEditing"],
    assignmentStore: null,
    resourceStore: null,
    readOnly: false,
    cls: "gnt-assignmentgrid",
    defaultAssignedUnits: 100,
    taskId: null,
    cellEditing: null,
    assignmentUnitsEditor: null,
    bufferedRenderer: false,
    sorter: {
        sorterFn: function(b, a) {
            var d = b.getUnits(),
            c = a.getUnits();
            if ((!d && !c) || (d && c)) {
                return b.get("ResourceName") < a.get("ResourceName") ? -1 : 1
            }
            return d ? -1 : 1
        }
    },
    constructor: function(a) {
        var b = this;
        this.store = Ext.create("Ext.data.JsonStore", {
            model: "Gnt.model.AssignmentEditing"
        });
        this.columns = this.buildColumns();
        if (!this.readOnly) {
            this.plugins = this.buildPlugins()
        }
        Ext.applyIf(this, {
            selModel: {
                selType: "checkboxmodel",
                mode: "MULTI",
                checkOnly: true
            }
        });
        this.callParent(arguments)
    },
    initComponent: function() {
        this.loadResources();
        this.mon(this.resourceStore, {
            datachanged: this.loadResources,
            scope: this
        });
        this.callParent(arguments);
        this.getSelectionModel().on({
            select: this.onSelect,
            deselect: this.onDeselect,
            scope: this
        })
    },
    onSelect: function(b, a) {
        if ((!this.cellEditing || !this.cellEditing.getActiveEditor()) && !a.getUnits()) {
            a.setUnits(this.defaultAssignedUnits)
        }
    },
    onDeselect: function(b, a) {
        a.setUnits(0)
    },
    loadResources: function() {
        var e = [],
        b = this.resourceStore;
        for (var c = 0,
        a = b.getCount(); c < a; c++) {
            var d = b.getAt(c);
            e.push({
                ResourceId: d.getId(),
                ResourceName: d.getName(),
                Units: ""
            })
        }
        this.store.loadData(e)
    },
    buildPlugins: function() {
        var a = this.cellEditing = Ext.create("Ext.grid.plugin.CellEditing", {
            clicksToEdit: 1
        });
        a.on("edit", this.onEditingDone, this);
        return [a]
    },
    hide: function() {
        this.cellEditing.cancelEdit();
        this.callParent(arguments)
    },
    onEditingDone: function(a, b) {
        if (b.value) {
            this.getSelectionModel().select(b.record, true)
        } else {
            this.getSelectionModel().deselect(b.record);
            b.record.reject()
        }
    },
    buildColumns: function() {
        return [{
            xtype: "resourcenamecolumn"
        },
        {
            xtype: "assignmentunitscolumn",
            assignmentStore: this.assignmentStore,
            editor: {
                xtype: "numberfield",
                minValue: 0,
                step: 10,
                selectOnFocus: true
            }
        }]
    },
    setEditableFields: function(c) {
        if (!this.assignmentUnitsEditor) {
            this.assignmentUnitsEditor = this.down("assignmentunitscolumn").getEditor()
        }
        var b = this.assignmentStore && this.assignmentStore.taskStore,
        a = b && b.getNodeById(c);
        if (a) {
            switch (a.getSchedulingMode()) {
            case "DynamicAssignment":
                this.assignmentUnitsEditor.setReadOnly(true);
                break;
            default:
                this.assignmentUnitsEditor.setReadOnly(false)
            }
        }
    },
    loadTaskAssignments: function(e) {
        var c = this.store,
        g = this.getSelectionModel();
        this.taskId = e;
        g.deselectAll(true);
        for (var d = 0,
        b = c.getCount(); d < b; d++) {
            var a = c.getAt(d);
            a.data.Units = 0;
            a.data.Id = null;
            delete a.__id__
        }
        var f = this.assignmentStore.queryBy(function(h) {
            return h.getTaskId() == e
        });
        f.each(function(i) {
            var h = c.findRecord("ResourceId", i.getResourceId(), 0, false, true, true);
            if (h) {
                h.setUnits(i.getUnits());
                h.__id__ = i.getId();
                g.select(h, true, true)
            }
        });
        if (Ext.isSafari) {
            this.focus()
        }
        c.sort(this.sorter);
        c.getSorters().removeAll();
        this.setEditableFields(e)
    },
    saveTaskAssignments: function() {
        var a = this.assignmentStore,
        e = this.taskId;
        var d = {};
        var c = [];
        this.getSelectionModel().selected.each(function(g) {
            var f = g.getUnits();
            if (f > 0) {
                var i = g.__id__;
                if (i) {
                    d[i] = true;
                    a.getById(i).setUnits(f)
                } else {
                    var h = Ext.create(a.model);
                    h.setTaskId(e);
                    h.setResourceId(g.getResourceId());
                    h.setUnits(f);
                    d[h.internalId] = true;
                    c.push(h)
                }
            }
        });
        var b = [];
        a.each(function(f) {
            if (f.getTaskId() == e && !d[f.getId() || f.internalId]) {
                b.push(f)
            }
        });
        a.fireEvent("beforetaskassignmentschange", a, e, c);
        a.suspendAutoSync();
        a.remove(b);
        a.add(c);
        a.resumeAutoSync();
        a.fireEvent("taskassignmentschanged", a, e, c);
        if (a.autoSync) {
            a.sync()
        }
    },
    isDataChanged: function() {
        var a = this;
        return a.store && a.store.getUpdatedRecords().length > 0 || a.store.getNewRecords().length > 0 || a.store.getRemovedRecords().length > 0
    },
    isDataValid: function() {
        var a = true;
        this.store.each(function(b) {
            if (!b.isValid()) {
                a = false;
                return false
            }
        });
        return a
    }
});
Ext.define("Gnt.field.Assignment", {
    extend: "Ext.form.field.Picker",
    alias: ["widget.assignmentfield", "widget.assignmenteditor"],
    alternateClassName: "Gnt.widget.AssignmentField",
    requires: ["Gnt.widget.AssignmentGrid"],
    mixins: ["Gnt.mixin.Localizable"],
    matchFieldWidth: false,
    editable: false,
    task: null,
    assignmentStore: null,
    resourceStore: null,
    gridConfig: null,
    formatString: "{0} [{1}%]",
    expandPickerOnFocus: false,
    afterRender: function() {
        this.callParent(arguments);
        this.on("expand", this.onPickerExpand, this);
        if (this.expandPickerOnFocus) {
            this.on("focus",
            function() {
                this.expand()
            },
            this, {
                delay: 1
            })
        }
    },
    createPicker: function() {
        var a = new Gnt.widget.AssignmentGrid(Ext.apply({
            frame: true,
            floating: true,
            height: 200,
            width: 300,
            resourceStore: this.task.getResourceStore(),
            assignmentStore: this.task.getAssignmentStore(),
            fbar: this.buildButtons()
        },
        this.gridConfig || {}));
        return a
    },
    buildButtons: function() {
        return ["->", {
            text: this.L("closeText"),
            handler: function() {
                Ext.Function.defer(this.onSaveClick, Ext.isIE && !Ext.isIE9 ? 60 : 30, this)
            },
            scope: this
        },
        {
            text: this.L("cancelText"),
            handler: function() {
                this.collapse()
            },
            scope: this
        }]
    },
    setTask: function(a) {
        this.task = a;
        this.setRawValue(this.getDisplayValue(a))
    },
    onPickerExpand: function() {
        this.picker.loadTaskAssignments(this.task.getInternalId())
    },
    onSaveClick: function() {
        var b = this.picker.getSelectionModel(),
        a = b.selected;
        this.collapse();
        this.fireEvent("select", this, a);
        this.picker.saveTaskAssignments()
    },
    isDirty: function(c) {
        c = c || this.task;
        if (!c) {
            return false
        }
        var e = this.picker && this.picker.assignmentStore || c.getAssignmentStore(),
        b = c.getAssignments();
        for (var d = 0,
        a = b.length; d < a; d++) {
            if (b[d].dirty || b[d].phantom) {
                return true
            }
        }
        if (e) {
            b = e.getRemovedRecords();
            for (d = 0, a = b.length; d < a; d++) {
                if (b[d].getTaskId() == c.getInternalId()) {
                    return true
                }
            }
        }
        return false
    },
    getDisplayValue: function(c) {
        c = c || this.task;
        var e = [],
        b = c.getAssignments();
        for (var d = 0,
        a = b.length; d < a; d++) {
            var f = b[d];
            if (f.getUnits() > 0) {
                e.push(Ext.String.format(this.formatString, f.getResourceName(), f.getUnits()))
            }
        }
        return e.join(", ")
    }
});
Ext.define("Gnt.column.ResourceAssignment", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.resourceassignmentcolumn", "widget.ganttcolumn.resourceassignment"],
    requires: ["Gnt.field.Assignment"],
    mixins: ["Gnt.mixin.Localizable"],
    tdCls: "sch-assignment-cell",
    showUnits: true,
    field: null,
    dirtyCls: null,
    constructor: function(b) {
        b = b || {};
        this.text = b.text || this.L("text");
        var c = b.editor;
        var a = b.showUnits || this.showUnits;
        delete b.editor;
        b.editor = c || {};
        if (! (b.editor instanceof Ext.form.Field)) {
            b.editor = Ext.ComponentManager.create(Ext.applyIf(b.editor, {
                expandPickerOnFocus: true,
                formatString: "{0}" + (a ? " [{1}%]": "")
            }), "assignmentfield")
        }
        b.field = b.editor;
        this.callParent([b]);
        this.scope = this;
        if (this.field) {
            this.field.on("collapse",
            function() {
                this.up("ganttpanel").ganttEditingPlugin.completeEdit()
            },
            this)
        }
    },
    afterRender: function() {
        var a = this.up("treepanel").getView();
        if (a.markDirty) {
            this.dirtyCls = a.dirtyCls
        }
        this.callParent(arguments)
    },
    renderer: function(b, c, a) {
        if (this.dirtyCls && this.field.isDirty(a)) {
            c.tdCls = this.dirtyCls
        }
        return this.field.getDisplayValue(a)
    }
});
Ext.define("Gnt.column.Name", {
    extend: "Ext.tree.Column",
    alias: ["widget.namecolumn", "widget.ganttcolumn.name"],
    mixins: ["Gnt.mixin.Localizable"],
    draggable: true,
    fieldProperty: "nameField",
    field: null,
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        var b = a.editor;
        delete a.editor;
        Ext.apply(this, a);
        a.editor = b || {
            xtype: "textfield",
            allowBlank: false
        };
        this.scope = this;
        this.callParent([a])
    },
    afterRender: function() {
        if (!this.dataIndex) {
            var a = this.up("treepanel");
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    },
    renderer: function(b, c, a) {
        if (!a.isEditable(this.dataIndex)) {
            c.tdCls = (c.tdCls || "") + " sch-column-readonly"
        }
        return Ext.util.Format.htmlEncode(b)
    }
});
Ext.define("Gnt.column.Note", {
    extend: "Ext.grid.column.Column",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.notecolumn", "widget.ganttcolumn.note"],
    editor: {
        xtype: "textfield"
    },
    fieldProperty: "noteField",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.scope = this
    },
    afterRender: function() {
        var a = this.up("treepanel");
        if (!this.dataIndex) {
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    },
    renderer: function(b, c, a) {
        if (!a.isEditable(this.dataIndex)) {
            c.tdCls = (c.tdCls || "") + " sch-column-readonly"
        }
        return b
    }
});
Ext.define("Gnt.column.EndDate", {
    extend: "Ext.grid.column.Date",
    alias: ["widget.enddatecolumn", "widget.ganttcolumn.enddate"],
    requires: ["Ext.grid.CellEditor", "Gnt.field.EndDate"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 100,
    align: "left",
    editorFormat: null,
    adjustMilestones: true,
    validateStartDate: true,
    instantUpdate: false,
    keepDuration: false,
    field: null,
    fieldProperty: "endDateField",
    constructor: function(b) {
        b = b || {};
        this.text = b.text || this.L("text");
        var c = b.editor;
        var a = {
            format: b.editorFormat || b.format || this.format || Ext.Date.defaultFormat,
            instantUpdate: this.instantUpdate,
            adjustMilestones: this.adjustMilestones,
            keepDuration: this.keepDuration,
            validateStartDate: this.validateStartDate
        };
        Ext.Array.forEach(["instantUpdate", "adjustMilestones", "keepDuration", "validateStartDate"],
        function(d) {
            if (d in b) {
                a[d] = b[d]
            }
        },
        this);
        b.editor = c || a;
        if (! (b.editor instanceof Gnt.field.EndDate)) {
            Ext.applyIf(b.editor, a);
            b.editor = Ext.ComponentManager.create(b.editor, "enddatefield")
        }
        b.field = b.editor;
        this.hasCustomRenderer = true;
        this.callParent([b]);
        this.scope = this;
        this.renderer = b.renderer || this.rendererFunc;
        this.editorFormat = this.editorFormat || this.format
    },
    rendererFunc: function(b, c, a) {
        if (!b) {
            return
        }
        if (!a.isEditable(this.dataIndex)) {
            c.tdCls = (c.tdCls || "") + " sch-column-readonly"
        }
        b = this.field.valueToVisible(b, a);
        return Ext.util.Format.date(b, this.format)
    },
    afterRender: function() {
        var a = this.ownerCt.up("treepanel");
        if (!this.dataIndex) {
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.PercentDone", {
    extend: "Ext.grid.column.Number",
    alias: ["widget.percentdonecolumn", "widget.ganttcolumn.percentdone"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 50,
    format: "0",
    align: "center",
    editor: {
        xtype: "percentfield",
        decimalPrecision: 0,
        minValue: 0,
        maxValue: 100
    },
    fieldProperty: "percentDoneField",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.scope = this
    },
    afterRender: function() {
        var a = this.up("treepanel");
        if (!this.dataIndex) {
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    },
    renderer: function(b, c, a) {
        if (!a.isEditable(this.dataIndex)) {
            c.tdCls = (c.tdCls || "") + " sch-column-readonly"
        }
        return this.defaultRenderer(b, c, a)
    }
});
Ext.define("Gnt.column.StartDate", {
    extend: "Ext.grid.column.Date",
    alias: ["widget.startdatecolumn", "widget.ganttcolumn.startdate"],
    requires: ["Gnt.field.StartDate"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 100,
    align: "left",
    editorFormat: null,
    adjustMilestones: true,
    instantUpdate: false,
    keepDuration: true,
    field: null,
    fieldProperty: "startDateField",
    constructor: function(b) {
        b = b || {};
        this.text = b.text || this.L("text");
        var c = b.editor;
        var a = {
            format: b.editorFormat || b.format || this.format || Ext.Date.defaultFormat,
            instantUpdate: this.instantUpdate,
            adjustMilestones: this.adjustMilestones,
            keepDuration: this.keepDuration
        };
        Ext.Array.forEach(["instantUpdate", "adjustMilestones", "keepDuration"],
        function(d) {
            if (d in b) {
                a[d] = b[d]
            }
        },
        this);
        b.editor = c || a;
        if (! (b.editor instanceof Gnt.field.StartDate)) {
            Ext.applyIf(b.editor, a);
            b.editor = Ext.ComponentManager.create(b.editor, "startdatefield")
        }
        b.field = b.editor;
        this.hasCustomRenderer = true;
        this.callParent([b]);
        this.renderer = b.renderer || this.rendererFunc;
        this.editorFormat = this.editorFormat || this.format
    },
    afterRender: function() {
        var a = this.up("treepanel");
        var b = a.store;
        if (!this.dataIndex) {
            this.dataIndex = b.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    },
    rendererFunc: function(b, c, a) {
        if (!b) {
            return
        }
        if (!a.isEditable(this.dataIndex)) {
            c.tdCls = (c.tdCls || "") + " sch-column-readonly"
        }
        b = this.field.valueToVisible(b, a);
        return Ext.util.Format.date(b, this.format)
    }
});
Ext.define("Gnt.column.WBS", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.wbscolumn", "widget.ganttcolumn.wbs"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 40,
    align: "left",
    sortable: false,
    dataIndex: "index",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments)
    },
    renderer: function(b, c, a) {
        return a.getWBSCode()
    }
});
Ext.define("Gnt.column.Sequence", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.sequencecolumn", "widget.ganttcolumn.sequence"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 40,
    align: "right",
    sortable: false,
    dataIndex: "index",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments)
    },
    renderer: function(b, c, a) {
        return a.getSequenceNumber()
    }
});
Ext.define("Gnt.column.SchedulingMode", {
    extend: "Ext.grid.column.Column",
    requires: ["Gnt.field.SchedulingMode"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.schedulingmodecolumn", "widget.ganttcolumn.schedulingmode"],
    width: 100,
    align: "left",
    data: null,
    instantUpdate: false,
    field: null,
    fieldProperty: "schedulingModeField",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        var b = a.editor || this.editor || new Gnt.field.SchedulingMode({
            store: a.data || Gnt.field.SchedulingMode.prototype.store,
            instantUpdate: this.instantUpdate
        });
        delete a.editor;
        if (! (b instanceof Gnt.field.SchedulingMode)) {
            if (Ext.isString(b)) {
                b = {
                    xtype: b
                }
            }
            Ext.applyIf(b, {
                instantUpdate: this.instantUpdate
            });
            b = Ext.ComponentManager.create(b, "schedulingmodefield")
        }
        this.field = a.editor = b;
        this.scope = this;
        this.callParent([a])
    },
    renderer: function(b, c, a) {
        return this.field.valueToVisible(b, a)
    },
    afterRender: function() {
        this.callParent(arguments);
        var a = this.up("treepanel");
        this.mon(a, "beforeedit",
        function(b, c) {
            if (this.field.setTask) {
                this.field.setTask(c.record)
            }
        },
        this);
        if (!this.dataIndex) {
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
    }
});
Ext.define("Gnt.column.AddNew", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.addnewcolumn", "widget.ganttcolumn.addnew"],
    requires: ["Ext.form.field.ComboBox", "Ext.Editor"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 100,
    resizable: false,
    sortable: false,
    draggable: false,
    colEditor: null,
    colEditorStore: null,
    columnList: null,
    initComponent: function() {
        if (!this.text) {
            this.text = this.L("text")
        }
        this.addCls("gnt-addnewcolumn");
        this.on({
            headerclick: this.myOnHeaderClick,
            headertriggerclick: this.myOnHeaderClick,
            scope: this
        });
        this.callParent(arguments)
    },
    getGantt: function() {
        if (!this.gantt) {
            this.gantt = this.up("ganttpanel")
        }
        return this.gantt
    },
    getColEditor: function() {
        var b = this,
        a;
        if (!b.colEditor) {
            a = b.colEditor = new Ext.Editor({
                shadow: false,
                updateEl: false,
                itemId: "addNewEditor",
                renderTo: b.el,
                offsets: [20, 0],
                field: new Ext.form.field.ComboBox({
                    displayField: "text",
                    valueField: "clsName",
                    hideTrigger: true,
                    queryMode: "local",
                    forceSelection: true,
                    multiSelect: false,
                    listConfig: {
                        itemId: "addNewEditorComboList",
                        minWidth: 150
                    },
                    store: b.getColEditorStore(),
                    listeners: {
                        render: function() {
                            this.on("blur",
                            function() {
                                a.cancelEdit()
                            })
                        },
                        select: b.onSelect,
                        scope: b
                    }
                })
            })
        }
        return b.colEditor
    },
    getColEditorStore: function() {
        var a = this;
        if (!a.colEditorStore) {
            a.columnList = a.columnList || Gnt.column.AddNew.buildDefaultColumnList();
            a.colEditorStore = new Ext.data.Store({
                fields: ["text", "clsName", "config"],
                data: a.columnList,
                sorters: [{
                    property: "text",
                    direction: "ASC"
                }]
            })
        }
        return a.colEditorStore
    },
    myOnHeaderClick: function() {
        var c = this,
        b, a;
        a = c.el.down("." + Ext.baseCSSPrefix + "column-header-text");
        b = c.getColEditor();
        b.startEdit(a, "");
        b.field.reset();
        b.field.setWidth(this.getWidth() - 20);
        b.field.expand();
        return false
    },
    onSelect: function(c, a) {
        var b = this;
        b.colEditor.cancelEdit();
        b.addColumn(Ext.isArray(a) ? a[0] : a)
    },
    addColumn: function(b) {
        var e = this;
        var g = b;
        var a = e.ownerCt;
        var f = g.get("text");
        var c = g.get("config") || {};
        var d = g.get("clsName") || c.xclass || "Ext.grid.column.Column";
        Ext.require(d,
        function() {
            var h = Ext.ClassManager.get(d);
            var i = Ext.create(Ext.applyIf(c, {
                xclass: d,
                dataIndex: e.getGantt().taskStore.model.prototype[h.prototype.fieldProperty],
                text: f
            }));
            a.insert(a.items.indexOf(e), i)
        })
    },
    statics: {
        buildDefaultColumnList: function() {
            var a = [];
            Ext.Array.each(Ext.ClassManager.getNamesByExpression("widget.ganttcolumn.*"),
            function(c) {
                var b = Ext.ClassManager.get(c);
                if (b !== Gnt.column.AddNew && !Gnt.column.AddNew.prototype.isPrototypeOf(b.prototype)) {
                    a.push({
                        clsName: c,
                        text: b.prototype.localize ? b.prototype.localize("text") : b.prototype.text
                    })
                }
            });
            return Ext.Array.sort(a,
            function(d, c) {
                return d.text > c.text ? 1 : -1
            })
        }
    }
});
Ext.define("Gnt.column.EarlyStartDate", {
    extend: "Ext.grid.column.Date",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.earlystartdatecolumn", "widget.ganttcolumn.earlystartdate"],
    width: 100,
    align: "left",
    adjustMilestones: true,
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    afterRender: function() {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    rendererFunc: function(b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        return a.getDisplayStartDate(this.format, this.adjustMilestones, a.getEarlyStartDate())
    }
});
Ext.define("Gnt.column.EarlyEndDate", {
    extend: "Ext.grid.column.Date",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.earlyenddatecolumn", "widget.ganttcolumn.earlyenddate"],
    width: 100,
    align: "left",
    adjustMilestones: true,
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    afterRender: function() {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    rendererFunc: function(b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        return a.getDisplayEndDate(this.format, this.adjustMilestones, a.getEarlyEndDate())
    }
});
Ext.define("Gnt.column.LateStartDate", {
    extend: "Ext.grid.column.Date",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.latestartdatecolumn", "widget.ganttcolumn.latestartdate"],
    width: 100,
    align: "left",
    adjustMilestones: true,
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    afterRender: function() {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    rendererFunc: function(b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        return a.getDisplayStartDate(this.format, this.adjustMilestones, a.getLateStartDate())
    }
});
Ext.define("Gnt.column.LateEndDate", {
    extend: "Ext.grid.column.Date",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.lateenddatecolumn", "widget.ganttcolumn.lateenddate"],
    width: 100,
    align: "left",
    adjustMilestones: true,
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    afterRender: function() {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    rendererFunc: function(b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        return a.getDisplayEndDate(this.format, this.adjustMilestones, a.getLateEndDate())
    }
});
Ext.define("Gnt.column.Slack", {
    extend: "Ext.grid.column.Column",
    requires: ["Ext.Number", "Sch.util.Date"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.slackcolumn", "widget.ganttcolumn.slack"],
    decimalPrecision: 2,
    useAbbreviation: false,
    slackUnit: "d",
    width: 100,
    align: "left",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    afterRender: function() {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    rendererFunc: function(b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        b = a.getSlack();
        if (Ext.isNumber(b)) {
            return parseFloat(Ext.Number.toFixed(b, this.decimalPrecision)) + " " + Sch.util.Date[this.useAbbreviation ? "getShortNameOfUnit": "getReadableNameOfUnit"](this.slackUnit, b !== 1)
        }
        return ""
    }
});
Ext.define("Gnt.column.BaselineStartDate", {
    extend: "Ext.grid.column.Date",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.baselinestartdatecolumn", "widget.ganttcolumn.baselinestartdate"],
    width: 100,
    adjustMilestones: true,
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    rendererFunc: function(b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        return a.getDisplayStartDate(this.format, this.adjustMilestones, a.getBaselineStartDate(), false, true)
    }
});
Ext.define("Gnt.column.BaselineEndDate", {
    extend: "Ext.grid.column.Date",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.baselineenddatecolumn", "widget.ganttcolumn.baselineenddate"],
    width: 100,
    adjustMilestones: true,
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    rendererFunc: function(b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        return a.getDisplayEndDate(this.format, this.adjustMilestones, a.getBaselineEndDate(), false, true)
    }
});
Ext.define("Gnt.column.Milestone", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.milestonecolumn", "widget.ganttcolumn.milestone"],
    requires: ["Gnt.field.Milestone"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 50,
    align: "center",
    field: null,
    constructor: function(a) {
        a = a || {};
        a.editor = a.editor || new Gnt.field.Milestone();
        this.text = a.text || this.L("text");
        this.field = a.editor;
        this.callParent(arguments);
        this.scope = this
    },
    renderer: function(b, c, a) {
        return this.field.valueToVisible(a.isMilestone())
    }
});
Ext.define("Gnt.column.Rollup", {
    extend: "Ext.grid.Column",
    alias: ["widget.rollupcolumn", "widget.ganttcolumn.rollup"],
    mixins: ["Gnt.mixin.Localizable"],
    fieldProperty: "rollupField",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.editor = a.editor || this.editor || {
            xtype: "combobox",
            store: [[false, this.L("no")], [true, this.L("yes")]]
        };
        this.scope = this;
        this.callParent([a])
    },
    afterRender: function() {
        if (!this.dataIndex) {
            var a = this.up("treepanel");
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    },
    renderer: function(b, c, a) {
        if (!a.isEditable(this.dataIndex)) {
            c.tdCls = (c.tdCls || "") + " sch-column-readonly"
        }
        return this.L(b ? "yes": "no")
    }
});
Ext.define("Gnt.column.Calendar", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.calendarcolumn", "widget.ganttcolumn.calendar"],
    requires: ["Gnt.model.Calendar", "Gnt.field.Calendar"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 100,
    align: "left",
    instantUpdate: true,
    store: null,
    fieldProperty: "calendarIdField",
    constructor: function(a) {
        a = a || {};
        this.text = this.text || a.text || this.L("text");
        delete a.text;
        this.store = a.store || this.store || {
            xclass: "Ext.data.Store",
            model: "Gnt.model.Calendar",
            data: this.getCalendarList()
        };
        delete a.store;
        if (! (this.store instanceof Ext.data.Store)) {
            this.store = Ext.create(this.store)
        }
        this.mon(Ext.data.StoreManager, {
            add: function(c, b, d) {
                if (b instanceof Gnt.data.Calendar) {
                    this.store.loadData(this.getCalendarList())
                }
            },
            remove: function(c, b, d) {
                if (b instanceof Gnt.data.Calendar) {
                    this.store.loadData(this.getCalendarList())
                }
            },
            scope: this
        });
        this.instantUpdate = ("instantUpdate" in a) ? a.instantUpdate: this.instantUpdate;
        a.editor = a.editor || this.editor || {
            xclass: "Gnt.field.Calendar",
            store: this.store,
            instantUpdate: this.instantUpdate
        };
        this.scope = this;
        this.callParent([a])
    },
    afterRender: function() {
        if (!this.dataIndex) {
            var a = this.up("treepanel");
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    },
    renderer: function(f, g, a, d, c, b) {
        if (!f) {
            g.tdCls = "gnt-default";
            f = b.calendar ? b.calendar.calendarId: ""
        }
        var e = this.store.getById(f);
        return e ? e.getName() : ""
    },
    getCalendarList: function() {
        return Ext.Array.map(Gnt.data.Calendar.getAllCalendars(),
        function(a) {
            return {
                Id: a.calendarId,
                Name: a.name || a.calendarId
            }
        })
    }
});
Ext.define("Gnt.widget.AssignmentEditGrid", {
    extend: "Ext.grid.Panel",
    alias: "widget.assignmenteditgrid",
    requires: ["Ext.data.JsonStore", "Ext.window.MessageBox", "Ext.form.field.ComboBox", "Ext.grid.plugin.CellEditing", "Gnt.util.Data", "Gnt.data.AssignmentStore", "Gnt.data.ResourceStore", "Gnt.model.Resource", "Gnt.model.Assignment", "Gnt.column.ResourceName", "Gnt.column.AssignmentUnits"],
    mixins: ["Gnt.mixin.Localizable"],
    assignmentStore: null,
    resourceStore: null,
    readOnly: false,
    cls: "gnt-assignmentgrid",
    defaultAssignedUnits: 100,
    confirmAddResource: true,
    addResources: true,
    taskId: null,
    refreshTimeout: 100,
    resourceDupStore: null,
    resourceComboStore: null,
    assignmentUnitsEditor: null,
    constructor: function(a) {
        Ext.apply(this, a);
        this.store = a.store || new Gnt.data.AssignmentStore({
            taskStore: a.taskStore || a.assignmentStore.getTaskStore()
        });
        this.resourceDupStore = a.resourceDupStore || new Gnt.data.ResourceStore({
            taskStore: a.taskStore || a.assignmentStore.getTaskStore()
        });
        this.resourceComboStore = new Ext.data.JsonStore({
            model: this.resourceDupStore.model
        });
        if (a.addResources !== undefined) {
            this.addResources = a.addResources
        }
        this.columns = this.buildColumns();
        if (!this.readOnly) {
            this.plugins = this.buildPlugins()
        }
        this.callParent(arguments)
    },
    initComponent: function() {
        this.loadResources();
        var a = Ext.Function.createBuffered(this.loadResources, this.refreshTimeout, this, []);
        this.mon(this.resourceStore, {
            add: a,
            remove: a,
            load: a,
            clear: a
        });
        this.loadTaskAssignments();
        var b = Ext.Function.createBuffered(this.loadTaskAssignments, this.refreshTimeout, this, []);
        this.mon(this.assignmentStore, {
            add: b,
            remove: b,
            load: b,
            clear: b
        });
        this.callParent(arguments)
    },
    loadResources: function(b) {
        if (!this.resourceStore) {
            return false
        }
        var a = Gnt.util.Data.cloneModelSet(this.resourceStore,
        function(c, d) {
            if (!c.getId()) {
                c.setId(d.getInternalId())
            }
        });
        this.resourceDupStore.loadData(a);
        this.resourceComboStore.loadData(a);
        if (!b) {
            this.loadTaskAssignments()
        }
        return true
    },
    setEditableFields: function(a) {
        if (!this.assignmentUnitsEditor) {
            this.assignmentUnitsEditor = this.down("assignmentunitscolumn").getEditor()
        }
        switch (a.getSchedulingMode()) {
        case "DynamicAssignment":
            this.assignmentUnitsEditor.setReadOnly(true);
            break;
        default:
            this.assignmentUnitsEditor.setReadOnly(false)
        }
    },
    loadTaskAssignments: function(d) {
        d = d || this.taskId;
        if (!d) {
            return false
        }
        var c = this.taskStore || this.assignmentStore.getTaskStore(),
        b = c && c.getByInternalModelId(d),
        g;
        if (b) {
            g = b.assignments
        } else {
            if (!this.assignmentStore) {
                return false
            }
            g = this.assignmentStore.queryBy(function(h) {
                return h.getTaskId() == d
            })
        }
        this.taskId = d;
        var a = this.store,
        e = this.resourceDupStore,
        f = Gnt.util.Data.cloneModelSet(g,
        function(i, h) {
            var k = h.getResourceId();
            var j = e.queryBy(function(m) {
                var l = m.originalRecord;
                return (l.getId() || l.internalId) == k
            });
            if (j.getCount()) {
                j = j.first();
                i.setResourceId(j.getId() || j.internalId)
            }
        });
        a.loadData(f);
        if (b && this.rendered) {
            this.setEditableFields(b)
        }
        return true
    },
    insertAssignment: function(b, g) {
        if (!this.store) {
            return
        }
        var d = this.store.model.prototype,
        c = {};
        if (b) {
            c = b
        } else {
            c[d.unitsField] = this.defaultAssignedUnits
        }
        c[d.taskIdField] = this.taskId;
        var e = this.store.insert(0, c);
        var f = this,
        a = e[0].isValid;
        e[0].isValid = function() {
            return a.apply(this, arguments) && f.isValidAssignment(this)
        };
        if (!g) {
            this.cellEditing.startEditByPosition({
                row: 0,
                column: 0
            })
        }
        return e
    },
    isValid: function() {
        var a = true;
        this.store.each(function(b) {
            if (!b.isValid()) {
                a = false;
                return false
            }
        });
        return a
    },
    getAssignmentErrors: function(a) {
        var b = a.getResourceId();
        if (!b) {
            return [this.L("noValueText")]
        }
        if (!this.resourceDupStore.getByInternalId(b)) {
            return [Ext.String.format(this.L("noResourceText"), b)]
        }
    },
    isValidAssignment: function(a) {
        return ! this.getAssignmentErrors(a)
    },
    buildPlugins: function() {
        var a = this.cellEditing = Ext.create("Ext.grid.plugin.CellEditing", {
            clicksToEdit: 1
        });
        var b = a.startEdit;
        a.startEdit = function() {
            this.completeEdit();
            return b.apply(this, arguments)
        };
        a.on({
            beforeedit: this.onEditingStart,
            scope: this
        });
        return [a]
    },
    hide: function() {
        this.cellEditing.cancelEdit();
        return this.callParent(arguments)
    },
    onEditingStart: function(a, c) {
        var b = this.store.model.prototype;
        if (c.field == b.resourceIdField) {
            this.assignment = c.record;
            this.resourceId = c.record.getResourceId();
            this.resourceComboStore.loadData(this.resourceDupStore.getRange());
            this.resourceComboStore.filter(this.resourcesFilter)
        }
    },
    resourceRender: function(b, c, d) {
        var e = this.getAssignmentErrors(d);
        if (e && e.length) {
            c.tdCls = Ext.baseCSSPrefix + "form-invalid";
            c.tdAttr = 'data-errorqtip="' + e.join("<br>") + '"'
        } else {
            c.tdCls = "";
            c.tdAttr = 'data-errorqtip=""'
        }
        var a = this.resourceDupStore.getByInternalId(b);
        return Ext.String.htmlEncode((a && a.getName()) || b)
    },
    filterResources: function(c) {
        var d = c.getInternalId(),
        b = this.store.model.prototype.resourceIdField,
        a = true;
        if (d !== this.resourceId) {
            this.store.each(function(e) {
                if (d == e.get(b)) {
                    a = false;
                    return false
                }
            })
        }
        return a
    },
    onResourceComboAssert: function(f) {
        var e = f.getRawValue();
        if (e) {
            var a = this.resourceDupStore.findExact(f.displayField, e);
            var b = a !== -1 ? this.resourceDupStore.getAt(a) : false;
            if (!b) {
                var h = this.assignment;
                var d = this;
                var c = function(j) {
                    var k = d.resourceStore.model,
                    i = {};
                    i[k.prototype.nameField] = f.rawValue;
                    i = new k(i);
                    i.setId(i.internalId);
                    var l = d.resourceDupStore.add(i);
                    if (l && l.length) {
                        if (!j) {
                            f.getStore().add(i);
                            f.setValue(l[0].getId())
                        } else {
                            h.setResourceId(l[0].getId())
                        }
                    }
                };
                if (this.confirmAddResource) {
                    var g = Ext.String.format(this.L("confirmAddResourceText"), Ext.String.htmlEncode(e));
                    Ext.Msg.confirm(this.L("confirmAddResourceTitle"), g,
                    function(i) {
                        if (i == "yes") {
                            c(true)
                        }
                    })
                } else {
                    c()
                }
            } else {
                f.select(b, true)
            }
        }
    },
    buildColumns: function() {
        var c = this;
        this.resourceCombo = new Ext.form.field.ComboBox({
            queryMode: "local",
            store: this.resourceComboStore,
            allowBlank: false,
            editing: this.addResources,
            validateOnChange: false,
            autoSelect: false,
            forceSelection: !this.addResources,
            valueField: this.resourceComboStore.model.prototype.idProperty,
            displayField: this.resourceComboStore.model.prototype.nameField,
            queryCaching: false,
            listConfig: {
                getInnerTpl: function() {
                    return "{" + this.displayField + ":htmlEncode}"
                }
            }
        });
        if (this.addResources) {
            this.resourcesFilter = Ext.create("Ext.util.Filter", {
                filterFn: this.filterResources,
                scope: this
            });
            Ext.Function.interceptBefore(this.resourceCombo, "assertValue",
            function() {
                c.onResourceComboAssert(this)
            })
        }
        var a;
        if (this.taskId) {
            var b = this.taskStore || this.assignmentStore.getTaskStore();
            a = b && b.getByInternalModelId(this.taskId)
        }
        return [{
            xtype: "resourcenamecolumn",
            editor: this.resourceCombo,
            dataIndex: this.assignmentStore.model.prototype.resourceIdField,
            renderer: this.resourceRender,
            scope: this
        },
        {
            xtype: "assignmentunitscolumn",
            assignmentStore: this.assignmentStore,
            editor: {
                xtype: "percentfield",
                step: 10,
                readOnly: a && a.getSchedulingMode() == "DynamicAssignment"
            }
        }]
    },
    saveResources: function() {
        Gnt.util.Data.applyCloneChanges(this.resourceDupStore, this.resourceStore)
    },
    saveTaskAssignments: function() {
        this.resourceStore.suspendEvents(true);
        this.assignmentStore.suspendEvents(true);
        this.saveResources();
        var b = this.store.model,
        c = this.resourceDupStore,
        a = true;
        Gnt.util.Data.applyCloneChanges(this.store, this.assignmentStore,
        function(f) {
            var e = c.getByInternalId(this.getResourceId());
            if (!e || !e.originalRecord) {
                a = false;
                return
            }
            var d = e.originalRecord;
            f[b.prototype.resourceIdField] = d.getId() || d.internalId
        });
        this.resourceStore.resumeEvents();
        this.assignmentStore.resumeEvents();
        return a
    },
    isDataChanged: function() {
        var a = this;
        return a.store && a.store.getUpdatedRecords().length > 0 || a.store.getNewRecords().length > 0 || a.store.getRemovedRecords().length > 0
    },
    isDataValid: function() {
        var a = true;
        this.store.each(function(b) {
            if (!b.isValid()) {
                a = false;
                return false
            }
        });
        return a
    }
});
Ext.define("Gnt.widget.DependencyGrid", {
    extend: "Ext.grid.Panel",
    alias: "widget.dependencygrid",
    requires: ["Ext.data.JsonStore", "Ext.grid.plugin.CellEditing", "Ext.form.field.ComboBox", "Ext.util.Filter", "Gnt.model.Dependency", "Gnt.util.Data", "Gnt.field.Duration"],
    mixins: ["Gnt.mixin.Localizable"],
    readOnly: false,
    showCls: false,
    cls: "gnt-dependencygrid",
    task: null,
    dependencyStore: null,
    taskModel: null,
    direction: "predecessors",
    oppositeStore: null,
    taskStoreListeners: null,
    refreshTimeout: 100,
    allowParentTaskDependencies: false,
    useSequenceNumber: false,
    lagEditor: null,
    typesCombo: null,
    constructor: function(b) {
        b = b || {};
        Ext.Array.each(["idText", "taskText", "blankTaskText", "invalidDependencyText", "parentChildDependencyText", "duplicatingDependencyText", "transitiveDependencyText", "cyclicDependencyText", "typeText", "lagText", "clsText", "endToStartText", "startToStartText", "endToEndText", "startToEndText"],
        function(c) {
            if (c in b) {
                this[c] = b[c]
            }
        },
        this);
        this.store = b.store || new Ext.data.JsonStore({
            model: b.dependencyStore ? b.dependencyStore.model: "Gnt.model.Dependency"
        });
        if (!this.readOnly) {
            this.plugins = this.buildPlugins()
        }
        this.direction = b.direction || this.direction;
        if (!b.taskModel) {
            b.taskModel = Ext.ClassManager.get("Gnt.model.Task");
            if (b.dependencyStore) {
                var a = b.dependencyStore.getTaskStore();
                if (a) {
                    b.taskModel = a.model
                }
            }
        }
        if (b.oppositeStore) {
            this.setOppositeStore(b.oppositeStore)
        }
        this.callParent([b])
    },
    initComponent: function() {
        if (this.task) {
            this.setTask(this.task);
            this.loadDependencies(this.task)
        }
        this.columns = this.buildColumns();
        this.callParent(arguments)
    },
    destroy: function() {
        if (this.deferredStoreBind) {
            this.tasksCombo.un("render", this.bindTaskStore, this)
        }
        this.tasksCombo.destroy();
        this.typesCombo.destroy();
        this.lagEditor.destroy();
        this.callParent(arguments);
        this.cellEditing.destroy()
    },
    setTask: function(a) {
        if (!a) {
            return
        }
        this.task = a;
        var b = a.dependencyStore || a.getTaskStore().dependencyStore;
        if (b && b !== this.dependencyStore) {
            if (this.dependencyStore) {
                this.mun(this.dependencyStore, this.onDependencyStoreDataChanged, this)
            }
            this.dependencyStore = b;
            if (this.typesCombo) {
                this.typesCombo.store.filter()
            }
            this.mon(this.dependencyStore, this.onDependencyStoreDataChanged, this)
        }
    },
    onDependencyStoreDataChanged: function() {
        this.loadDependencies()
    },
    buildPlugins: function() {
        var a = this.cellEditing = new Ext.grid.plugin.CellEditing({
            clicksToEdit: 1
        });
        a.on({
            beforeedit: this.onEditingStart,
            edit: this.onEditingDone,
            scope: this
        });
        return [a]
    },
    hide: function() {
        this.cellEditing.cancelEdit();
        this.callParent(arguments)
    },
    onEditingStart: function(a, c) {
        var b = this.store.model.prototype;
        switch (c.field) {
        case b.lagField:
            this.lagEditor.durationUnit = c.record.getLagUnit();
            break;
        case b.typeField:
            this.typesCombo.store.filter();
            if (this.typesCombo.store.count() < 2) {
                return false
            }
            break
        }
    },
    onEditingDone: function(a, c) {
        var b = this.store.model.prototype;
        if (c.field == b.lagField) {
            c.record.setLagUnit(this.lagEditor.durationUnit)
        }
        this.getView().refresh()
    },
    dependencyTypeRender: function(b) {
        var a = this.store.model.Type;
        switch (b) {
        case a.EndToStart:
            return this.L("endToStartText");
        case a.StartToStart:
            return this.L("startToStartText");
        case a.EndToEnd:
            return this.L("endToEndText");
        case a.StartToEnd:
            return this.L("startToEndText")
        }
        return b
    },
    taskValidate: function(b, a) {
        if (!b) {
            return [this.L("blankTaskText")]
        }
        if (!a.isValid()) {
            var c = this.getDependencyErrors(a);
            if (c && c.length) {
                return c
            }
            return [this.L("invalidDependencyText")]
        }
    },
    taskRender: function(d, e, b) {
        var f = this.taskValidate(d, b),
        a;
        if (f && f.length) {
            e.tdCls = Ext.baseCSSPrefix + "form-invalid";
            e.tdAttr = 'data-errorqtip="' + f.join("<br>") + '"'
        } else {
            e.tdCls = "";
            e.tdAttr = 'data-errorqtip=""'
        }
        var c = this.dependencyStore && this.dependencyStore.getTaskStore();
        if (c) {
            a = c.getByInternalModelId(d);
            return (a && Ext.String.htmlEncode(a.getName())) || ""
        }
        return ""
    },
    filterTasks: function(a) {
        var c = this,
        b = a.getInternalId(),
        d;
        if (this.direction === "predecessors") {
            d = "getSourceId"
        } else {
            d = "getTargetId"
        }
        return b != this.task.getInternalId() && !this.task.contains(a) && !a.contains(this.task) && (this.allowParentTaskDependencies || a.isLeaf())
    },
    bindTaskStore: function() {
        var c = this.dependencyStore && this.dependencyStore.getTaskStore();
        if (c) {
            if (!this.taskStoreListeners) {
                var d = Ext.Function.createBuffered(this.bindTaskStore, this.refreshTimeout, this, []);
                this.taskStoreListeners = this.mon(c, {
                    nodeappend: d,
                    nodeinsert: d,
                    noderemove: d,
                    update: d,
                    refresh: d,
                    clear: d,
                    "nodestore-datachange-end": d,
                    scope: this,
                    destroyable: true
                })
            }
            var b = new Ext.data.JsonStore({
                model: c.model,
                sorters: c.model.prototype.nameField
            });
            var a = c.getRootNode();
            b.loadData(Gnt.util.Data.cloneModelSet(c.toArray(),
            function(f, e) {
                if (e === a || e.hidden) {
                    return false
                }
                if (!e.getId()) {
                    f.setId(e.getPhantomId())
                }
            }));
            this.tasksFilter = new Ext.util.Filter({
                filterFn: this.filterTasks,
                scope: this
            });
            b.filter(this.tasksFilter);
            this.tasksCombo.bindStore(b)
        }
    },
    buildTasksCombo: function() {
        var a = this;
        return new Ext.form.field.ComboBox({
            queryMode: "local",
            allowBlank: false,
            editing: false,
            forceSelection: true,
            valueField: this.taskModel.prototype.idProperty,
            displayField: this.taskModel.prototype.nameField,
            queryCaching: false,
            listConfig: {
                getInnerTpl: function() {
                    return "{" + this.displayField + ":htmlEncode}"
                }
            },
            validator: function(b) {
                if (!b) {
                    return a.L("blankTaskText")
                }
                return true
            }
        })
    },
    filterAllowedTypes: function(b) {
        if (!this.dependencyStore || !this.dependencyStore.allowedDependencyTypes) {
            return true
        }
        var e = this.dependencyStore.allowedDependencyTypes;
        var f = this.store.model.Type;
        for (var c = 0,
        a = e.length; c < a; c++) {
            var d = f[e[c]];
            if (b.getId() == d) {
                return true
            }
        }
        return false
    },
    buildTypesCombo: function() {
        var b = this.store.model.Type;
        this.typesFilter = new Ext.util.Filter({
            filterFn: this.filterAllowedTypes,
            scope: this
        });
        var a = new Ext.data.ArrayStore({
            fields: [{
                name: "id",
                type: "int"
            },
            "text"],
            data: [[b.EndToStart, this.L("endToStartText")], [b.StartToStart, this.L("startToStartText")], [b.EndToEnd, this.L("endToEndText")], [b.StartToEnd, this.L("startToEndText")]]
        });
        a.filter(this.typesFilter);
        return new Ext.form.field.ComboBox({
            triggerAction: "all",
            queryMode: "local",
            editable: false,
            valueField: "id",
            displayField: "text",
            store: a
        })
    },
    buildLagEditor: function() {
        return new Gnt.field.Duration({
            minValue: Number.NEGATIVE_INFINITY
        })
    },
    buildColumns: function() {
        var d = this,
        b = this.store.model.prototype,
        f = this.store.model.Type,
        e = [],
        a = this.dependencyStore && this.dependencyStore.getTaskStore();
        this.tasksCombo = this.buildTasksCombo();
        if (!a) {
            this.deferredStoreBind = true;
            this.tasksCombo.on("render", this.bindTaskStore, this)
        } else {
            this.bindTaskStore()
        }
        var c = {};
        if (this.useSequenceNumber) {
            c = {
                text: this.L("snText"),
                dataIndex: b.fromField,
                renderer: function(j, k, g) {
                    var h = d.dependencyStore && d.dependencyStore.getTaskStore(),
                    i = h && h.getNodeById(g.get("From"));
                    return i ? i.getSequenceNumber() : ""
                },
                width: 50
            }
        } else {
            c = {
                text: this.L("idText"),
                dataIndex: b.fromField,
                width: 50
            }
        }
        e.push(c, {
            text: this.L("taskText"),
            dataIndex: b[this.direction === "predecessors" ? "fromField": "toField"],
            flex: 1,
            editor: this.tasksCombo,
            renderer: function(h, i, g) {
                return d.taskRender(h, i, g)
            }
        });
        this.lagEditor = this.buildLagEditor();
        this.typesCombo = this.buildTypesCombo();
        e.push({
            text: this.L("typeText"),
            dataIndex: b.typeField,
            width: 120,
            renderer: function(g) {
                return d.dependencyTypeRender(g)
            },
            editor: this.typesCombo
        },
        {
            text: this.L("lagText"),
            dataIndex: b.lagField,
            width: 100,
            editor: this.lagEditor,
            renderer: function(h, i, g) {
                return d.lagEditor.valueToVisible(h, g.get(b.lagUnitField), 2)
            }
        },
        {
            text: this.L("clsText"),
            dataIndex: b.clsField,
            hidden: !this.showCls,
            width: 100
        });
        return e
    },
    insertDependency: function(b, h) {
        if (!this.dependencyStore) {
            return
        }
        var e = this.task.getInternalId(),
        d = this.store.model.prototype,
        c = {},
        g = this;
        if (b) {
            c = b
        } else {
            c[d.typeField] = this.typesCombo.store.getAt(0).getId();
            c[d.lagField] = 0;
            c[d.lagUnitField] = "d"
        }
        if (this.direction === "predecessors") {
            c[d.toField] = e
        } else {
            c[d.fromField] = e
        }
        var f = this.store.insert(0, c);
        if (f.length) {
            var a = f[0].isValid;
            f[0].isValid = function() {
                return a.call(this, false) && g.isValidDependency(this)
            }
        }
        if (!h) {
            this.cellEditing.startEditByPosition({
                row: 0,
                column: 1
            })
        }
        return f
    },
    onOppositeStoreChange: function() {
        this.getView().refresh()
    },
    setOppositeStore: function(a) {
        var b = {
            update: this.onOppositeStoreChange,
            datachanged: this.onOppositeStoreChange,
            scope: this
        };
        if (this.oppositeStore) {
            this.mun(this.oppositeStore, b)
        }
        this.oppositeStore = a;
        this.mon(this.oppositeStore, b)
    },
    loadDependencies: function(b) {
        var c = this;
        b = b || this.task;
        if (!b) {
            return
        }
        if (this.task !== b) {
            this.setTask(b)
        }
        var d;
        if (this.direction === "predecessors") {
            d = b.getIncomingDependencies(true);
            if (!this.oppositeStore) {
                this.oppositeData = b.getOutgoingDependencies(true)
            }
        } else {
            d = b.getOutgoingDependencies(true);
            if (!this.oppositeStore) {
                this.oppositeData = b.getIncomingDependencies(true)
            }
        }
        var a = Gnt.util.Data.cloneModelSet(d,
        function(f) {
            var e = f.isValid;
            f.isValid = function() {
                return e.call(this, false) && c.isValidDependency(this)
            }
        });
        this.store.loadData(a);
        this.fireEvent("loaddependencies", this, this.store, a, b)
    },
    getDependencyErrors: function(c) {
        var h = this,
        j = h.dependencyStore,
        d = h.task.getInternalId(),
        b = d,
        i = [];
        if (h.direction === "predecessors") {
            d = c.getSourceId()
        } else {
            b = c.getTargetId()
        }
        var f = j.getSourceTask(d);
        var e = j.getTargetTask(b);
        h.store.each(function(n) {
            var m = n.getSourceId(),
            l = n.getTargetId();
            if ((d == m) && (b == l) && (n !== c)) {
                i.push(h.L("duplicatingDependencyText"));
                return false
            }
        });
        if (i.length) {
            return i
        }
        var k = h.store.getRange();
        k.splice(Ext.Array.indexOf(k, c), 1);
        var a = h.task[h.direction];
        var g = j.getDependencyError(c, k, a);
        if (g) {
            switch (g) {
            case - 3 : case - 8 : case - 5 : case - 6 : return [h.L("transitiveDependencyText")];
            case - 4 : case - 7 : return [h.L("cyclicDependencyText")];
            case - 9 : return [h.L("parentChildDependencyText")]
            }
            return [this.L("invalidDependencyText")]
        }
        return i
    },
    isValidDependency: function(a) {
        var b = this.getDependencyErrors(a);
        return ! b || !b.length
    },
    isValid: function() {
        var a = true;
        this.store.each(function(b) {
            if (!b.isValid()) {
                a = false;
                return false
            }
        });
        return a
    },
    saveDependencies: function() {
        if (!this.dependencyStore || !this.isValid()) {
            return
        }
        Gnt.util.Data.applyCloneChanges(this.store, this.dependencyStore)
    },
    isDataChanged: function() {
        var a = this;
        return a.store && a.store.getUpdatedRecords().length > 0 || a.store.getNewRecords().length > 0 || a.store.getRemovedRecords().length > 0
    },
    isDataValid: function() {
        return this.isValid()
    }
});
Ext.define("Gnt.widget.taskeditor.TaskForm", {
    extend: "Ext.form.Panel",
    alias: "widget.taskform",
    requires: ["Gnt.model.Task", "Ext.form.FieldSet", "Ext.form.FieldContainer", "Ext.form.field.Text", "Ext.form.field.Date", "Gnt.field.Percent", "Gnt.field.StartDate", "Gnt.field.EndDate", "Gnt.field.Duration", "Gnt.field.SchedulingMode", "Gnt.field.Effort", "Gnt.field.ConstraintType", "Gnt.field.ConstraintDate"],
    mixins: ["Gnt.mixin.Localizable"],
    alternateClassName: ["Gnt.widget.TaskForm"],
    task: null,
    taskBuffer: null,
    taskStore: null,
    highlightTaskUpdates: true,
    showGeneral: true,
    showBaseline: true,
    editBaseline: false,
    showCalendar: false,
    showSchedulingMode: false,
    showWbsCode: false,
    showRollup: false,
    showConstraint: false,
    l10n: {
        taskNameText: "Name",
        durationText: "Duration",
        datesText: "Dates",
        baselineText: "Baseline",
        startText: "Start",
        finishText: "Finish",
        percentDoneText: "Percent Complete",
        baselineStartText: "Start",
        baselineFinishText: "Finish",
        baselinePercentDoneText: "Percent Complete",
        effortText: "Effort",
        invalidEffortText: "Invalid effort value",
        calendarText: "Calendar",
        schedulingModeText: "Scheduling Mode",
        wbsCodeText: "WBS code",
        "Constraint Type": "Constraint Type",
        "Constraint Date": "Constraint Date"
    },
    taskNameConfig: null,
    durationConfig: null,
    startConfig: null,
    finishConfig: null,
    percentDoneConfig: null,
    baselineStartConfig: null,
    baselineFinishConfig: null,
    baselinePercentDoneConfig: null,
    effortConfig: null,
    calendarConfig: null,
    schedulingModeConfig: null,
    wbsCodeConfig: null,
    rollupConfig: null,
    constraintTypeConfig: null,
    constraintDateConfig: null,
    autoScroll: true,
    defaults: {
        labelWidth: 110
    },
    isTaskEditorSubComponent: true,
    constructor: function(b) {
        b = b || {};
        this.showBaseline = b.showBaseline;
        this.editBaseline = b.editBaseline;
        var a = b.taskStore ? b.taskStore.model.prototype: Gnt.model.Task.prototype;
        this.fieldNames = {
            baselineEndDateField: a.baselineEndDateField,
            baselinePercentDoneField: a.baselinePercentDoneField,
            baselineStartDateField: a.baselineStartDateField,
            calendarIdField: a.calendarIdField,
            clsField: a.clsField,
            draggableField: a.draggableField,
            durationField: a.durationField,
            durationUnitField: a.durationUnitField,
            effortField: a.effortField,
            effortUnitField: a.effortUnitField,
            endDateField: a.endDateField,
            manuallyScheduledField: a.manuallyScheduledField,
            nameField: a.nameField,
            percentDoneField: a.percentDoneField,
            resizableField: a.resizableField,
            rollupField: a.rollupField,
            schedulingModeField: a.schedulingModeField,
            startDateField: a.startDateField,
            noteField: a.noteField,
            constraintTypeField: a.constraintTypeField,
            constraintDateField: a.constraintDateField
        };
        Ext.apply(this, b, {
            border: false,
            layout: "anchor",
            defaultType: "textfield"
        });
        if (this.task) {
            this.fieldNames = this.getFieldNames(this.task)
        }
        if (!this.items) {
            this.buildFields()
        }
        this.callParent(arguments);
        if (this.task) {
            this.loadRecord(this.task, this.taskBuffer)
        }
        this.addBodyCls("gnt-taskeditor-taskform")
    },
    getFieldNames: function(b) {
        if (!b) {
            return
        }
        var a = {};
        for (var c in this.fieldNames) {
            a[c] = b[c]
        }
        return a
    },
    renameFields: function(b) {
        var a = this.getFieldNames(b);
        if (!a) {
            return
        }
        var d = this.getForm(),
        f = false,
        e;
        for (var c in this.fieldNames) {
            e = d.findField(this.fieldNames[c]);
            if (e && a[c] && a[c] != e.name) {
                f = true;
                e.name = a[c]
            }
        }
        if (f) {
            this.fieldNames = a
        }
    },
    buildFields: function() {
        var d = this,
        e = this.fieldNames,
        c = this.task,
        b = this.taskStore;
        var g = function(f) {
            return c ? c.get(e[f]) : ""
        };
        var a = function(i, f) {
            var h = {
                taskStore: d.taskStore,
                task: d.task,
                highlightTaskUpdates: d.highlightTaskUpdates
            };
            if (!i.readOnly && d.task) {
                h.readOnly = !d.task.isEditable(i.name)
            }
            return Ext.apply(i, h, f)
        };
        this.items = this.items || [];
        if (this.showGeneral) {
            this.items.push({
                xtype: "fieldcontainer",
                layout: "hbox",
                defaults: {
                    allowBlank: false
                },
                items: [a({
                    xtype: "textfield",
                    fieldLabel: this.L("taskNameText"),
                    name: e.nameField,
                    labelWidth: 110,
                    flex: 1,
                    value: g(e.nameField)
                },
                this.taskNameConfig), a({
                    xtype: "durationfield",
                    fieldLabel: this.L("durationText"),
                    name: e.durationField,
                    labelWidth: 90,
                    width: 170,
                    value: g(e.durationField)
                },
                this.durationConfig)]
            },
            a({
                xtype: "percentfield",
                fieldLabel: this.L("percentDoneText"),
                name: e.percentDoneField,
                margin: "0 0 0 8",
                width: 200,
                allowBlank: false,
                value: g(e.percentDoneField)
            },
            this.percentDoneConfig), {
                xtype: "fieldset",
                title: this.L("datesText"),
                layout: "hbox",
                defaults: {
                    labelWidth: 110,
                    allowBlank: false
                },
                items: [a({
                    xtype: "startdatefield",
                    fieldLabel: this.L("startText"),
                    width: 260,
                    name: e.startDateField,
                    value: g(e.startDateField)
                },
                this.startConfig), a({
                    xtype: "enddatefield",
                    fieldLabel: this.L("finishText"),
                    flex: 1,
                    labelWidth: 110,
                    name: e.endDateField,
                    value: g(e.endDateField)
                },
                this.finishConfig)]
            },
            a({
                xtype: "effortfield",
                fieldLabel: this.L("effortText"),
                name: e.effortField,
                invalidText: this.L("invalidEffortText"),
                width: 200,
                allowBlank: true,
                value: g(e.effortField)
            },
            this.effortConfig))
        }
        if (this.showBaseline) {
            this.items.push({
                xtype: "fieldset",
                title: this.L("baselineText"),
                layout: "hbox",
                defaultType: "datefield",
                defaults: {
                    labelWidth: 110,
                    width: 260,
                    cls: "gnt-baselinefield"
                },
                items: [a({
                    fieldLabel: this.L("baselineStartText"),
                    name: e.baselineStartDateField,
                    value: g(e.baselineStartDateField),
                    readOnly: !this.editBaseline
                },
                this.baselineStartConfig), a({
                    fieldLabel: this.L("baselineFinishText"),
                    name: e.baselineEndDateField,
                    flex: 1,
                    value: g(e.baselineEndDateField),
                    readOnly: !this.editBaseline
                },
                this.baselineFinishConfig)]
            },
            a({
                xtype: "percentfield",
                fieldLabel: this.L("baselinePercentDoneText"),
                name: e.baselinePercentDoneField,
                labelWidth: 110,
                width: 200,
                cls: "gnt-baselinefield",
                value: g(e.baselinePercentDoneField),
                readOnly: !this.editBaseline
            },
            this.baselinePercentDoneConfig))
        }
        if (this.showCalendar) {
            this.items.push(a({
                xtype: "calendarfield",
                fieldLabel: this.L("calendarText"),
                width: 260,
                name: e.calendarIdField,
                value: g(e.calendarIdField)
            },
            this.calendarConfig))
        }
        if (this.showSchedulingMode) {
            this.items.push(a({
                xtype: "schedulingmodefield",
                fieldLabel: this.L("schedulingModeText"),
                width: 260,
                name: e.schedulingModeField,
                value: g(e.schedulingModeField),
                allowBlank: false
            },
            this.schedulingModeConfig))
        }
        if (this.showWbsCode) {
            this.items.push(a({
                xtype: "textfield",
                fieldLabel: this.L("wbsCodeText"),
                name: "wbsCode",
                width: 260,
                readOnly: true,
                value: this.task && this.task.getWBSCode()
            },
            this.wbsCodeConfig))
        }
        if (this.showRollup) {
            this.items.push(a({
                xtype: "checkboxfield",
                fieldLabel: this.L("rollupText"),
                name: e.rollupField,
                value: g(e.rollupField)
            },
            this.rollupConfig))
        }
        if (this.showConstraint) {
            this.items.push(a({
                xtype: "constrainttypefield",
                fieldLabel: this.L("Constraint Type"),
                name: e.constraintTypeField,
                width: 260,
                value: g(e.constraintTypeField)
            },
            this.constraintTypeConfig), a({
                xtype: "constraintdatefield",
                fieldLabel: this.L("Constraint Date"),
                name: e.constraintDateField,
                width: 260,
                value: g(e.constraintDateField)
            },
            this.constraintDateConfig))
        }
    },
    setSuppressTaskUpdate: function(b) {
        var a = this.getForm().getFields();
        a.each(function(c) {
            c.setSuppressTaskUpdate && c.setSuppressTaskUpdate(b)
        })
    },
    loadRecord: function(b, a) {
        if (b && b !== this.task) {
            this.renameFields(b)
        }
        this.task = b;
        this.taskBuffer = a;
        if (!this.taskBuffer) {
            this.taskBuffer = b.copy();
            this.taskBuffer.taskStore = b.taskStore
        }
        var d = this,
        c = d.getForm();
        c._record = b;
        this.suspendLayouts();
        Ext.iterate(b.getData(),
        function(e, g) {
            var f = c.findField(e);
            if (f) {
                if (f.setTask) {
                    f.setSuppressTaskUpdate(true);
                    f.setTask(d.taskBuffer);
                    f.setSuppressTaskUpdate(false)
                } else {
                    f.setValue(g);
                    if (!f.disabled) {
                        if (f.editable === false) {
                            if (!d.taskBuffer.isEditable(f.name)) {
                                f.setReadOnly(true)
                            } else {
                                if (f.inputEl) {
                                    f.setReadOnly(false);
                                    f.inputEl.dom.readOnly = true
                                }
                            }
                        } else {
                            f.setReadOnly(!d.taskBuffer.isEditable(f.name))
                        }
                    }
                }
                if (c.trackResetOnLoad) {
                    f.resetOriginalValue()
                }
            }
        });
        this.resumeLayouts(true);
        this.fireEvent("afterloadrecord", this, b)
    },
    updateRecord: function(c) {
        var e = this,
        d, b;
        c = c || this.task;
        var a = function() {
            e.setSuppressTaskUpdate(true);
            var f = e.getForm().getFields();
            c.beginEdit();
            f.each(function(h) {
                var g = c.getField(h.name);
                if (h.name == e.fieldNames.constraintTypeField) {
                    d = h
                } else {
                    if (h.name == e.fieldNames.constraintDateField) {
                        b = h
                    } else {
                        if (h.applyChanges) {
                            h.applyChanges(c)
                        } else {
                            if (g && g.persist) {
                                c.set(h.name, h.getValue())
                            }
                        }
                    }
                }
            });
            c.endEdit();
            if (d && b && c.setConstraint) {
                c.setConstraint(d.getValue(), b.getValue())
            }
            e.setSuppressTaskUpdate(false);
            e.fireEvent("afterupdaterecord", e, c)
        };
        if (c && e.fireEvent("beforeupdaterecord", e, c, a) !== false) {
            a();
            return true
        }
        return false
    },
    isDataChanged: function() {
        return this.isDirty()
    }
});
Ext.define("Gnt.widget.taskeditor.TaskEditor", {
    extend: "Ext.tab.Panel",
    alias: "widget.taskeditor",
    requires: ["Ext.panel.Panel", "Ext.form.Panel", "Gnt.widget.taskeditor.TaskForm", "Gnt.widget.AssignmentEditGrid", "Gnt.widget.DependencyGrid", "Gnt.field.Calendar", "Gnt.field.SchedulingMode", "Ext.form.field.HtmlEditor", "Gnt.util.Data"],
    mixins: ["Gnt.mixin.Localizable"],
    margin: "5 0 0 0",
    alternateClassName: ["Gnt.widget.TaskEditor"],
    border: false,
    plain: true,
    defaults: {
        margin: 5,
        border: false
    },
    task: null,
    taskStore: null,
    assignmentStore: null,
    resourceStore: null,
    taskFormClass: "Gnt.widget.taskeditor.TaskForm",
    advancedFormClass: "Gnt.widget.taskeditor.TaskForm",
    showAssignmentGrid: true,
    showDependencyGrid: true,
    allowParentTaskDependencies: true,
    showNotes: true,
    showStyle: true,
    showAdvancedForm: true,
    showRollup: false,
    showBaseline: true,
    taskFormConfig: null,
    dependencyGridClass: "Gnt.widget.DependencyGrid",
    dependencyGridConfig: null,
    assignmentGridClass: "Gnt.widget.AssignmentEditGrid",
    assignmentGridConfig: null,
    styleFormConfig: null,
    advancedFormConfig: null,
    notesConfig: null,
    notesPanel: null,
    notesEditor: null,
    height: 340,
    width: 600,
    layout: "fit",
    taskForm: null,
    assignmentGrid: null,
    dependencyGrid: null,
    advancedForm: null,
    stylingText: "Styling",
    clsText: "CSS Class",
    backgroundText: "Background",
    doneBackgroundText: "Progress Background",
    clonedStores: null,
    constructor: function(b) {
        var e = this;
        b = b || {};
        Ext.apply(this, b);
        this.taskFormConfig = this.taskFormConfig || {};
        Ext.applyIf(this.taskFormConfig, {
            showBaseline: this.showBaseline,
            showRollup: false
        });
        var d = this.clonedStores = (this.task || this.taskStore) ? this.cloneStores() : {};
        var a = [];
        this.taskForm = Ext.create(this.taskFormClass || "Gnt.widget.taskeditor.TaskForm", Ext.applyIf(this.taskFormConfig, {
            task: this.task,
            taskStore: this.taskStore
        }));
        a.push(this.taskForm);
        if (this.showDependencyGrid) {
            this.dependencyGrid = Ext.create(this.dependencyGridClass, Ext.apply({
                allowParentTaskDependencies: this.allowParentTaskDependencies,
                taskModel: this.taskStore.model,
                task: this.task,
                margin: 5,
                tbar: {
                    layout: "auto",
                    items: [{
                        xtype: "button",
                        iconCls: "gnt-action-add",
                        text: this.L("addDependencyText"),
                        handler: function() {
                            e.dependencyGrid.insertDependency()
                        }
                    },
                    {
                        xtype: "button",
                        iconCls: "gnt-action-remove",
                        text: this.L("dropDependencyText"),
                        itemId: "drop-dependency-btn",
                        disabled: true,
                        handler: function() {
                            var f = e.dependencyGrid.getSelectionModel().getSelection();
                            if (f && f.length) {
                                e.dependencyGrid.store.remove(f)
                            }
                        }
                    }]
                },
                listeners: {
                    selectionchange: function(h, g) {
                        var f = e.dependencyGrid;
                        if (!f.dropDepBtn) {
                            f.dropDepBtn = f.down("#drop-dependency-btn")
                        }
                        f.dropDepBtn && f.dropDepBtn.setDisabled(!g.length)
                    }
                }
            },
            this.dependencyGridConfig));
            a.push(this.dependencyGrid)
        }
        if (this.showAssignmentGrid && this.assignmentStore && this.resourceStore) {
            if (!d.assignmentStore) {
                d.assignmentStore = this.cloneAssignmentStore(this.task)
            }
            if (!d.resourceStore) {
                d.resourceStore = this.cloneResourceStore(this.task)
            }
            this.assignmentGrid = Ext.create(this.assignmentGridClass, Ext.apply({
                assignmentStore: this.assignmentStore,
                resourceStore: this.resourceStore,
                store: d.assignmentStore,
                resourceDupStore: d.resourceStore,
                tbar: {
                    layout: "auto",
                    items: [{
                        xtype: "button",
                        iconCls: "gnt-action-add",
                        text: this.L("addAssignmentText"),
                        handler: function() {
                            e.assignmentGrid.insertAssignment()
                        }
                    },
                    {
                        xtype: "button",
                        iconCls: "gnt-action-remove",
                        text: this.L("dropAssignmentText"),
                        itemId: "drop-assignment-btn",
                        disabled: true,
                        handler: function() {
                            var f = e.assignmentGrid.getSelectionModel().getSelection();
                            if (f && f.length) {
                                e.assignmentGrid.store.remove(f)
                            }
                        }
                    }]
                },
                listeners: {
                    afterrender: {
                        fn: function(f) {
                            f.loadTaskAssignments(e.task.get(e.task.idProperty))
                        },
                        single: true
                    },
                    selectionchange: function(h, g) {
                        var f = e.assignmentGrid;
                        if (!f.dropBtn) {
                            f.dropBtn = f.down("#drop-assignment-btn")
                        }
                        f.dropBtn && f.dropBtn.setDisabled(!g.length)
                    }
                }
            },
            this.assignmentGridConfig));
            a.push(this.assignmentGrid)
        }
        if (this.showAdvancedForm) {
            this.advancedFormConfig = this.advancedFormConfig || {};
            this.advancedForm = Ext.create(this.advancedFormClass || "Gnt.widget.taskeditor.TaskForm", Ext.applyIf(this.advancedFormConfig, {
                showGeneral: false,
                showBaseline: false,
                showCalendar: true,
                showSchedulingMode: true,
                showWbsCode: true,
                showConstraint: true,
                showRollup: this.showRollup,
                task: this.task,
                taskStore: this.taskStore
            }));
            a.push(this.advancedForm)
        }
        if (this.showNotes) {
            this.notesEditor = Ext.create("Ext.form.field.HtmlEditor", Ext.apply({
                listeners: {
                    afterrender: function(f) {
                        e.notesEditor.setValue(e.task.get(e.task.noteField))
                    }
                },
                readOnly: this.task && !this.task.isEditable(this.task.noteField),
                isTaskEditorSubComponent: true,
                isDataChanged: function() {
                    return this.isDirty()
                }
            },
            this.notesConfig));
            this.notesPanel = Ext.create("Ext.panel.Panel", {
                border: false,
                layout: "fit",
                items: this.notesEditor
            });
            a.push(this.notesPanel)
        }
        if (!this.taskForm.title) {
            this.taskForm.title = this.L("generalText")
        }
        if (this.dependencyGrid && !this.dependencyGrid.title) {
            this.dependencyGrid.title = this.L("dependencyText")
        }
        if (this.assignmentGrid && !this.assignmentGrid.title) {
            this.assignmentGrid.title = this.L("resourcesText")
        }
        if (this.advancedForm && !this.advancedForm.title) {
            this.advancedForm.title = this.L("advancedText")
        }
        if (this.notesPanel && !this.notesPanel.title) {
            this.notesPanel.title = this.L("notesText")
        }
        if (this.styleForm && !this.styleForm.title) {
            this.styleForm.title = this.stylingText
        }
        var c = this.items;
        if (c) {
            a.push.apply(a, Ext.isArray(c) ? c: [c]);
            delete b.items
        }
        this.items = a;
        if (a.length <= 1) {
            b.tabBar = b.tabBar || {};
            Ext.applyIf(b.tabBar, {
                hidden: true
            })
        }
        this.callParent(arguments)
    },
    getTaskStore: function() {
        return this.taskStore || this.task && this.task.getTaskStore()
    },
    cloneTaskStore: function(b, c) {
        var a = this.getTaskStore();
        if (!a) {
            return null
        }
        var d = new(Ext.getClass(a))(Ext.apply({
            isCloned: true,
            storeId: null,
            calendar: a.getCalendar(),
            model: a.model,
            weekendsAreWorkdays: a.weekendsAreWorkdays,
            cascadeChanges: a.cascadeChanges,
            batchSync: false,
            recalculateParents: false,
            skipWeekendsDuringDragDrop: a.skipWeekendsDuringDragDrop,
            moveParentAsGroup: a.moveParentAsGroup,
            enableDependenciesForParentTasks: a.enableDependenciesForParentTasks,
            availabilitySearchLimit: a.availabilitySearchLimit,
            dependenciesCalendar: "project",
            proxy: {
                type: "memory",
                reader: {
                    type: "json"
                }
            }
        },
        c));
        this.mon(a, {
            calendarset: function(e, f) {
                d.setCalendar(f)
            }
        });
        return d
    },
    cloneDependencyStore: function(b, d) {
        var c = this.getTaskStore();
        var a = this.dependencyStore || c && c.getDependencyStore();
        if (!a) {
            return null
        }
        return new(Ext.getClass(a))(Ext.apply({
            isCloned: true,
            model: a.model,
            strictDependencyValidation: a.strictDependencyValidation,
            allowedDependencyTypes: a.allowedDependencyTypes,
            proxy: {
                type: "memory",
                reader: {
                    type: "json"
                }
            }
        },
        d))
    },
    cloneAssignmentStore: function(b, d) {
        var c = this.getTaskStore();
        var a = this.assignmentStore || c && c.getAssignmentStore();
        if (!a) {
            return null
        }
        return new(Ext.getClass(a))(Ext.apply({
            isCloned: true,
            model: a.model,
            proxy: {
                type: "memory",
                reader: {
                    type: "json"
                }
            }
        },
        d))
    },
    cloneResourceStore: function(b, d) {
        var c = this.getTaskStore();
        var a = this.resourceStore || c && c.getResourceStore();
        if (!a) {
            return null
        }
        return new(Ext.getClass(a))(Ext.apply({
            isCloned: true,
            model: a.model,
            proxy: {
                type: "memory",
                reader: {
                    type: "json"
                }
            }
        },
        d))
    },
    cloneStores: function(d) {
        var a = this.task,
        e = this.cloneResourceStore(a, d && d.resourceStore),
        f = this.cloneAssignmentStore(a, d && d.assignmentStore),
        c = this.cloneDependencyStore(a, d && d.dependencyStore);
        var b = this.cloneTaskStore(a, Ext.apply({
            assignmentStore: f,
            resourceStore: e,
            dependencyStore: c
        },
        d && d.taskStore));
        e.taskStore = b;
        return {
            resourceStore: e,
            assignmentStore: f,
            dependencyStore: c,
            taskStore: b
        }
    },
    cloneTask: function(a) {
        return a.copy(a.getInternalId(), false)
    },
    bindDependencyGrid: function() {
        var a = this.clonedStores.dependencyStore;
        var b = this.dependencyGrid;
        b.store.taskStore = this.clonedStores.taskStore;
        if (a) {
            this.mon(b, {
                loaddependencies: function(d, c) {
                    a.loadData(c.getRange().concat(Gnt.util.Data.cloneModelSet(d.oppositeData)))
                }
            });
            this.mon(b.store, {
                add: function(d, c) {
                    a.add(c)
                },
                remove: function(d, c) {
                    a.remove(c)
                }
            });
            this.dependencyGridBound = true
        }
    },
    loadTask: function(d) {
        if (!d) {
            return
        }
        var h = this;
        this.task = d;
        var c = this.taskForm;
        c.setSuppressTaskUpdate(true);
        c.getForm().reset();
        var j = this.clonedStores;
        var g = this.cloneTask(d);
        var e = [g];
        Ext.Array.each(d.predecessors,
        function(m) {
            var l = h.cloneTask(m.getSourceTask());
            l.taskStore = j.taskStore;
            e.push(l)
        });
        Ext.Array.each(d.successors,
        function(m) {
            var l = h.cloneTask(m.getTargetTask());
            l.taskStore = j.taskStore;
            e.push(l)
        });
        if (!j.dependencyStore) {
            j.dependencyStore = this.cloneDependencyStore(d)
        }
        if (!j.assignmentStore) {
            j.assignmentStore = this.cloneAssignmentStore(d)
        }
        if (!j.resourceStore) {
            j.resourceStore = this.cloneResourceStore(d)
        }
        if (!j.taskStore) {
            j.taskStore = this.cloneTaskStore(d, {
                assignmentStore: j.assignmentStore,
                resourceStore: j.resourceStore,
                dependencyStore: j.dependencyStore
            })
        }
        g.taskStore = j.taskStore;
        g.taskStore.on({
            update: function(n, l, m) {
                if (l === g && m == Ext.data.Model.EDIT) {
                    l.fireEvent("taskupdated", l)
                }
            }
        });
        var a = function(m, l) {
            m.setId(l.getId())
        };
        var k = this.dependencyGrid;
        if (k) {
            if (!this.dependencyGridBound) {
                this.bindDependencyGrid()
            }
            k.loadDependencies(d);
            if (this.allowParentTaskDependencies || d.isLeaf()) {
                k.tab.show()
            } else {
                k.tab.hide()
            }
        } else {
            if (j.dependencyStore) {
                j.dependencyStore.loadData(Gnt.util.Data.cloneModelSet(d.getAllDependencies(), a))
            }
        }
        j.taskStore.setRootNode({
            expanded: true,
            children: e
        });
        var f = this.assignmentGrid;
        if (f) {
            if (j.assignmentStore !== f.getStore()) {
                f.reconfigure(j.assignmentStore)
            }
            if (f.resourceDupStore !== j.resourceStore) {
                f.resourceDupStore = j.resourceStore
            }
            f.loadResources(true);
            f.loadTaskAssignments(d.getId() || d.getPhantomId());
            f.task = g
        } else {
            if (j.resourceStore) {
                j.resourceStore.loadData(Gnt.util.Data.cloneModelSet(this.resourceStore || this.getTaskStore().getResourceStore(), a))
            }
            if (j.assignmentStore) {
                j.assignmentStore.loadData(Gnt.util.Data.cloneModelSet(d.assignments, a))
            }
        }
        c.getForm().reset();
        c.loadRecord(d, g);
        if (this.advancedForm) {
            this.advancedForm.setSuppressTaskUpdate(true);
            var b = this.advancedForm.getForm();
            b.reset();
            this.advancedForm.loadRecord(d, c.taskBuffer);
            var i = b.findField("wbsCode");
            if (i) {
                i.setValue(d.getWBSCode())
            }
            this.advancedForm.setSuppressTaskUpdate(false)
        }
        c.setSuppressTaskUpdate(false);
        if (this.styleForm) {
            this.styleForm.loadRecord(d)
        }
        if (this.notesEditor) {
            this.notesEditor.setValue(d.getNote());
            this.notesEditor.setReadOnly(!d.isEditable(d.noteField))
        }
        this.fireEvent("loadtask", this, d)
    },
    getTabByComponent: function(b) {
        var a;
        this.items.each(function(c) {
            if (b === c || b.isDescendantOf(c)) {
                a = c;
                return false
            }
        },
        this);
        return a
    },
    validate: function() {
        var b, a = this.getActiveTab(),
        c = [],
        d;
        b = this.doValidate(function(e) {
            c.push(e)
        });
        if (!b && a && !Ext.Array.contains(c, a)) {
            d = c[0];
            this.setActiveTab(d)
        } else {
            if (!b && a) {
                d = a
            } else {
                if (!b) {
                    d = c[0]
                }
            }
        }
        return (this.fireEvent("validate", this, d) !== false) && b
    },
    doValidate: function(b) {
        var a = true;
        if (this.taskForm && !this.taskForm.isValid()) {
            a = false;
            b && b(this.getTabByComponent(this.taskForm))
        }
        if (this.dependencyGrid && !this.dependencyGrid.isValid()) {
            a = false;
            b && b(this.getTabByComponent(this.dependencyGrid))
        }
        if (this.assignmentGrid && !this.assignmentGrid.isValid()) {
            a = false;
            b && b(this.getTabByComponent(this.assignmentGrid))
        }
        if (this.advancedForm && !this.advancedForm.isValid()) {
            a = false;
            b && b(this.getTabByComponent(this.advancedForm))
        }
        return a
    },
    updateTask: function() {
        var b = this,
        a = false;
        if (b.fireEvent("beforeupdatetask", b,
        function() {
            b.doUpdateTask()
        }) !== false) {
            b.doUpdateTask();
            b.fireEvent("afterupdatetask", b);
            a = true
        }
        return a
    },
    doUpdateTask: function() {
        this.taskForm && this.taskForm.updateRecord();
        this.advancedForm && this.advancedForm.updateRecord();
        this.notesEditor && this.task.set(this.task.noteField, this.notesEditor.getValue());
        this.styleForm && this.styleForm.getForm().updateRecord();
        this.assignmentGrid && this.assignmentGrid.saveTaskAssignments();
        this.dependencyGrid && this.dependencyGrid.saveDependencies()
    },
    isDataValid: function(a) {
        return this.doValidate()
    },
    isDataChanged: function(b) {
        var a = false;
        if (this.taskForm && this.taskForm.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.taskForm))
        }
        if (this.dependencyGrid && this.dependencyGrid.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.dependencyGrid))
        }
        if (this.assignmentGrid && this.assignmentGrid.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.assignmentGrid))
        }
        if (this.advancedForm && this.advancedForm.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.advancedForm))
        }
        if (this.notesEditor && this.notesEditor.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.notesEditor))
        }
        return a
    },
    onDestroy: function() {
        if (this.clonedStores.taskStore) {
            this.clonedStores.taskStore.destroy()
        }
        this.callParent(arguments)
    }
});
Ext.define("Gnt.plugin.TaskEditor", {
    extend: "Ext.window.Window",
    requires: ["Ext.window.MessageBox", "Gnt.widget.taskeditor.TaskEditor"],
    alias: "plugin.gantt_taskeditor",
    ptype: "gantt_taskeditor",
    mixins: ["Ext.AbstractPlugin", "Gnt.mixin.Localizable"],
    lockableScope: "top",
    taskEditor: null,
    panelConfig: null,
    height: 340,
    width: 600,
    layout: "fit",
    constrain: true,
    triggerEvent: "taskdblclick",
    closeAction: "hide",
    modal: true,
    gantt: null,
    assignmentStore: null,
    resourceStore: null,
    taskStore: null,
    monitorDataUpdates: false,
    getState: function() {
        if (this.rendered) {
            return this.callParent(arguments)
        }
    },
    monitorDataUpdatesInterval: 500,
    constructor: function(a) {
        a = a || {};
        Ext.apply(this, a);
        this.title = this.L("title");
        if (!a.buttons) {
            this.buttons = ["->", {
                itemId: "teOkBtn",
                text: this.L("okText"),
                handler: function() {
                    this.completeEditing() || Ext.Msg.alert(this.L("alertCaption"), this.L("alertText"))
                },
                scope: this
            },
            {
                text: this.L("cancelText"),
                handler: this.close,
                scope: this
            }]
        }
        this.callParent(arguments);
        this.addCls("gnt-taskeditor-window")
    },
    init: function(d) {
        this.assignmentStore = this.assignmentStore || d.getAssignmentStore();
        this.resourceStore = this.resourceStore || d.getResourceStore();
        this.taskStore = this.taskStore || d.getTaskStore();
        var b = {
            width: null,
            height: null,
            border: false
        },
        e = ["l10n", "task", "taskStore", "assignmentStore", "resourceStore", "generalText", "resourcesText", "dependencyText", "addDependencyText", "dropDependencyText", "notesText", "advancedText", "wbsCodeText", "addAssignmentText", "dropAssignmentText", "showAssignmentGrid", "showDependencyGrid", "allowParentTaskDependencies", "showNotes", "showStyle", "showAdvancedForm", "taskFormClass", "advancedFormClass", "taskFormConfig", "dependencyGridConfig", "assignmentGridConfig", "advancedFormConfig", "styleFormConfig", "dependencyGridClass", "assignmentGridClass"];
        for (var c = 0,
        a = e.length; c < a; c++) {
            if (this[e[c]] !== undefined) {
                b[e[c]] = this[e[c]]
            }
        }
        b.showBaseline = d.enableBaseline;
        b.showRollup = d.showRollupTasks;
        b.allowParentTaskDependencies = d.allowParentTaskDependencies;
        Ext.apply(b, this.panelConfig);
        this.buildTaskEditor(b);
        this.add(this.taskEditor);
        this.relayEvents(this.taskEditor, ["validate", "beforeupdatetask", "afterupdatetask", "loadtask"]);
        this.mon(d, this.triggerEvent, this.onTriggerEvent, this);
        this.gantt = d;
        d.taskEditor = this
    },
    buildTaskEditor: function(a) {
        this.taskEditor = new Gnt.widget.taskeditor.TaskEditor(a)
    },
    onTriggerEvent: function(b, a) {
        this.showTask(a)
    },
    showTask: function(a) {
        if (this.taskEditor && a) {
            this.taskEditor.loadTask(a);
            this.show()
        }
    },
    validate: function() {
        if (this.taskEditor) {
            return this.taskEditor.validate()
        }
    },
    completeEditing: function() {
        if (this.taskEditor) {
            var a = this.taskEditor.getActiveTab();
            if (a.editingPlugin && a.editingPlugin.completeEdit) {
                a.editingPlugin.completeEdit()
            }
            if (!this.taskEditor.validate()) {
                return false
            }
            if (this.taskEditor.updateTask()) {
                this.hide();
                return true
            }
            return false
        }
    },
    updateTask: function() {
        if (this.taskEditor) {
            return this.taskEditor.updateTask()
        }
    },
    afterRender: function() {
        var a = this;
        a.callParent(arguments);
        a.startDataUpdatesMonitoring()
    },
    startDataUpdatesMonitoring: function() {
        var e = this,
        d = e.down("#teOkBtn"),
        c = true;
        function b() {
            if (c && d && e.taskEditor) {
                d.setDisabled(!e.taskEditor.isDataChanged() || !e.taskEditor.isDataValid());
                c = Ext.Function.defer(b, e.monitorDataUpdatesInterval)
            }
        }
        function a() {
            c !== true && clearTimeout(c);
            c = true
        }
        if (e.monitorDataUpdates && d) {
            e.on({
                show: b,
                hide: a,
                destroy: a
            })
        }
    }
});
Ext.define("Gnt.column.Dependency", {
    extend: "Ext.grid.column.Column",
    requires: ["Gnt.field.Dependency"],
    separator: ";",
    type: "predecessors",
    field: null,
    useSequenceNumber: false,
    constructor: function(a) {
        a = a || {};
        var b = a.editor;
        delete a.editor;
        Ext.apply(this, a);
        a.editor = b || Ext.create("Gnt.field.Dependency", {
            type: this.type,
            separator: this.separator,
            useSequenceNumber: this.useSequenceNumber
        });
        if (! (a.editor instanceof Gnt.widget.DependencyField)) {
            a.editor = Ext.ComponentManager.create(a.editor, "dependencyfield")
        }
        a.field = a.editor;
        this.scope = this;
        this.callParent([a])
    },
    afterRender: function() {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    getContainingPanel: function() {
        if (!this.panel) {
            this.panel = this.up("tablepanel")
        }
        return this.panel
    },
    setDirtyClass: function(c, b) {
        var a = this.getContainingPanel().getView();
        if (a.markDirty && this.field.isDirty(b)) {
            c.tdCls = a.dirtyCls
        }
    },
    isEditable: function(b) {
        var a = this.gantt || this.up("ganttpanel");
        return ! a || a.allowParentTaskDependencies || b.isLeaf()
    },
    renderer: function(b, c, a) {
        if (!a.isEditable(this.dataIndex) || !this.isEditable(a)) {
            c.tdCls = (c.tdCls || "") + " sch-column-readonly"
        } else {
            this.setDirtyClass(c, a)
        }
        return this.field.getDisplayValue(a)
    }
});
Ext.define("Gnt.column.Successor", {
    extend: "Gnt.column.Dependency",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.successorcolumn", "widget.ganttcolumn.successor"],
    type: "successors",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.Predecessor", {
    extend: "Gnt.column.Dependency",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.predecessorcolumn", "widget.ganttcolumn.predecessor"],
    type: "predecessors",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.Duration", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.durationcolumn", "widget.ganttcolumn.duration"],
    requires: ["Gnt.field.Duration"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 80,
    align: "left",
    decimalPrecision: 2,
    useAbbreviation: false,
    instantUpdate: true,
    field: null,
    fieldProperty: "durationField",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        var b = a.editor;
        delete a.editor;
        Ext.apply(this, a);
        a.editor = b || Ext.create("Gnt.field.Duration", {
            useAbbreviation: this.useAbbreviation,
            decimalPrecision: this.decimalPrecision,
            instantUpdate: this.instantUpdate
        });
        if (! (a.editor instanceof Gnt.field.Duration)) {
            Ext.applyIf(a.editor, {
                instantUpdate: this.instantUpdate
            });
            a.editor = Ext.ComponentManager.create(a.editor, "durationfield")
        }
        this.field = a.editor;
        this.scope = this;
        this.hasCustomRenderer = true;
        this.callParent([a])
    },
    afterRender: function() {
        var a = this.up("treepanel");
        if (!this.dataIndex) {
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    },
    renderer: function(b, d, a) {
        if (!Ext.isNumber(b)) {
            return ""
        }
        if (!a.isEditable(this.dataIndex)) {
            d.tdCls = (d.tdCls || "") + " sch-column-readonly"
        }
        var c = a.getDurationUnit();
        return this.field.valueToVisible(b, c)
    }
});
Ext.define("Gnt.column.Effort", {
    extend: "Gnt.column.Duration",
    alias: ["widget.effortcolumn", "widget.ganttcolumn.effort"],
    requires: ["Gnt.field.Effort"],
    width: 80,
    align: "left",
    decimalPrecision: 2,
    field: null,
    fieldProperty: "effortField",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        var b = a.editor;
        delete a.editor;
        Ext.apply(this, a);
        a.editor = b || Ext.create("Gnt.field.Effort", {
            useAbbreviation: this.useAbbreviation,
            decimalPrecision: this.decimalPrecision,
            getDurationMethod: null,
            instantUpdate: this.instantUpdate
        });
        if (! (a.editor instanceof Gnt.field.Effort)) {
            Ext.applyIf(a.editor, {
                useAbbreviation: this.useAbbreviation,
                decimalPrecision: this.decimalPrecision,
                getDurationMethod: null,
                instantUpdate: this.instantUpdate
            });
            a.editor = Ext.ComponentManager.create(a.editor, "effortfield")
        }
        this.field = a.editor;
        this.scope = this;
        this.hasCustomRenderer = true;
        this.callParent([a])
    },
    afterRender: function() {
        var a = this.up("treepanel");
        if (!this.dataIndex) {
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    },
    renderer: function(c, d, a) {
        if (!Ext.isNumber(c)) {
            return ""
        }
        if (!a.isEditable(this.dataIndex)) {
            d.tdCls = (d.tdCls || "") + " sch-column-readonly"
        }
        var b = a.getEffortUnit();
        return this.field.valueToVisible(c, b)
    }
});
Ext.define("Gnt.column.ConstraintType", {
    extend: "Ext.grid.column.Column",
    requires: ["Gnt.field.ConstraintType"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.constrainttypecolumn", "widget.ganttcolumn.constrainttype"],
    l10n: {
        text: "Constraint"
    },
    width: 100,
    align: "left",
    data: null,
    field: null,
    fieldProperty: "constraintTypeField",
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        var b = a.editor || new Gnt.field.ConstraintType({
            store: a.data,
            taskField: this.fieldProperty
        });
        delete a.editor;
        if (! (b instanceof Gnt.field.ConstraintType)) {
            b = Ext.ComponentManager.create(b, "constrainttypefield")
        }
        a.field = a.editor = b;
        this.scope = this;
        this.callParent([a])
    },
    renderer: function(b, c, a) {
        return this.field.valueToVisible(b, a)
    },
    afterRender: function() {
        if (!this.dataIndex) {
            var a = this.up("treepanel");
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.ConstraintDate", {
    extend: "Ext.grid.column.Date",
    alias: ["widget.constraintdatecolumn", "widget.ganttcolumn.constraintdate"],
    requires: ["Gnt.field.ConstraintDate"],
    mixins: ["Gnt.mixin.Localizable"],
    l10n: {
        text: "Constraint date"
    },
    width: 100,
    align: "left",
    fieldProperty: "constraintDateField",
    field: null,
    constructor: function(a) {
        a = a || {};
        this.text = a.text || this.L("text");
        var b = a.editor || new Gnt.field.ConstraintDate({
            format: a.format || this.format || Ext.Date.defaultFormat,
            taskField: a.fieldProperty || this.fieldProperty
        });
        delete a.editor;
        if (! (b instanceof Gnt.field.ConstraintDate)) {
            b = Ext.ComponentManager.create(b, "constraintdate")
        }
        a.field = a.editor = b;
        this.scope = this;
        this.callParent([a])
    },
    renderer: function(d, f, a) {
        var c = this,
        e = c.format || Ext.Date.defaultFormat,
        b;
        b = a.getConstraintClass();
        d = b && b.getDisplayableConstraintDateForFormat(d, e, a) || d;
        return Ext.Date.format(d, e)
    },
    afterRender: function() {
        if (!this.dataIndex) {
            var a = this.up("treepanel");
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    }
});
Ext.define("Gnt.widget.Calendar", {
    extend: "Ext.picker.Date",
    alias: "widget.ganttcalendar",
    requires: ["Gnt.data.Calendar", "Sch.util.Date"],
    mixins: ["Gnt.mixin.Localizable"],
    calendar: null,
    startDate: null,
    endDate: null,
    initComponent: function() {
        if (!this.calendar) {
            Ext.Error.raise('Required attribute "calendar" missing during initialization of `Gnt.widget.Calendar`')
        }
        if (!this.startDate) {
            Ext.Error.raise('Required attribute "startDate" missing during initialization of `Gnt.widget.Calendar`')
        }
        if (!this.endDate) {
            this.endDate = Sch.util.Date.add(this.startDate, Sch.util.Date.MONTH, 1)
        }
        this.setCalendar(this.calendar);
        this.minDate = this.value = this.startDate;
        this.callParent(arguments);
        this.injectDates()
    },
    injectDates: function() {
        var a = this;
        var b = a.disabledDates = [];
        Ext.each(a.calendar.getHolidaysRanges(a.startDate, a.endDate),
        function(c) {
            c.forEachDate(function(d) {
                b.push(Ext.Date.format(d, a.format))
            })
        });
        a.setDisabledDates(b)
    },
    setCalendar: function(b) {
        var a = {
            update: this.injectDates,
            remove: this.injectDates,
            add: this.injectDates,
            load: this.injectDates,
            clear: this.injectDates,
            scope: this
        };
        if (this.calendar) {
            this.mun(b, a)
        }
        this.calendar = b;
        if (b) {
            this.mon(b, a)
        }
    }
});
Ext.define("Gnt.widget.calendar.ResourceCalendarGrid", {
    extend: "Ext.grid.Panel",
    requires: ["Ext.data.Store", "Ext.grid.plugin.CellEditing", "Sch.util.Date", "Gnt.model.Calendar", "Gnt.data.Calendar"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.resourcecalendargrid",
    resourceStore: null,
    calendarStore: null,
    cellEditingConfig: null,
    initComponent: function() {
        var b = this;
        this.calendarStore = this.calendarStore || {
            xclass: "Ext.data.Store",
            model: "Gnt.model.Calendar"
        };
        if (! (this.calendarStore instanceof Ext.data.Store)) {
            this.calendarStore = Ext.create(this.calendarStore)
        }
        var a = Ext.create("Ext.grid.plugin.CellEditing", Ext.apply({
            clicksToEdit: 2
        },
        this.cellEditingConfig));
        this.mon(a, {
            edit: function(c, d) {
                this.onCalendarChange(d.record, d.value)
            },
            scope: this
        });
        Ext.apply(b, {
            store: b.resourceStore,
            columns: [{
                header: this.L("name"),
                dataIndex: "Name",
                flex: 1
            },
            {
                header: this.L("calendar"),
                flex: 1,
                renderer: function(d, f, c) {
                    var e = c.getCalendar();
                    var g = b.calendarStore.getById(e && e.calendarId);
                    return g && g.getName() || d
                },
                editor: {
                    xtype: "combobox",
                    store: b.calendarStore,
                    queryMode: "local",
                    displayField: "Name",
                    valueField: "Id",
                    editable: false,
                    allowBlank: false
                }
            }],
            border: true,
            height: 180,
            plugins: a
        });
        this.calendarStore.loadData(this.getCalendarData());
        this.callParent(arguments)
    },
    getCalendarData: function() {
        var a = [];
        Ext.Array.each(Gnt.data.Calendar.getAllCalendars(),
        function(b) {
            a.push({
                Id: b.calendarId,
                Name: b.name || b.calendarId
            })
        });
        return a
    },
    onCalendarChange: function(a, b) {
        a.setCalendarId(b)
    }
});
Ext.define("Gnt.widget.calendar.AvailabilityGrid", {
    extend: "Ext.grid.Panel",
    requires: ["Ext.Button", "Ext.data.Store", "Ext.grid.plugin.CellEditing", "Ext.window.MessageBox", "Gnt.data.Calendar", "Sch.util.Date"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendaravailabilitygrid",
    calendarDay: null,
    height: 160,
    addButton: null,
    removeButton: null,
    maxIntervalsNum: 5,
    initComponent: function() {
        if (!this.tbar) {
            this.tbar = this.buildToolbar()
        }
        Ext.applyIf(this, {
            store: new Ext.data.Store({
                fields: ["startTime", "endTime"],
                data: this.calendarDay.getAvailability()
            }),
            plugins: [new Ext.grid.plugin.CellEditing({
                clicksToEdit: 2
            })],
            columns: [{
                xtype: "datecolumn",
                header: this.L("startText"),
                format: "g:i a",
                dataIndex: "startTime",
                flex: 1,
                editor: {
                    xtype: "timefield",
                    allowBlank: false,
                    initDate: "31/12/1899"
                }
            },
            {
                xtype: "datecolumn",
                header: this.L("endText"),
                format: "g:i a",
                dataIndex: "endTime",
                flex: 1,
                editor: {
                    xtype: "timefield",
                    allowBlank: false,
                    initDate: "31/12/1899"
                }
            }],
            listeners: {
                selectionchange: this.onAvailabilityGridSelectionChange,
                scope: this
            }
        });
        this.callParent(arguments)
    },
    buildToolbar: function() {
        this.addButton = new Ext.Button({
            text: this.L("addText"),
            iconCls: "gnt-action-add",
            handler: this.addAvailability,
            scope: this
        });
        this.removeButton = new Ext.Button({
            text: this.L("removeText"),
            iconCls: "gnt-action-remove",
            handler: this.removeAvailability,
            scope: this,
            disabled: true
        });
        return [this.addButton, this.removeButton]
    },
    onAvailabilityGridSelectionChange: function(a) {
        this.removeButton.setDisabled(!a || a.getSelection().length === 0)
    },
    setAvailability: function(a) {
        this.store.loadData(a);
        this.addButton.setDisabled(this.store.getCount() >= this.maxIntervalsNum)
    },
    addAvailability: function() {
        var a = this.getStore(),
        b = a.count();
        if (b >= this.maxIntervalsNum) {
            return
        }
        a.add({
            startTime: new Date(0, 0, 0, 12, 0),
            endTime: new Date(0, 0, 0, 13, 0)
        });
        if (b + 1 >= this.maxIntervalsNum && this.addButton) {
            this.addButton.disable()
        }
    },
    removeAvailability: function() {
        var a = this.getStore(),
        c = a.getCount(),
        b = this.getSelectionModel().getSelection();
        if (b.length === 0) {
            return
        }
        a.remove(b[0]);
        if (c < this.maxIntervalsNum && this.addButton) {
            this.addButton.enable()
        }
    },
    isValid: function(b) {
        try {
            this.calendarDay.verifyAvailability(this.getIntervals())
        } catch(a) {
            if (!b) {
                Ext.MessageBox.show({
                    title: this.L("error"),
                    msg: a,
                    modal: true,
                    icon: Ext.MessageBox.ERROR,
                    buttons: Ext.MessageBox.OK
                })
            }
            return false
        }
        return true
    },
    extractTimeFromDate: function(a) {
        return new Date(0, 0, 0, a.getHours(), a.getMinutes(), a.getSeconds())
    },
    getIntervals: function() {
        var a = [];
        var b = this;
        this.getStore().each(function(d) {
            var c = b.extractTimeFromDate(d.get("endTime"));
            if (c - new Date(0, 0, 0, 0, 0, 0) === 0) {
                c = new Date(0, 0, 1, 0, 0)
            }
            a.push({
                startTime: b.extractTimeFromDate(d.get("startTime")),
                endTime: c
            })
        });
        return a
    }
});
Ext.define("Gnt.widget.calendar.DayEditor", {
    extend: "Gnt.widget.calendar.AvailabilityGrid",
    requires: ["Ext.grid.plugin.CellEditing", "Gnt.data.Calendar", "Sch.util.Date"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendardayeditor",
    height: 160,
    initComponent: function() {
        var a = this.calendarDay.getIsWorkingDay();
        this.dockedItems = this.dockedItems || [{
            xtype: "radiogroup",
            dock: "top",
            name: "dayType",
            padding: "0 5px",
            margin: 0,
            items: [{
                boxLabel: this.L("workingTimeText"),
                name: "IsWorkingDay",
                inputValue: true,
                checked: a
            },
            {
                boxLabel: this.L("nonworkingTimeText"),
                name: "IsWorkingDay",
                inputValue: false,
                checked: !a
            }],
            listeners: {
                change: this.onDayTypeChanged,
                scope: this
            }
        }];
        this.on("afterrender", this.myApplyState, this);
        this.callParent(arguments)
    },
    getDayTypeRadioGroup: function() {
        return this.down('radiogroup[name="dayType"]')
    },
    myApplyState: function() {
        if (!this.isWorkingDay()) {
            this.viewSetDisabled(true);
            this.addButton.disable()
        }
    },
    viewSetDisabled: function(a) {
        if (a) {
            this.getView().getEl().mask();
            this.headerCt.getEl().mask()
        } else {
            this.getView().getEl().unmask();
            this.headerCt.getEl().unmask()
        }
    },
    onDayTypeChanged: function(a) {
        var b = a.getValue();
        if (Ext.isArray(b.IsWorkingDay)) {
            return
        }
        this.viewSetDisabled(!b.IsWorkingDay);
        this.addButton.setDisabled(!b.IsWorkingDay || this.getStore().getCount() >= this.maxIntervalsNum)
    },
    isWorkingDay: function() {
        return this.getDayTypeRadioGroup().getValue().IsWorkingDay
    },
    isValid: function() {
        if (this.isWorkingDay()) {
            return this.callParent()
        }
        return true
    },
    getIntervals: function() {
        if (!this.isWorkingDay()) {
            return []
        }
        return this.callParent()
    }
});
Ext.define("Gnt.widget.calendar.WeekEditor", {
    extend: "Ext.form.Panel",
    requires: ["Ext.grid.Panel", "Gnt.data.Calendar", "Sch.util.Date", "Gnt.widget.calendar.AvailabilityGrid"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendarweekeditor",
    weekName: null,
    startDate: null,
    endDate: null,
    weekAvailability: null,
    calendarWeekAvailability: null,
    defaultWeekAvailability: null,
    backupWeekAvailability: null,
    layout: "anchor",
    defaults: {
        border: false,
        anchor: "100%"
    },
    calendarDayModel: null,
    currentDayIndex: null,
    _weekDaysGrid: null,
    _availabilityGrid: null,
    initComponent: function() {
        this.backupWeekAvailability = [];
        this.items = [{
            xtype: "radiogroup",
            padding: "0 5px",
            name: "dayType",
            items: [{
                boxLabel: this.L("defaultTimeText"),
                name: "IsWorkingDay",
                inputValue: 0
            },
            {
                boxLabel: this.L("workingTimeText"),
                name: "IsWorkingDay",
                inputValue: 1
            },
            {
                boxLabel: this.L("nonworkingTimeText"),
                name: "IsWorkingDay",
                inputValue: 2
            }],
            listeners: {
                change: this.onDayTypeChanged,
                scope: this
            }
        },
        {
            layout: "column",
            padding: "0 0 5px 0",
            defaults: {
                border: false
            },
            items: [{
                margin: "0 10px 0 5px",
                columnWidth: 0.5,
                items: this.getWeekDaysGrid()
            },
            {
                columnWidth: 0.5,
                margin: "0 5px 0 0",
                items: this.getAvailabilityGrid()
            }]
        }];
        this.callParent(arguments)
    },
    getWeekDaysGrid: function() {
        if (this._weekDaysGrid != null) {
            return this._weekDaysGrid
        }
        var a = Ext.Date.dayNames;
        return this._weekDaysGrid = new Ext.grid.Panel({
            hideHeaders: true,
            height: 160,
            columns: [{
                header: "",
                dataIndex: "name",
                flex: 1
            }],
            store: new Ext.data.Store({
                fields: ["id", "name"],
                idProperty: "id",
                data: [{
                    id: 1,
                    name: a[1]
                },
                {
                    id: 2,
                    name: a[2]
                },
                {
                    id: 3,
                    name: a[3]
                },
                {
                    id: 4,
                    name: a[4]
                },
                {
                    id: 5,
                    name: a[5]
                },
                {
                    id: 6,
                    name: a[6]
                },
                {
                    id: 0,
                    name: a[0]
                }]
            }),
            listeners: {
                viewready: this.onWeekDaysListViewReady,
                selectionchange: this.onWeekDaysListSelectionChange,
                beforeselect: this.onWeekDaysListBeforeSelect,
                scope: this
            }
        })
    },
    getAvailabilityGrid: function() {
        if (!this._availabilityGrid) {
            this._availabilityGrid = new Gnt.widget.calendar.AvailabilityGrid({
                calendarDay: new this.calendarDayModel()
            })
        }
        return this._availabilityGrid
    },
    getDayTypeRadioGroup: function() {
        if (!this.dayTypeRadioGroup) {
            this.dayTypeRadioGroup = this.down('radiogroup[name="dayType"]')
        }
        return this.dayTypeRadioGroup
    },
    getWeekAvailability: function() {
        return this.weekAvailability
    },
    onWeekDaysListViewReady: function() {
        var b = this.getWeekDaysGrid(),
        a = b.getStore().getAt(0);
        this.currentDayIndex = a.getId();
        this.readFromData();
        b.getSelectionModel().select(a, false, true)
    },
    onWeekDaysListBeforeSelect: function() {
        if (!this.saveToData()) {
            return false
        }
    },
    applyChanges: function(e) {
        if (!this.saveToData()) {
            return false
        }
        var b = this.weekAvailability;
        var d = false;
        for (var c = 0; c < 7; c++) {
            var a = b[c];
            if (a) {
                d = true
            }
            if (!a) {
                e[c] = null
            }
            if (a && !e[c]) {
                e[c] = a
            }
            if (a && e[c]) {
                e[c].setIsWorkingDay(a.getIsWorkingDay());
                e[c].setAvailability(a.getAvailability())
            }
        }
        if (!d) {
            Ext.MessageBox.show({
                title: this.L("error"),
                msg: this.L("noOverrideError"),
                modal: true,
                icon: Ext.MessageBox.ERROR,
                buttons: Ext.MessageBox.OK
            });
            return false
        }
        return true
    },
    onWeekDaysListSelectionChange: function(a, b) {
        this.currentDayIndex = b[0].getId();
        this.readFromData()
    },
    getCurrentTypeOfWeekDay: function(a) {
        return this.weekAvailability[a] ? (this.weekAvailability[a].getIsWorkingDay() ? 1 : 2) : 0
    },
    getCurrentWeekDay: function(a) {
        return this.weekAvailability[a] || this.calendarWeekAvailability[a] || this.defaultWeekAvailability[a]
    },
    saveToData: function() {
        var c = this.currentDayIndex;
        var d = this.getDayTypeRadioGroup().getValue().IsWorkingDay;
        var a = this.weekAvailability;
        if (d === 0) {
            a[c] = null;
            return true
        }
        var b = this.getAvailabilityGrid();
        if (d == 1) {
            if (!b.isValid()) {
                return false
            }
            if (!a[c]) {
                a[c] = this.copyDefaultWeekDay(c)
            }
            a[c].setIsWorkingDay(true);
            a[c].setAvailability(b.getIntervals());
            this.backupWeekAvailability[c] = null;
            return true
        }
        if (!a[c]) {
            a[c] = this.copyDefaultWeekDay(c)
        }
        a[c].setIsWorkingDay(false);
        a[c].setAvailability([]);
        return true
    },
    copyDefaultWeekDay: function(a) {
        var b = (this.calendarWeekAvailability[a] || this.defaultWeekAvailability[a]).copy();
        b.setType("WEEKDAYOVERRIDE");
        b.setOverrideStartDate(this.startDate);
        b.setOverrideEndDate(this.endDate);
        b.setName(this.weekName);
        return b
    },
    readFromData: function(b) {
        var a = this.getCurrentWeekDay(this.currentDayIndex);
        var d = this.getCurrentTypeOfWeekDay(this.currentDayIndex);
        var c = this.getAvailabilityGrid();
        c.setAvailability(b || a.getAvailability());
        var e = this.getDayTypeRadioGroup();
        e.suspendEvents();
        e.setValue({
            IsWorkingDay: [d]
        });
        e.resumeEvents();
        c.setDisabled(d != 1)
    },
    onDayTypeChanged: function(d, b, a) {
        var g = d.getValue();
        if (g.IsWorkingDay == null || Ext.isArray(g.IsWorkingDay)) {
            return
        }
        var e = this.weekAvailability;
        var f = this.backupWeekAvailability;
        var h = this.currentDayIndex;
        var c = this.getAvailabilityGrid();
        var i;
        if (a.IsWorkingDay == 1) {
            f[h] = c.getIntervals()
        }
        switch (g.IsWorkingDay) {
        case 0:
            e[h] = null;
            break;
        case 1:
            if (!e[h]) {
                e[h] = this.copyDefaultWeekDay(h)
            }
            i = f[h];
            e[h].setIsWorkingDay(true);
            break;
        case 2:
            if (!e[h]) {
                e[h] = this.copyDefaultWeekDay(h)
            }
            e[h].setAvailability([]);
            e[h].setIsWorkingDay(false);
            break;
        default:
            throw "Unrecognized day type"
        }
        this.readFromData(i)
    }
});
Ext.define("Gnt.widget.calendar.DatePicker", {
    extend: "Ext.picker.Date",
    alias: "widget.gntdatepicker",
    workingDayCls: "gnt-datepicker-workingday",
    nonWorkingDayCls: "gnt-datepicker-nonworkingday",
    overriddenDayCls: "gnt-datepicker-overriddenday",
    overriddenWeekDayCls: "gnt-datepicker-overriddenweekday",
    weekOverridesStore: null,
    dayOverridesCalendar: null,
    update: function() {
        this.callParent(arguments);
        this.refreshCssClasses()
    },
    refreshCssClasses: function() {
        var d = this,
        b = d.cells.elements;
        this.removeCustomCls();
        for (var c = 0; c < d.numDays; c++) {
            var a = b[c].firstChild.dateValue;
            b[c].className += " " + this.getDateCls(new Date(a))
        }
    },
    getDateCls: function(e) {
        var b = "";
        if (e.getMonth() !== this.getActive().getMonth()) {
            return
        }
        var c = this.dayOverridesCalendar;
        if (c.getOwnCalendarDay(e)) {
            b += " " + this.overriddenDayCls;
            if (!c.isWorkingDay(e)) {
                b += " " + this.nonWorkingDayCls
            }
        } else {
            var f = null;
            this.weekOverridesStore.each(function(g) {
                if (Ext.Date.between(e, g.get("startDate"), g.get("endDate"))) {
                    f = g;
                    return false
                }
            });
            if (f) {
                b += " " + this.overriddenWeekDayCls;
                var d = e.getDay(),
                a = f.get("weekAvailability");
                if (a && a[d] && !a[d].getIsWorkingDay()) {
                    b += " " + this.nonWorkingDayCls
                }
            } else {
                if (!c.isWorkingDay(e)) {
                    b += " " + this.nonWorkingDayCls
                }
            }
        }
        return b || this.workingDayCls
    },
    removeCustomCls: function() {
        this.cells.removeCls([this.overriddenDayCls, this.nonWorkingDayCls, this.workingDayCls, this.overriddenWeekDayCls])
    }
});
Ext.define("Gnt.widget.calendar.Calendar", {
    extend: "Ext.form.Panel",
    requires: ["Ext.XTemplate", "Ext.data.Store", "Ext.grid.Panel", "Ext.grid.plugin.CellEditing", "Gnt.data.Calendar", "Gnt.model.CalendarDay", "Gnt.model.Week", "Gnt.widget.calendar.DayEditor", "Gnt.widget.calendar.WeekEditor", "Gnt.widget.calendar.DatePicker"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendar",
    defaults: {
        padding: 10,
        border: false
    },
    workingDayCls: "gnt-datepicker-workingday",
    nonWorkingDayCls: "gnt-datepicker-nonworkingday",
    overriddenDayCls: "gnt-datepicker-overriddenday",
    overriddenWeekDayCls: "gnt-datepicker-overriddenweekday",
    calendar: null,
    calendarManager: null,
    dayGridConfig: null,
    weekGridConfig: null,
    datePickerConfig: null,
    dayGrid: null,
    weekGrid: null,
    datePicker: null,
    legendTpl: '<ul class="gnt-calendar-legend"><li class="gnt-calendar-legend-item"><div class="gnt-calendar-legend-itemstyle {workingDayCls}"></div><span class="gnt-calendar-legend-itemname">{workingDayText}</span><div style="clear: both"></div></li><li><div class="gnt-calendar-legend-itemstyle {nonWorkingDayCls}"></div><span class="gnt-calendar-legend-itemname">{weekendsText}</span><div style="clear: both"></div></li><li class="gnt-calendar-legend-override"><div class="gnt-calendar-legend-itemstyle {overriddenDayCls}">31</div><span class="gnt-calendar-legend-itemname">{overriddenDayText}</span><div style="clear: both"></div></li><li class="gnt-calendar-legend-override"><div class="gnt-calendar-legend-itemstyle {overriddenWeekDayCls}">31</div><span class="gnt-calendar-legend-itemname">{overriddenWeekText}</span><div style="clear: both"></div></li></ul>',
    dateInfoTpl: null,
    dayOverridesCalendar: null,
    weekOverridesStore: null,
    copiesIndexByOriginalId: null,
    currentDayOverrideEditor: null,
    getDayGrid: function() {
        if (!this.dayGrid) {
            var a = this.calendar.model.prototype;
            this.dayGrid = new Ext.grid.Panel(Ext.apply({
                title: this.L("dayOverridesText"),
                tbar: [{
                    text: this.L("addText"),
                    itemId: "btnAdd",
                    action: "add",
                    iconCls: "gnt-action-add",
                    handler: this.addDay,
                    scope: this
                },
                {
                    text: this.L("editText"),
                    itemId: "btnEdit",
                    action: "edit",
                    iconCls: "gnt-action-edit",
                    handler: this.editDay,
                    scope: this
                },
                {
                    text: this.L("removeText"),
                    itemId: "btnRemove",
                    action: "remove",
                    iconCls: "gnt-action-remove",
                    handler: this.removeDay,
                    scope: this
                }],
                store: new Gnt.data.Calendar(),
                plugins: [new Ext.grid.plugin.CellEditing({
                    clicksToEdit: 2
                })],
                columns: [{
                    header: this.L("dayOverrideNameHeaderText"),
                    dataIndex: a.nameField,
                    flex: 1,
                    editor: {
                        allowBlank: false
                    }
                },
                {
                    header: this.L("dateText"),
                    dataIndex: a.dateField,
                    width: 100,
                    xtype: "datecolumn",
                    editor: {
                        xtype: "datefield"
                    }
                }]
            },
            this.dayGridConfig || {}));
            this.dayOverridesCalendar = this.dayGrid.store
        }
        return this.dayGrid
    },
    updateGrids: function() {
        if (this.dayGrid && this.weekGrid) {
            this.dayGrid.reconfigure(Ext.create("Gnt.data.Calendar"));
            this.fillDaysStore();
            this.weekGrid.reconfigure(Ext.create("Gnt.data.Calendar"));
            this.fillWeeksStore()
        }
    },
    getWeekGrid: function() {
        if (!this.weekGrid) {
            this.weekGrid = new Ext.grid.Panel(Ext.apply({
                title: this.L("weekOverridesText"),
                border: true,
                plugins: [new Ext.grid.plugin.CellEditing({
                    clicksToEdit: 2
                })],
                store: new Ext.data.Store({
                    model: "Gnt.model.Week"
                }),
                tbar: [{
                    text: this.L("addText"),
                    itemId: "btnAdd",
                    action: "add",
                    iconCls: "gnt-action-add",
                    handler: this.addWeek,
                    scope: this
                },
                {
                    text: this.L("editText"),
                    itemId: "btnEdit",
                    action: "edit",
                    iconCls: "gnt-action-edit",
                    handler: this.editWeek,
                    scope: this
                },
                {
                    text: this.L("removeText"),
                    itemId: "btnRemove",
                    action: "remove",
                    iconCls: "gnt-action-remove",
                    handler: this.removeWeek,
                    scope: this
                }],
                columns: [{
                    header: this.L("overrideName"),
                    dataIndex: "name",
                    flex: 1,
                    editor: {
                        allowBlank: false
                    }
                },
                {
                    xtype: "datecolumn",
                    header: this.L("startDate"),
                    dataIndex: "startDate",
                    width: 100,
                    editor: {
                        xtype: "datefield"
                    }
                },
                {
                    xtype: "datecolumn",
                    header: this.L("endDate"),
                    dataIndex: "endDate",
                    width: 100,
                    editor: {
                        xtype: "datefield"
                    }
                }]
            },
            this.weekGridConfig || {}));
            this.weekOverridesStore = this.weekGrid.store
        }
        return this.weekGrid
    },
    getDatePicker: function() {
        if (!this.datePicker) {
            this.datePicker = new Gnt.widget.calendar.DatePicker(Ext.apply({
                dayOverridesCalendar: this.getDayGrid().store,
                weekOverridesStore: this.getWeekGrid().store
            },
            this.datePickerConfig))
        }
        return this.datePicker
    },
    onCalendarSet: function(a) {
        this.weekOverridesStore.commitChanges()
    },
    initComponent: function() {
        var d = this;
        d.on("calendarset", d.onCalendarSet);
        d.on("afterrender", d.onCalendarSet);
        d.copiesIndexByOriginalId = {};
        d.setupTemplates();
        var e = this.calendar;
        if (!e) {
            Ext.Error.raise('Required attribute "calendar" is missed during initialization of `Gnt.widget.Calendar`')
        }
        this.mon(this.calendar, {
            load: this.onCalendarChange,
            add: this.onCalendarChange,
            remove: this.onCalendarChange,
            update: this.onCalendarChange,
            scope: this
        });
        var b = this.getWeekGrid(),
        a = this.getDayGrid(),
        c = this.getDatePicker();
        a.on({
            selectionchange: this.onDayGridSelectionChange,
            validateedit: this.onDayGridValidateEdit,
            edit: this.onDayGridEdit,
            scope: this
        });
        a.store.on({
            update: this.refreshView,
            remove: this.refreshView,
            add: this.refreshView,
            scope: this
        });
        b.on({
            selectionchange: this.onWeekGridSelectionChange,
            validateedit: this.onWeekGridValidateEdit,
            edit: this.onWeekGridEdit,
            scope: this
        });
        b.store.on({
            update: this.refreshView,
            remove: this.refreshView,
            add: this.refreshView,
            scope: this
        });
        c.on({
            select: this.onDateSelect,
            scope: this
        });
        this.fillDaysStore();
        this.fillWeeksStore();
        this.dateInfoPanel = new Ext.Panel({
            cls: "gnt-calendar-dateinfo",
            columnWidth: 0.33,
            border: false,
            height: 200
        });
        this.items = [{
            xtype: "container",
            layout: "hbox",
            pack: "start",
            align: "stretch",
            items: [{
                xtype: "textfield",
                itemId: "calendarName",
                fieldLabel: this.L("calendarNameText"),
                margin: "0 10 0 0",
                value: e.name,
                flex: 1
            },
            this.cmbParentCalendar = Ext.create("Ext.form.field.ComboBox", {
                xtype: "combobox",
                name: "cmb_parentCalendar",
                fieldLabel: this.L("parentCalendarText"),
                store: new Ext.data.Store({
                    fields: ["Id", "Name"],
                    data: [{
                        Id: -1,
                        Name: this.L("noParentText")
                    }].concat(e.getParentableCalendars())
                }),
                queryMode: "local",
                displayField: "Name",
                valueField: "Id",
                editable: false,
                emptyText: this.L("selectParentText"),
                value: e.parent ? e.parent.calendarId: -1,
                flex: 1
            })]
        },
        {
            layout: "column",
            defaults: {
                border: false
            },
            items: [{
                margin: "0 15px 0 0",
                columnWidth: 0.3,
                html: this.legendTpl.apply({
                    workingDayText: this.L("workingDayText"),
                    weekendsText: this.L("weekendsText"),
                    overriddenDayText: this.L("overriddenDayText"),
                    overriddenWeekText: this.L("overriddenWeekText"),
                    workingDayCls: this.workingDayCls,
                    nonWorkingDayCls: this.nonWorkingDayCls,
                    overriddenDayCls: this.overriddenDayCls,
                    overriddenWeekDayCls: this.overriddenWeekDayCls
                })
            },
            {
                columnWidth: 0.37,
                margin: "0 5px 0 0",
                items: [c]
            },
            this.dateInfoPanel]
        },
        {
            xtype: "tabpanel",
            height: 220,
            items: [a, b]
        }];
        this.callParent(arguments)
    },
    setCalendar: function(a) {
        if (this.calendar) {
            this.mun(this.calendar, {
                load: this.onCalendarChange,
                add: this.onCalendarChange,
                remove: this.onCalendarChange,
                update: this.onCalendarChange,
                scope: this
            })
        }
        this.calendar = a;
        this.mon(this.calendar, {
            load: this.onCalendarChange,
            add: this.onCalendarChange,
            remove: this.onCalendarChange,
            update: this.onCalendarChange,
            scope: this
        });
        this.updateComboBox();
        this.fillDaysStore();
        this.fillWeeksStore();
        this.refreshView();
        this.fireEvent("calendarset", a)
    },
    updateComboBox: function() {
        var d = this,
        b = [];
        if (this.calendarManager) {
            var a = this.calendarManager.getRootNode();
            a.cascadeBy(function(e) {
                if (e != a && e.calendar.calendarId != d.calendar.calendarId) {
                    b.push({
                        Id: e.calendar.calendarId,
                        Name: e.getName() || e.calendar.calendarId
                    })
                }
            })
        } else {
            Ext.each(Gnt.data.Calendar.getAllCalendars(),
            function(e) {
                if (e.calendarId != d.calendar.calendarId) {
                    b.push({
                        Id: e.calendarId,
                        Name: e.name || e.calendarId
                    })
                }
            })
        }
        var c = Ext.create("Ext.data.Store", {
            fields: ["Id", "Name"],
            data: [{
                Id: -1,
                Name: this.L("noParentText")
            }].concat(b)
        });
        this.cmbParentCalendar.bindStore(c);
        this.cmbParentCalendar.setValue(this.calendar.parent == null ? -1 : this.calendar.parent.calendarId);
        Ext.isIE10p && this.cmbParentCalendar.doQueryTask.cancel()
    },
    onCalendarChange: function() {
        this.fillDaysStore();
        this.fillWeeksStore();
        this.refreshView()
    },
    setupTemplates: function() {
        var a = this.L("tplTexts");
        this.dateInfoTpl = this.dateInfoTpl || Ext.String.format('<div class="gnt-calendar-overridedate"><tpl if="isWorkingDay">' + a.tplWorkingHours + " {date}:<tpl else>{date} " + a.tplIsNonWorking + '</tpl></div><ul class="gnt-calendar-availabilities"><tpl for="availability"><li>{.}</li></tpl></ul><span class="gnt-calendar-overridesource">' + a.tplBasedOn + ': <tpl if="override">' + a.tplOverride + ' "{name}" ' + a.tplInCalendar + ' "{calendarName}"<tpl else>' + a.tplDayInCalendar + ' "{calendarName}"</tpl></span>');
        if (! (this.dateInfoTpl instanceof Ext.Template)) {
            this.dateInfoTpl = new Ext.XTemplate(this.dateInfoTpl)
        }
        if (! (this.legendTpl instanceof Ext.Template)) {
            this.legendTpl = new Ext.XTemplate(this.legendTpl)
        }
    },
    afterRender: function() {
        this.callParent(arguments);
        this.onDateSelect(this.getDatePicker(), new Date())
    },
    fillDaysStore: function() {
        var a = Gnt.util.Data.cloneModelSet(this.calendar,
        function(b) {
            return (b.getType() == "DAY" && b.getDate())
        });
        this.dayOverridesCalendar.loadData(a)
    },
    copyCalendarDay: function(a) {
        var b = a.copy(null);
        b.__COPYOF__ = a.getId();
        this.copiesIndexByOriginalId[a.getId()] = b.getId();
        return b
    },
    fillWeeksStore: function() {
        var a = this;
        var b = [];
        this.calendar.forEachNonStandardWeek(function(c) {
            var d = Ext.apply({},
            c);
            d.weekAvailability = Ext.Array.map(d.weekAvailability,
            function(e) {
                return e && a.copyCalendarDay(e) || null
            });
            d.mainDay = a.copyCalendarDay(d.mainDay);
            b.push(d)
        });
        this.weekOverridesStore.loadData(b)
    },
    addDay: function() {
        var a = this.getDatePicker().getValue();
        if (this.dayOverridesCalendar.getOwnCalendarDay(a)) {
            this.alert({
                msg: this.L("overrideErrorText")
            });
            return
        }
        var b = new this.calendar.model({
            Name: this.L("newDayName"),
            Type: "DAY",
            Date: a,
            IsWorkingDay: false
        });
        this.getDayGrid().getStore().insert(0, b);
        this.getDayGrid().getSelectionModel().select([b], false, false)
    },
    editDay: function() {
        var e = this,
        c = this.getDayGrid().getSelectionModel().getSelection();
        if (c.length === 0) {
            return
        }
        var a = c[0];
        var b = this.currentDayOverrideEditor = new Gnt.widget.calendar.DayEditor({
            addText: this.L("addText"),
            removeText: this.L("removeText"),
            workingTimeText: this.L("workingTimeText"),
            nonworkingTimeText: this.L("nonworkingTimeText"),
            calendarDay: a
        });
        var d = Ext.create("Ext.window.Window", {
            title: this.L("dayOverridesText"),
            modal: true,
            width: 280,
            height: 260,
            layout: "fit",
            items: b,
            buttons: [{
                text: this.L("okText"),
                handler: function() {
                    if (b.isValid()) {
                        var f = b.calendarDay;
                        f.setIsWorkingDay(b.isWorkingDay());
                        f.setAvailability(b.getIntervals());
                        e.applyCalendarDay(f, a);
                        e.refreshView();
                        d.close()
                    }
                }
            },
            {
                text: this.L("cancelText"),
                handler: function() {
                    d.close()
                }
            }]
        });
        d.show()
    },
    removeDay: function() {
        var a = this.getDayGrid(),
        b = a.getSelectionModel().getSelection();
        if (!b.length) {
            return
        }
        a.getStore().remove(b[0]);
        this.refreshView()
    },
    refreshView: function() {
        var f = this.getDatePicker().getValue(),
        b = this.getCalendarDay(f),
        e = this.getWeekGrid(),
        a = this.getDayGrid(),
        d = this.dayOverridesCalendar.getOwnCalendarDay(f),
        h;
        var c;
        if (d) {
            a.getSelectionModel().select([d], false, true);
            c = d.getName()
        } else {
            h = this.getWeekOverrideByDate(f);
            if (h) {
                e.getSelectionModel().select([h], false, true);
                c = h.get("name")
            }
        }
        var g = {
            name: c || b.getName(),
            date: Ext.Date.format(f, "M j, Y"),
            calendarName: this.calendar.name || this.calendar.calendarId,
            availability: b.getAvailability(true),
            override: Boolean(d || h),
            isWorkingDay: b.getIsWorkingDay()
        };
        this.dateInfoPanel.update(this.dateInfoTpl.apply(g));
        this.down("#calendarName").setValue(this.calendar.name);
        this.datePicker.refreshCssClasses()
    },
    onDayGridSelectionChange: function(b) {
        if (b.getSelection().length === 0) {
            return
        }
        var a = b.getSelection()[0];
        this.getDatePicker().setValue(a.getDate());
        this.refreshView()
    },
    onDayGridEdit: function(b, a) {
        if (a.field === "Date") {
            a.grid.getStore().clearCache();
            this.getDatePicker().setValue(a.value)
        }
        this.refreshView()
    },
    onDayGridValidateEdit: function(b, a) {
        var c = this.getDayGrid().store;
        if (a.field === c.model.prototype.dateField && c.getOwnCalendarDay(a.value) && a.value !== a.originalValue) {
            this.alert({
                msg: this.L("overrideErrorText")
            });
            return false
        }
    },
    onDateSelect: function(b, a) {
        this.refreshView()
    },
    getCalendarDay: function(b) {
        var a = this.dayOverridesCalendar.getOwnCalendarDay(b);
        if (a) {
            return a
        }
        a = this.getWeekOverrideDay(b);
        if (a) {
            return a
        }
        return this.calendar.weekAvailability[b.getDay()] || this.calendar.defaultWeekAvailability[b.getDay()]
    },
    getWeekOverrideDay: function(d) {
        var e = new Date(d),
        b = this.getWeekOverrideByDate(d),
        c = e.getDay();
        if (b == null) {
            return null
        }
        var a = b.get("weekAvailability");
        if (!a) {
            return null
        }
        return a[c]
    },
    getWeekOverrideByDate: function(a) {
        var b = null;
        this.weekOverridesStore.each(function(c) {
            if (Ext.Date.between(a, c.get("startDate"), c.get("endDate"))) {
                b = c;
                return false
            }
        });
        return b
    },
    intersectsWithCurrentWeeks: function(b, d, c) {
        var a = false;
        this.weekOverridesStore.each(function(f) {
            if (f == c) {
                return
            }
            var e = f.get("startDate");
            var g = f.get("endDate");
            if (e <= b && b < g || e < d && d <= g) {
                a = true;
                return false
            }
        });
        return a
    },
    addWeek: function() {
        var c = this.weekOverridesStore;
        var a = this.getDatePicker().getValue();
        var f;
        for (var e = 7; e > 0; e--) {
            f = Sch.util.Date.add(a, Sch.util.Date.DAY, e);
            if (!this.intersectsWithCurrentWeeks(a, f)) {
                break
            }
        }
        if (!e) {
            this.alert({
                msg: Ext.String.format(this.L("overrideDateError"), Ext.Date.format(a, "Y/m/d"))
            });
            return
        }
        var d = new this.calendar.model();
        d.setType("WEEKDAYOVERRIDE");
        d.setName(this.L("newDayName"));
        d.setOverrideStartDate(a);
        d.setOverrideEndDate(f);
        d.setWeekday( - 1);
        var b = c.insert(0, {
            name: this.L("newDayName"),
            startDate: a,
            endDate: f,
            weekAvailability: [],
            mainDay: d
        })[0];
        this.getWeekGrid().getSelectionModel().select([b], false, false)
    },
    editWeek: function() {
        var c = this.getWeekGrid().getSelectionModel().getSelection(),
        e = this;
        if (c.length === 0) {
            return
        }
        var b = c[0];
        var a = new Gnt.widget.calendar.WeekEditor({
            startDate: b.get("startDate"),
            endDate: b.get("endDate"),
            weekName: b.get("name"),
            calendarDayModel: this.calendar.model,
            weekAvailability: b.get("weekAvailability"),
            calendarWeekAvailability: this.calendar.weekAvailability,
            defaultWeekAvailability: this.calendar.defaultWeekAvailability
        });
        var d = Ext.create("Ext.window.Window", {
            title: this.L("weekOverridesText"),
            modal: true,
            width: 370,
            defaults: {
                border: false
            },
            layout: "fit",
            items: a,
            buttons: [{
                action: "ok",
                text: this.L("okText"),
                handler: function() {
                    if (a.applyChanges(b.get("weekAvailability"))) {
                        e.refreshView();
                        d.close()
                    }
                }
            },
            {
                text: this.L("cancelText"),
                handler: function() {
                    d.close()
                }
            }]
        });
        d.show()
    },
    removeWeek: function() {
        var a = this.getWeekGrid().getSelectionModel().getSelection(),
        b = this;
        if (a.length === 0) {
            return
        }
        this.weekOverridesStore.remove(a[0]);
        this.refreshView()
    },
    onWeekGridSelectionChange: function(a) {
        var b = a.getSelection();
        if (b.length === 0) {
            return
        }
        this.getDatePicker().setValue(b[0].get("startDate"))
    },
    onWeekGridEdit: function(d, b) {
        var c = b.record,
        a = c.get("startDate"),
        e = c.get("endDate");
        if (b.field == "startDate" || b.field == "endDate") {
            Ext.Array.each(c.get("weekAvailability").concat(c.get("mainDay")),
            function(f) {
                if (f) {
                    f.setOverrideStartDate(a);
                    f.setOverrideEndDate(e)
                }
            });
            this.getDatePicker().setValue(a)
        }
        this.refreshView()
    },
    alert: function(a) {
        a = a || {};
        Ext.MessageBox.show(Ext.applyIf(a, {
            title: this.L("error"),
            icon: Ext.MessageBox.WARNING,
            buttons: Ext.MessageBox.OK
        }))
    },
    onWeekGridValidateEdit: function(d, b) {
        var c = b.record,
        a = b.field == "startDate" ? b.value: c.get("startDate"),
        e = b.field == "endDate" ? b.value: c.get("endDate");
        if (a > e) {
            this.alert({
                msg: this.L("startAfterEndError")
            });
            return false
        }
        if (this.intersectsWithCurrentWeeks(a, e, c)) {
            this.alert({
                msg: this.L("weeksIntersectError")
            });
            return false
        }
    },
    applyCalendarDay: function(d, c) {
        c.beginEdit();
        c.setName(d.getName());
        c.setIsWorkingDay(d.getIsWorkingDay());
        c.setDate(d.getDate());
        c.setOverrideStartDate(d.getOverrideStartDate());
        c.setOverrideEndDate(d.getOverrideEndDate());
        var b = d.getAvailability(true);
        var a = c.getAvailability(true);
        if (b + "" != a + "") {
            c.setAvailability(d.getAvailability())
        }
        c.endEdit()
    },
    applySingleDay: function(b, a) {
        if (b.__COPYOF__) {
            this.applyCalendarDay(b, this.calendar.getByInternalId(b.__COPYOF__))
        } else {
            if (b.joined) {
                b.unjoin(b.joined[0])
            }
            a.push(b)
        }
    },
    applyChanges: function() {
        var g = this;
        var h = this.calendar;
        var e = this.down('combobox[name="cmb_parentCalendar"]').getValue(),
        a = this.down("#calendarName").getValue();
        if (this.calendarManager) {
            var f = this.calendarManager.getNodeById(h.calendarId);
            if (f) {
                f.setName(a)
            }
        }
        h.suspendEvents(true);
        h.suspendCacheUpdate++;
        h.name = a;
        h.setParent(e ? Gnt.data.Calendar.getCalendar(e) : null);
        if (h.proxy.extraParams) {
            h.proxy.extraParams.calendarId = h.calendarId
        }
        Gnt.util.Data.applyCloneChanges(this.dayOverridesCalendar, h);
        var c = [];
        var b = [];
        var d = {};
        this.weekOverridesStore.each(function(i) {
            Ext.Array.each(i.get("weekAvailability").concat(i.get("mainDay")),
            function(j) {
                if (j) {
                    if (j.__COPYOF__) {
                        d[j.__COPYOF__] = true
                    }
                    g.applySingleDay(j, c)
                }
            })
        });
        h.forEachNonStandardWeek(function(i) {
            Ext.Array.each(i.weekAvailability.concat(i.mainDay),
            function(j) {
                if (j && !d[j.getId()]) {
                    b.push(j)
                }
            })
        });
        h.add(c);
        h.remove(b);
        h.suspendCacheUpdate--;
        h.clearCache();
        h.resumeEvents();
        this.fireEvent("calendarset", h)
    },
    checkChanges: function() {
        var a = this.dayOverridesCalendar.getModifiedRecords().length > 0 || this.dayOverridesCalendar.getRemovedRecords().length > 0,
        d = this.weekOverridesStore.getModifiedRecords().length > 0 || this.weekOverridesStore.getRemovedRecords().length > 0,
        c = this.down("#calendarName").getValue() != this.calendar.name,
        e = this.calendar.parent == null ? -1 : this.calendar.parent.calendarId,
        b = this.cmbParentCalendar.getValue() != e;
        return a || d || c || b
    }
});
Ext.define("Gnt.widget.calendar.CalendarWindow", {
    extend: "Ext.window.Window",
    requires: ["Gnt.widget.calendar.Calendar"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendarwindow",
    calendarConfig: null,
    calendar: null,
    calendarWidget: null,
    initComponent: function() {
        Ext.apply(this, {
            width: 600,
            layout: "fit",
            items: this.calendarWidget = new Gnt.widget.calendar.Calendar(Ext.apply({
                calendar: this.calendar
            },
            this.calendarConfig)),
            buttons: [{
                text: this.L("ok"),
                handler: function() {
                    this.applyChanges();
                    this.close()
                },
                scope: this
            },
            {
                text: this.L("cancel"),
                handler: this.close,
                scope: this
            }]
        });
        this.callParent(arguments)
    },
    applyChanges: function() {
        this.calendarWidget.applyChanges()
    }
});
Ext.define("Gnt.widget.calendar.CalendarManager", {
    extend: "Ext.panel.Panel",
    requires: ["Gnt.widget.calendar.Calendar", "Gnt.data.calendar.BusinessTime", "Ext.menu.Menu"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendarmanager",
    calendarConfig: null,
    calendarManager: null,
    calendarPanel: null,
    emptyCalendar: null,
    initComponent: function() {
        var a = this;
        Ext.apply(this, {
            layout: "border",
            width: 800,
            height: 550,
            items: [this.treePanel = new Ext.tree.Panel({
                split: true,
                region: "west",
                width: 200,
                store: this.calendarManager,
                displayField: "Name",
                rootVisible: false,
                tbar: [{
                    itemId: "btnAdd",
                    text: this.L("addText"),
                    action: "add",
                    iconCls: "gnt-action-add",
                    handler: this.onAddCalendar,
                    scope: this
                },
                {
                    itemId: "btnRemove",
                    text: this.L("removeText"),
                    action: "remove",
                    iconCls: "gnt-action-remove",
                    handler: this.onRemoveCalendar,
                    scope: this
                }],
                viewConfig: {
                    plugins: {
                        ptype: "treeviewdragdrop"
                    },
                    getRowClass: function(b, e, d, c) {
                        if (a.calendarManager.getProjectCalendar() == b.calendar) {
                            return "gnt-project-calendar-row"
                        }
                    },
                    listeners: {
                        drop: this.onDrop,
                        scope: this
                    }
                },
                listeners: {
                    containercontextmenu: this.onContainerContextMenu,
                    itemcontextmenu: this.onItemContextMenu,
                    selectionchange: this.onSelectionChange,
                    scope: this
                }
            }), this.calendarPanel = new Gnt.widget.calendar.Calendar(Ext.apply({
                region: "center",
                calendar: this.emptyCalendar = new Gnt.data.calendar.BusinessTime({
                    name: "initial"
                }),
                split: true,
                calendarManager: this.calendarManager
            },
            this.calendarConfig))]
        });
        this.callParent(arguments);
        this.itemContextMenu = new Ext.menu.Menu({
            margin: "0 0 10 0",
            items: [{
                text: this.L("add_child"),
                handler: this.addCalendar,
                scope: this
            },
            {
                text: this.L("add_sibling"),
                handler: this.addSiblingCalendar,
                scope: this
            },
            {
                text: this.L("remove"),
                handler: this.removeCalendar,
                scope: this
            }]
        });
        this.containerContextMenu = new Ext.menu.Menu({
            margin: "0 0 10 0",
            items: [{
                text: this.L("add_node"),
                handler: this.addNode,
                scope: this
            }]
        });
        this.counter = 1
    },
    onContainerContextMenu: function(a, b) {
        b.stopEvent();
        this.containerContextMenu.showAt(b.getXY())
    },
    onItemContextMenu: function(b, a, d, c, f) {
        f.stopEvent();
        this.itemContextMenu.showAt(f.getXY())
    },
    checkChanges: function() {
        if (this.calendarPanel.calendar != this.emptyCalendar && this.calendarPanel.checkChanges()) {
            return true
        }
        return false
    },
    onSelectionChange: function(e, f, d) {
        var g = this.treePanel;
        var c = this.calendarManager;
        var b = this.calendarPanel;
        if (f.length > 0) {
            var a = f[0];
            if (b.calendar != this.emptyCalendar && b.checkChanges()) {
                Ext.Msg.show({
                    title: this.L("confirm_action"),
                    msg: this.L("confirm_message"),
                    buttons: Ext.Msg.YESNOCANCEL,
                    icon: Ext.Msg.QUESTION,
                    fn: function(h) {
                        if (h == "yes") {
                            var i = c.getNodeById(b.calendar.calendarId);
                            b.applyChanges(i);
                            b.setCalendar(a.getCalendar())
                        } else {
                            if (h == "no") {
                                b.setCalendar(a.getCalendar())
                            } else {
                                e.suspendEvents();
                                e.select(c.getNodeById(b.calendar.calendarId));
                                e.resumeEvents()
                            }
                        }
                    }
                })
            } else {
                b.setCalendar(a.getCalendar())
            }
        }
    },
    onDrop: function(b, d, c, a) {
        Ext.each(d.records,
        function(e) {
            e.calendar.setParent(c.calendar)
        });
        this.calendarPanel.cmbParentCalendar.setValue(c.calendar.calendarId)
    },
    onDestroy: function() {
        this.containerContextMenu.destroy();
        this.itemContextMenu.destroy();
        this.callParent(arguments)
    },
    applyChanges: function(f) {
        var c = this.calendarManager;
        var b = this.calendarPanel;
        var g = b.cmbParentCalendar.getValue();
        var e = g == -1 ? c.getRootNode() : c.getNodeById(g);
        var d = this.treePanel.getSelectionModel().getSelection();
        var a = d.length ? d[0] : null;
        f = f || a;
        if (f && e != f.parentNode) {
            e.data.leaf = false;
            e.data.expanded = true;
            e.appendChild(f)
        }
        b.applyChanges();
        Ext.each(c.getModifiedRecords(),
        function(h) {})
    },
    onAddCalendar: function() {
        this.addCalendar()
    },
    addCalendar: function(c) {
        var d = Ext.ClassManager.get(this.calendarManager.calendarClass).prototype;
        var a = {
            Name: this.L("calendarName") + this.counter++,
            DaysPerMonth: d.daysPerMonth,
            DaysPerWeek: d.daysPerWeek,
            HoursPerDay: d.hoursPerDay,
            WeekendsAreWorkdays: d.weekendsAreWorkdays,
            WeekendFirstDay: d.weekendFirstDay,
            WeekendSecondDay: d.weekendSecondDay,
            DefaultAvailability: d.defaultAvailability,
            expanded: true,
            leaf: true
        };
        if (! (c && c instanceof Gnt.model.Calendar)) {
            var b = this.treePanel.getSelectionModel().getSelection();
            if (b.length) {
                c = b[0]
            }
        }
        c = c || this.treePanel.getRootNode();
        c.data.leaf = false;
        c.data.expanded = true;
        c.appendChild(a)
    },
    addSiblingCalendar: function() {
        var a = this.treePanel.getSelectionModel().getSelection();
        if (a.length > 0) {
            this.addCalendar(a[0].parentNode)
        }
    },
    addNode: function() {
        this.addCalendar(this.treePanel.getRootNode())
    },
    onRemoveCalendar: function() {
        this.removeCalendar()
    },
    removeCalendar: function() {
        var c = this.treePanel.getSelectionModel().getSelection();
        var a = this.treePanel.getRootNode();
        if (c.length > 0) {
            var d = c[0];
            var b = d.nextSibling || d.previousSibling || (d.parentNode == a ? a.firstChild: d.parentNode);
            if (b) {
                this.treePanel.getSelectionModel().select(b)
            } else {
                this.calendarPanel.setCalendar(new Gnt.data.calendar.BusinessCalendar())
            }
            d.remove()
        }
    }
});
Ext.define("Gnt.widget.calendar.CalendarManagerWindow", {
    extend: "Ext.window.Window",
    requires: ["Gnt.widget.calendar.CalendarManager"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendarmanagerwindow",
    width: 800,
    height: 600,
    layout: "fit",
    border: false,
    calendarConfig: null,
    calendarManager: null,
    calendarWidget: null,
    initComponent: function() {
        Ext.apply(this, {
            items: [this.calendarWidget = new Gnt.widget.calendar.CalendarManager({
                calendarManager: this.calendarManager,
                calendarConfig: this.calendarConfig
            })],
            buttons: [{
                text: this.L("ok"),
                handler: function() {
                    this.calendarWidget.applyChanges()
                },
                scope: this
            },
            {
                text: this.L("cancel"),
                handler: function() {
                    this.close()
                },
                scope: this
            }],
            listeners: {
                beforeclose: this.onBeforeClose
            }
        });
        this.callParent(arguments)
    },
    applyChanges: function() {
        this.calendarWidget.applyChanges()
    },
    onBeforeClose: function() {
        var e = this;
        var b = this.calendarManager;
        var d = this.calendarWidget;
        var a = d.calendarPanel;
        var c = d.treePanel;
        if (this.calendarWidget.checkChanges()) {
            Ext.Msg.show({
                title: d.L("confirm_action"),
                msg: d.L("confirm_message"),
                buttons: Ext.Msg.YESNOCANCEL,
                icon: Ext.Msg.QUESTION,
                fn: function(f) {
                    if (f == "yes") {
                        var g = b.getNodeById(a.calendar.calendarId);
                        d.applyChanges(g);
                        e.close()
                    } else {
                        if (f == "no") {
                            e.suspendEvents();
                            e.close()
                        }
                    }
                }
            });
            return false
        }
    }
});
Ext.define("Gnt.patches.IETreeStore", {
    extend: "Sch.util.Patch",
    requires: ["Gnt.data.TaskStore"],
    target: "Gnt.data.TaskStore",
    ieOnly: true,
    maxVersion: "5.1.0",
    overrides: {
        onNodeAdded: function(c, e) {
            var d = this,
            b = d.getProxy(),
            a = b.getReader(),
            f = e.raw || e[e.persistenceProperty],
            g;
            Ext.Array.remove(d.removed, e);
            e.join(d);
            if (!e.isLeaf()) {
                g = a.getRoot(f);
                if (g) {
                    d.fillNode(e, a.extractData(g));
                    if (f[a.root]) {
                        delete f[a.root]
                    }
                }
            }
            if (d.autoSync && !d.autoSyncSuspended && (e.phantom || e.dirty)) {
                d.sync()
            }
        }
    }
});
Ext.define("Gnt.patches.CellEditor", {
    extend: "Sch.util.Patch",
    requires: ["Ext.grid.CellEditor"],
    target: "Ext.grid.CellEditor",
    minVersion: "5.1.0",
    overrides: {
        onHide: function() {
            this.restoreCell();
            this.superclass.onHide.apply(this, arguments)
        }
    }
});
Ext.define("Gnt.panel.Gantt", {
    extend: "Sch.panel.TimelineTreePanel",
    alias: ["widget.ganttpanel"],
    alternateClassName: ["Sch.gantt.GanttPanel"],
    requires: ["Ext.layout.container.Border", "Gnt.patches.CellEditor", "Gnt.model.Dependency", "Gnt.data.ResourceStore", "Gnt.data.AssignmentStore", "Gnt.feature.WorkingTime", "Gnt.data.Calendar", "Gnt.data.TaskStore", "Gnt.data.DependencyStore", "Gnt.view.Gantt", "Gnt.plugin.ConstraintResolutionGui"],
    uses: ["Sch.plugin.CurrentTimeLine"],
    viewType: "ganttview",
    layout: "border",
    rowLines: true,
    syncRowHeight: false,
    useSpacer: false,
    rowHeight: 24,
    topLabelField: null,
    leftLabelField: null,
    bottomLabelField: null,
    rightLabelField: null,
    highlightWeekends: true,
    weekendsAreWorkdays: false,
    skipWeekendsDuringDragDrop: true,
    enableTaskDragDrop: true,
    enableDependencyDragDrop: true,
    enableProgressBarResize: false,
    toggleParentTasksOnClick: true,
    addRowOnTab: true,
    recalculateParents: true,
    cascadeChanges: false,
    showTodayLine: false,
    enableBaseline: false,
    baselineVisible: false,
    enableAnimations: false,
    animate: false,
    workingTimePlugin: null,
    todayLinePlugin: null,
    allowParentTaskMove: true,
    allowParentTaskDependencies: true,
    enableDragCreation: true,
    eventRenderer: Ext.emptyFn,
    eventRendererScope: null,
    eventTemplate: null,
    parentEventTemplate: null,
    rollupTemplate: null,
    milestoneTemplate: null,
    taskBodyTemplate: null,
    parentTaskBodyTemplate: null,
    milestoneBodyTemplate: null,
    autoHeight: null,
    calendar: null,
    taskStore: null,
    dependencyStore: null,
    resourceStore: null,
    assignmentStore: null,
    columnLines: false,
    dndValidatorFn: Ext.emptyFn,
    createValidatorFn: Ext.emptyFn,
    resizeHandles: "both",
    resizeValidatorFn: Ext.emptyFn,
    resizeConfig: null,
    progressBarResizeConfig: null,
    dragDropConfig: null,
    createConfig: null,
    autoFitOnLoad: false,
    showRollupTasks: false,
    enableConstraintsResolutionGui: true,
    constraintResolutionGuiConfig: null,
    refreshLockedTreeOnDependencyUpdate: false,
    _lockedDependencyListeners: null,
    earlyStartColumn: null,
    earlyEndColumn: null,
    lateStartColumn: null,
    lateEndColumn: null,
    earlyDatesListeners: null,
    lateDatesListeners: null,
    slackListeners: null,
    refreshTimeout: 100,
    lastFocusedRecord: null,
    lastFocusedRecordFrom: null,
    ganttEditingPlugin: null,
    simpleCascadeThreshold: 30,
    setShowRollupTasks: function(b) {
        this.showRollupTasks = b;
        var a = this.getSchedulingView();
        a.setShowRollupTasks(b)
    },
    onCalendarSet: function(a, b) {
        if (this.needToTranslateOption("weekendsAreWorkdays")) {
            b.setWeekendsAreWorkDays(this.weekendsAreWorkdays)
        }
        if (this.workingTimePlugin) {
            this.workingTimePlugin.bindCalendar(b);
            this.workingTimePlugin.refresh()
        }
        this.calendar = b
    },
    initStores: function() {
        if (this.crudManager) {
            if (!this.taskStore) {
                this.taskStore = this.crudManager.getTaskStore()
            }
            if (!this.dependencyStore) {
                this.dependencyStore = this.crudManager.getDependencyStore()
            }
            if (!this.resourceStore) {
                this.resourceStore = this.crudManager.getResourceStore()
            }
            if (!this.assignmentStore) {
                this.assignmentStore = this.crudManager.getAssignmentStore()
            }
        }
        if (!this.taskStore) {
            Ext.Error.raise("You must specify a taskStore config.")
        }
        var a = Ext.StoreMgr.lookup(this.taskStore);
        if (!a) {
            Ext.Error.raise("You have provided an incorrect taskStore identifier")
        }
        if (! (a instanceof Gnt.data.TaskStore)) {
            Ext.Error.raise("A `taskStore` should be an instance of `Gnt.data.TaskStore` (or of a subclass)")
        }
        this.mon(a, {
            calendarset: this.onCalendarSet,
            scope: this
        });
        Ext.apply(this, {
            store: a,
            taskStore: a
        });
        var d = this.calendar = a.calendar;
        if (this.dependencyStore) {
            this.dependencyStore = Ext.StoreMgr.lookup(this.dependencyStore);
            a.setDependencyStore(this.dependencyStore)
        } else {
            this.dependencyStore = a.dependencyStore
        }
        this.dependencyStore.allowParentTaskDependencies = this.allowParentTaskDependencies;
        if (! (this.dependencyStore instanceof Gnt.data.DependencyStore)) {
            Ext.Error.raise("The Gantt dependency store should be a Gnt.data.DependencyStore, or a subclass thereof.")
        }
        var b = this.resourceStore ? Ext.StoreMgr.lookup(this.resourceStore) : a.getResourceStore();
        if (! (b instanceof Gnt.data.ResourceStore)) {
            Ext.Error.raise("A `ResourceStore` should be an instance of `Gnt.data.ResourceStore` (or of a subclass)")
        }
        var c = this.assignmentStore ? Ext.StoreMgr.lookup(this.assignmentStore) : a.getAssignmentStore();
        if (! (c instanceof Gnt.data.AssignmentStore)) {
            Ext.Error.raise("An `assignmentStore` should be an instance of `Gnt.data.AssignmentStore` (or of a subclass)")
        }
        this.bindAssignmentStore(c, true);
        this.bindResourceStore(b, true);
        if (this.needToTranslateOption("weekendsAreWorkdays")) {
            d.setWeekendsAreWorkDays(this.weekendsAreWorkdays)
        }
    },
    initComponent: function() {
        var d = this;
        if (Ext.isBoolean(this.showBaseline)) {
            this.enableBaseline = this.baselineVisible = this.showBaseline;
            this.showBaseline = Gnt.panel.Gantt.prototype.showBaseline
        }
        this.autoHeight = false;
        this.initStores();
        if (this.needToTranslateOption("cascadeChanges")) {
            this.setCascadeChanges(this.cascadeChanges)
        }
        if (this.needToTranslateOption("recalculateParents")) {
            this.setRecalculateParents(this.recalculateParents)
        }
        if (this.needToTranslateOption("skipWeekendsDuringDragDrop")) {
            this.setSkipWeekendsDuringDragDrop(this.skipWeekendsDuringDragDrop)
        }
        this.normalViewConfig = this.normalViewConfig || {};
        Ext.apply(this.normalViewConfig, {
            taskStore: this.taskStore,
            dependencyStore: this.dependencyStore,
            snapRelativeToEventStartDate: this.snapRelativeToEventStartDate,
            enableDependencyDragDrop: this.enableDependencyDragDrop,
            enableTaskDragDrop: this.enableTaskDragDrop,
            enableProgressBarResize: this.enableProgressBarResize,
            enableDragCreation: this.enableDragCreation,
            allowParentTaskMove: this.allowParentTaskMove,
            allowParentTaskDependencies: this.allowParentTaskDependencies,
            toggleParentTasksOnClick: this.toggleParentTasksOnClick,
            resizeHandles: this.resizeHandles,
            enableBaseline: this.baselineVisible || this.enableBaseline,
            leftLabelField: this.leftLabelField,
            rightLabelField: this.rightLabelField,
            topLabelField: this.topLabelField,
            bottomLabelField: this.bottomLabelField,
            eventTemplate: this.eventTemplate,
            parentEventTemplate: this.parentEventTemplate,
            milestoneTemplate: this.milestoneTemplate,
            rollupTemplate: this.rollupTemplate,
            taskBodyTemplate: this.taskBodyTemplate,
            parentTaskBodyTemplate: this.parentTaskBodyTemplate,
            milestoneBodyTemplate: this.milestoneBodyTemplate,
            resizeConfig: this.resizeConfig,
            dragDropConfig: this.dragDropConfig,
            showRollupTasks: this.showRollupTasks
        });
        if (this.topLabelField || this.bottomLabelField) {
            this.addCls("sch-gantt-topbottom-labels " + (this.topLabelField ? "sch-gantt-top-label": ""));
            this.normalViewConfig.rowHeight = 52
        }
        this.configureFunctionality();
        this.mon(this.taskStore, {
            beforecascade: this.onBeforeCascade,
            cascade: this.onAfterCascade,
            scope: this
        });
        this.callParent(arguments);
        if (this.autoFitOnLoad) {
            if (this.store.getCount()) {
                this.zoomToFit()
            }
            this.mon(this.store, "load",
            function() {
                this.zoomToFit()
            },
            this)
        }
        this.bodyCls = (this.bodyCls || "") + " sch-ganttpanel-container-body";
        var c = this.getSchedulingView();
        this.relayEvents(c, ["taskclick", "taskdblclick", "taskcontextmenu", "beforetaskresize", "taskresizestart", "partialtaskresize", "beforetaskresizefinalize", "aftertaskresize", "beforeprogressbarresize", "progressbarresizestart", "afterprogressbarresize", "beforetaskdrag", "taskdragstart", "beforetaskdropfinalize", "beforedragcreate", "dragcreatestart", "beforedragcreatefinalize", "dragcreateend", "afterdragcreate", "taskdrop", "aftertaskdrop", "labeledit_beforestartedit", "labeledit_beforecomplete", "labeledit_complete", "beforedependencydrag", "dependencydragstart", "dependencydrop", "afterdependencydragdrop", "dependencyclick", "dependencycontextmenu", "dependencydblclick", "scheduleclick", "scheduledblclick", "schedulecontextmenu"]);
        if (this.addRowOnTab) {
            var e = this.getSelectionModel();
            e.onEditorTab = Ext.Function.createInterceptor(e.onEditorTab, this.onEditorTabPress, this)
        }
        var b = this.getSchedulingView();
        this.registerRenderer(b.columnRenderer, b);
        var a = " sch-ganttpanel sch-horizontal ";
        if (this.highlightWeekends) {
            a += " sch-ganttpanel-highlightweekends "
        }
        if (!this.rtl) {
            a += " sch-ltr "
        }
        this.addCls(a);
        if (this.eventBorderWidth < 1) {
            this.addCls("sch-gantt-no-task-border")
        }
        if (this.baselineVisible) {
            this.showBaseline()
        }
        this.on("add",
        function(g, f) {
            if (f instanceof Ext.Editor) {
                g.lockedGrid.suspendLayouts();
                g.suspendLayouts();
                g.lockedGrid.add(f);
                g.resumeLayouts();
                g.lockedGrid.resumeLayouts()
            }
        });
        this.on("viewready", this.onMyViewReady, this)
    },
    getTimeSpanDefiningStore: function() {
        return this.taskStore
    },
    bindAutoTimeSpanListeners: function() {
        if (!this.autoFitOnLoad) {
            this.callParent(arguments)
        }
    },
    onBeforeCascade: function() {
        this.lockedGrid.view.onUpdate = this.normalGrid.view.onUpdate = Ext.emptyFn;
        this.suspendLayouts()
    },
    onAfterCascade: function(d, b) {
        var h = this;
        this.lockedGrid.view.onUpdate = this.lockedGrid.view.self.prototype.onUpdate;
        this.normalGrid.view.onUpdate = this.normalGrid.view.self.prototype.onUpdate;
        h.resumeLayouts();
        if (b.nbrAffected > 0) {
            var k = this.lockedGrid.getView();
            if (b.nbrAffected <= h.simpleCascadeThreshold) {
                var i = this.getView();
                var f = this.getSchedulingView();
                var j = {};
                f.suspendEvents(true);
                for (var a in b.affected) {
                    var c = b.affected[a];
                    var g = k.store.indexOf(c);
                    if (g >= 0) {
                        i.refreshNode(g)
                    }
                }
                f.resumeEvents();
                return
            }
            var e = this.normalGrid.getView();
            e.refreshKeepingScroll(true);
            h.suspendLayouts();
            k.refresh();
            h.resumeLayouts()
        }
    },
    bindFullRefreshListeners: function(a) {
        var c = this;
        var d;
        var b = function() {
            if (d) {
                return
            }
            d = setTimeout(function() {
                d = null;
                c.redrawColumns([a])
            },
            c.refreshTimeout)
        };
        a.mon(this.taskStore, {
            append: b,
            insert: b,
            remove: b,
            scope: this
        })
    },
    bindSequentialDataListeners: function(b) {
        var c = this.lockedGrid.view;
        var a = this.taskStore;
        b.mon(a, {
            nodeappend: function(d, f, e) {
                if (!a.fillCount) {
                    this.updateAutoGeneratedCells(b, e)
                }
            },
            nodeinsert: function(d, f, e) {
                this.updateAutoGeneratedCells(b, c.store.indexOf(e))
            },
            move: function(g, e, f) {
                if (g.__recordBelow) {
                    var h = c.store;
                    var d = Math.min(h.indexOf(g), h.indexOf(g.__recordBelow));
                    this.updateAutoGeneratedCells(b, d)
                }
            },
            _noderemove: function(f, d, e) {
                this.updateAutoGeneratedCells(b, this.lockedGrid.view.all.startIndex)
            },
            scope: this
        });
        b.mon(this.lockedGrid.getView(), {
            itemremove: function(f, d, e) {
                this.updateAutoGeneratedCells(b, this.lockedGrid.view.all.startIndex)
            },
            scope: this
        })
    },
    bindSlackListeners: function() {
        var a = Ext.Function.createBuffered(this.updateSlackColumns, this.refreshTimeout, this, []);
        this.slackListeners = this.mon(this.taskStore, {
            resetearlydates: a,
            resetlatedates: a,
            scope: this,
            destroyable: true
        })
    },
    bindEarlyDatesListeners: function() {
        var a = Ext.Function.createBuffered(this.updateEarlyDateColumns, this.refreshTimeout, this, []);
        this.earlyDatesListeners = this.mon(this.taskStore, {
            resetearlydates: a,
            scope: this,
            destroyable: true
        })
    },
    bindLateDatesListeners: function() {
        var a = Ext.Function.createBuffered(this.updateLateDateColumns, this.refreshTimeout, this, []);
        this.lateDatesListeners = this.mon(this.taskStore, {
            resetlatedates: a,
            scope: this,
            destroyable: true
        })
    },
    onEditorTabPress: function(b, f) {
        var g = this.lockedGrid.headerCt,
        a = b.getActiveRecord(),
        d = g.items.indexOf(b.getActiveColumn()),
        i = this.store.indexOf(a) === this.getStore().getCount() - 1,
        h = function(e) {
            return g.items.indexOf(e) > d && e.isVisible() && e.getEditor()
        };
        if (i && g.items.findIndexBy(h) < 0) {
            var c = a.addTaskBelow({
                leaf: true
            }); ! Sch.disableOverrides && b.on("beforeedit",
            function(e, m) {
                var l = m.column;
                var k = b.getEditor(c, l);
                var j = this.lockedGrid.view;
                k.on("startedit",
                function() {
                    j.scrollCellIntoView(j.getCell(c, l))
                },
                null, {
                    single: true,
                    delay: 1
                })
            },
            this, {
                single: true
            })
        }
    },
    needToTranslateOption: function(a) {
        return this.hasOwnProperty(a) || this.self.prototype.hasOwnProperty(a) && this.self != Gnt.panel.Gantt
    },
    getDependencyView: function() {
        return this.getSchedulingView().getDependencyView()
    },
    disableWeekendHighlighting: function(a) {
        this.workingTimePlugin.setDisabled(a)
    },
    resolveTaskRecord: function(a) {
        return this.getSchedulingView().resolveTaskRecord(a)
    },
    fitTimeColumns: function() {
        this.getSchedulingView().fitColumns()
    },
    getResourceStore: function() {
        return this.getTaskStore().getResourceStore()
    },
    getAssignmentStore: function() {
        return this.getTaskStore().getAssignmentStore()
    },
    getTaskStore: function() {
        return this.taskStore
    },
    getEventStore: function() {
        return this.taskStore
    },
    getDependencyStore: function() {
        return this.dependencyStore
    },
    onDragDropStart: function() {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable()
        }
    },
    onDragDropEnd: function() {
        if (this.tip) {
            this.tip.enable()
        }
    },
    configureFunctionality: function() {
        var a = this.plugins = [].concat(this.plugins || []);
        if (this.highlightWeekends) {
            this.workingTimePlugin = Ext.create("Gnt.feature.WorkingTime", {
                calendar: this.calendar
            });
            a.push(this.workingTimePlugin)
        }
        if (this.showTodayLine) {
            this.todayLinePlugin = new Sch.plugin.CurrentTimeLine();
            a.push(this.todayLinePlugin)
        }
        if (this.enableConstraintsResolutionGui && !Ext.Array.findBy(a,
        function(b) {
            return (b instanceof Gnt.plugin.ConstraintResolutionGui) || (b.ptype == "constraintresolutiongui")
        })) {
            a.push(Ext.apply(this.constraintResolutionGuiConfig || {},
            {
                pluginId: "constraintresolutiongui",
                ptype: "constraintresolutiongui"
            }))
        }
    },
    getWorkingTimePlugin: function() {
        return this.workingTimePlugin
    },
    registerLockedDependencyListeners: function() {
        var b = this;
        var a = this.getDependencyStore();
        this._lockedDependencyListeners = this._lockedDependencyListeners || {
            load: function() {
                var c = b.getTaskStore();
                c.resetEarlyDates();
                c.resetLateDates();
                b.lockedGrid.getView().refresh()
            },
            clear: function() {
                var c = b.getTaskStore();
                c.resetEarlyDates();
                c.resetLateDates();
                b.lockedGrid.getView().refresh()
            },
            add: function(d, c) {
                for (var e = 0; e < c.length; e++) {
                    b.updateDependencyTasks(c[e])
                }
            },
            update: function(i, f, h) {
                if (h != Ext.data.Model.COMMIT) {
                    var e = b.lockedGrid.view;
                    var g = e.store;
                    if (f.previous[f.fromField]) {
                        var d = b.taskStore.getByInternalModelId(f.previous[f.fromField]);
                        if (d) {
                            e.refreshNode(g.indexOf(d))
                        }
                    }
                    if (f.previous[f.toField]) {
                        var c = b.taskStore.getByInternalModelId(f.previous[f.toField]);
                        if (c) {
                            e.refreshNode(g.indexOf(c))
                        }
                    }
                    b.updateDependencyTasks(f)
                }
            },
            remove: function(d, c) {
                Ext.Array.each(c,
                function(e) {
                    b.updateDependencyTasks(e)
                })
            }
        };
        this.mun(a, this._lockedDependencyListeners);
        this.mon(a, this._lockedDependencyListeners)
    },
    updateDependencyTasks: function(c) {
        var b = c.getSourceTask(this.taskStore);
        var e = c.getTargetTask(this.taskStore);
        var f = this.lockedGrid.getView();
        var a = f.store.indexOf(b);
        var d = f.store.indexOf(e);
        if (b && b.getTreeStore() && a >= 0) {
            f.refreshNode(a)
        }
        if (e && e.getTreeStore() && d >= 0) {
            f.refreshNode(d)
        }
    },
    showBaseline: function() {
        this.addCls("sch-ganttpanel-showbaseline")
    },
    hideBaseline: function() {
        this.removeCls("sch-ganttpanel-showbaseline")
    },
    toggleBaseline: function() {
        this.toggleCls("sch-ganttpanel-showbaseline")
    },
    zoomToFit: function(c, a) {
        a = Ext.apply({
            adjustStart: 1,
            adjustEnd: 1
        },
        a);
        if (!c && this.taskStore.isTreeFiltered()) {
            c = this.getSchedulingView().store.getRange()
        }
        var b = c ? this.taskStore.getTimeSpanForTasks(c) : this.taskStore.getTotalTimeSpan();
        if (this.zoomToSpan(b, a) === null) {
            if (!c) {
                this.fitTimeColumns()
            }
        }
    },
    getCascadeChanges: function() {
        return this.taskStore.cascadeChanges
    },
    setCascadeChanges: function(a) {
        this.taskStore.cascadeChanges = a
    },
    getRecalculateParents: function() {
        return this.taskStore.recalculateParents
    },
    setRecalculateParents: function(a) {
        this.taskStore.recalculateParents = a
    },
    setSkipWeekendsDuringDragDrop: function(a) {
        this.taskStore.skipWeekendsDuringDragDrop = this.skipWeekendsDuringDragDrop = a
    },
    getSkipWeekendsDuringDragDrop: function() {
        return this.taskStore.skipWeekendsDuringDragDrop
    },
    bindResourceStore: function(d, a) {
        var c = this;
        var b = {
            scope: c,
            update: c.onResourceStoreUpdate,
            datachanged: c.onResourceStoreDataChanged
        };
        if (!a && c.resourceStore) {
            if (d !== c.resourceStore && c.resourceStore.autoDestroy) {
                c.resourceStore.destroy()
            } else {
                c.mun(c.resourceStore, b)
            }
            if (!d) {
                c.resourceStore = null
            }
        }
        if (d) {
            d = Ext.data.StoreManager.lookup(d);
            c.mon(d, b);
            this.taskStore.setResourceStore(d)
        }
        c.resourceStore = d;
        if (d && !a) {
            c.refreshViews()
        }
    },
    refreshViews: function() {
        if (!this.rendered) {
            return
        }
        var b = this.lockedGrid.getView(),
        a = {
            left: b.getScrollX(),
            top: b.getScrollY()
        };
        b.refresh();
        this.getSchedulingView().refreshKeepingScroll();
        b.setScrollX(a.left);
        b.setScrollY(a.top)
    },
    bindAssignmentStore: function(d, a) {
        var c = this;
        var b = {
            scope: c,
            beforetaskassignmentschange: c.onBeforeSingleTaskAssignmentChange,
            taskassignmentschanged: c.onSingleTaskAssignmentChange,
            update: c.onAssignmentStoreUpdate,
            datachanged: c.onAssignmentStoreDataChanged
        };
        if (!a && c.assignmentStore) {
            if (d !== c.assignmentStore && c.assignmentStore.autoDestroy) {
                c.assignmentStore.destroy()
            } else {
                c.mun(c.assignmentStore, b)
            }
            if (!d) {
                c.assignmentStore = null
            }
        }
        if (d) {
            d = Ext.data.StoreManager.lookup(d);
            c.mon(d, b);
            this.taskStore.setAssignmentStore(d)
        }
        c.assignmentStore = d;
        if (d && !a) {
            c.refreshViews()
        }
    },
    onResourceStoreUpdate: function(a, b) {
        var c = b.getTasks();
        Ext.Array.each(c,
        function(d) {
            var e = this.lockedGrid.view.store.indexOf(d);
            if (e >= 0) {
                this.getView().refreshNode(e)
            }
        },
        this)
    },
    onResourceStoreDataChanged: function() {
        if (this.taskStore.getRootNode().childNodes.length > 0) {
            this.refreshViews()
        }
    },
    onAssignmentStoreDataChanged: function() {
        if (this.taskStore.getRootNode().childNodes.length > 0) {
            this.refreshViews()
        }
    },
    onAssignmentStoreUpdate: function(b, d) {
        var a = d.getTask();
        if (a) {
            var c = this.lockedGrid.view.store.indexOf(a);
            if (c >= 0) {
                this.getView().refreshNode(c)
            }
        }
    },
    onBeforeSingleTaskAssignmentChange: function() {
        this.assignmentStore.un("datachanged", this.onAssignmentStoreDataChanged, this)
    },
    onSingleTaskAssignmentChange: function(e, d, c) {
        this.assignmentStore.on("datachanged", this.onAssignmentStoreDataChanged, this);
        if (this.rendered) {
            var a = this.taskStore.getNodeById(d);
            if (a && a.parentNode) {
                var b = this.taskStore.indexOf(a);
                if (b >= 0) {
                    this.getView().refreshNode(b)
                }
            }
        }
    },
    updateAutoGeneratedCells: function(e, c) {
        var b = this.lockedGrid.view;
        var h = b.all.startIndex;
        var f = b.all.endIndex;
        if (c < 0 || c > f) {
            return
        }
        for (var d = Math.max(h, c); d <= f; d++) {
            var g = b.store.getAt(d);
            var a = this.getCellDom(b, g, e);
            if (a) {
                a.firstChild.innerHTML = e.renderer(null, null, g)
            }
        }
    },
    getCellDom: function(b, a, c) {
        var d = b.getNode(a, true);
        return d && Ext.fly(d).down(c.getCellSelector(), true)
    },
    redrawColumns: function(g) {
        if (g.length && !this.isDestroyed) {
            var b = this.lockedGrid.view;
            for (var e = b.all.startIndex; e <= b.all.endIndex; e++) {
                var h = b.store.getAt(e);
                for (var d = 0,
                f = g.length; d < f; d++) {
                    var a = this.getCellDom(b, h, g[d]);
                    if (a) {
                        var c = [];
                        b.renderCell(g[d], h, e, g[d].getIndex(), e, c);
                        a.innerHTML = c.join("")
                    }
                }
            }
        }
    },
    updateSlackColumns: function() {
        if (this.slackColumn) {
            this.redrawColumns([this.slackColumn])
        }
    },
    updateEarlyDateColumns: function() {
        var a = [];
        if (this.earlyStartColumn) {
            a.push(this.earlyStartColumn)
        }
        if (this.earlyEndColumn) {
            a.push(this.earlyEndColumn)
        }
        if (a.length) {
            this.redrawColumns(a)
        }
    },
    updateLateDateColumns: function() {
        var a = [];
        if (this.lateStartColumn) {
            a.push(this.lateStartColumn)
        }
        if (this.lateEndColumn) {
            a.push(this.lateEndColumn)
        }
        if (a.length) {
            this.redrawColumns(a)
        }
    },
    onMyViewReady: function() {
        this.on("beforeedit",
        function(e, f) {
            var d = f.column;
            return ! this.isReadOnly() && f.record.isEditable(f.field) && (!d.isEditable || d.isEditable(f.record))
        },
        this);
        this.setupColumnListeners();
        var b = this.getDependencyView();
        this.getView().on({
            expandbody: b.renderAllDependencies,
            collapsebody: b.renderAllDependencies,
            scope: b
        });
        var a = this.lockedGrid.plugins || [];
        Ext.Array.each(a,
        function(d) {
            if (Sch.plugin && Sch.plugin.TreeCellEditing && d instanceof Sch.plugin.TreeCellEditing) {
                this.ganttEditingPlugin = d;
                return false
            }
        },
        this);
        this.mon(this.taskStore, {
            "nodestore-datachange-start": this.onFilterChange,
            "filter-clear": this.onFilterChange,
            scope: this
        });
        var c = this.down("splitter");
        if (c) {
            c.on("dragend",
            function() {
                this.saveState()
            },
            this, {
                delay: 10
            })
        }
    },
    onFilterChange: function() {
        this.getSelectionModel().deselectAll()
    },
    setupColumnListeners: function() {
        var a = this;
        var b = this.lockedGrid.headerCt;
        b.on("add", this.onLockedColumnAdded, this);
        b.items.each(function(c) {
            a.onLockedColumnAdded(b, c)
        })
    },
    onLockedColumnAdded: function(b, a) {
        var c = Gnt.column;
        if (c) {
            if ((c.WBS && a instanceof c.WBS) || (c.Sequence && a instanceof c.Sequence)) {
                this.bindSequentialDataListeners(a)
            } else {
                if (c.Dependency && a instanceof c.Dependency && a.useSequenceNumber) {
                    this.bindFullRefreshListeners(a)
                } else {
                    if (c.EarlyStartDate && a instanceof c.EarlyStartDate) {
                        this.earlyStartColumn = a
                    } else {
                        if (c.EarlyEndDate && a instanceof c.EarlyEndDate) {
                            this.earlyEndColumn = a
                        } else {
                            if (c.LateStartDate && a instanceof c.LateStartDate) {
                                this.lateStartColumn = a
                            } else {
                                if (c.LateEndDate && a instanceof c.LateEndDate) {
                                    this.lateEndColumn = a
                                } else {
                                    if (c.Slack && a instanceof c.Slack) {
                                        this.slackColumn = a
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!this.slackListeners && this.slackColumn) {
            this.bindSlackListeners()
        }
        if (!this.earlyDatesListeners && (this.earlyStartColumn || this.earlyEndColumn)) {
            this.bindEarlyDatesListeners()
        }
        if (!this.lateDatesListeners && (this.lateStartColumn || this.lateEndColumn)) {
            this.bindLateDatesListeners()
        }
    },
    getState: function() {
        var a = this,
        b = a.callParent(arguments);
        b.lockedWidth = a.lockedGrid.getWidth();
        return b
    },
    applyState: function(b) {
        var a = this;
        a.callParent(arguments);
        if (b && b.lockedWidth) {
            a.lockedGrid.setWidth(b.lockedWidth)
        }
    },
    completeEdit: function() {
        this.ganttEditingPlugin && this.ganttEditingPlugin.completeEdit()
    },
    cancelEdit: function() {
        this.ganttEditingPlugin && this.ganttEditingPlugin.cancelEdit()
    }
});
Ext.define("Gnt.panel.ResourceHistogram", {
    extend: "Sch.panel.TimelineGridPanel",
    requires: ["Ext.XTemplate", "Sch.util.Date", "Gnt.feature.WorkingTime", "Gnt.column.Scale", "Gnt.view.ResourceHistogram"],
    alias: "widget.resourcehistogram",
    viewType: "resourcehistogramview",
    layout: "border",
    preserveScrollOnRefresh: true,
    showScaleLines: false,
    showLimitLines: true,
    showLimitLinesThreshold: 10,
    showVerticalLimitLines: true,
    calendarListeners: null,
    calendarListenersHash: null,
    calendar: null,
    taskStore: null,
    resourceStore: null,
    assignmentStore: null,
    startDate: null,
    endDate: null,
    highlightWeekends: true,
    allocationData: null,
    scaleUnit: "HOUR",
    scaleMin: 0,
    scaleMax: 24,
    scaleLabelStep: 4,
    scaleStep: 2,
    rowHeight: 50,
    resourceText: "Resource",
    scaleColumnConfigs: ["scalePoints", "scaleStep", "scaleLabelStep", "scaleMin", "scaleMax", "scaleLabelStep", "scaleStep"],
    normalViewConfigs: ["barCls", "barTpl", "barRenderer", "lineTpl", "lineCls", "limitLineTpl", "limitLineCls", "limitLineWidth", "labelMode", "labelPercentFormat", "labelUnitsFormat", "scaleMin", "scaleMax", "scaleStep", "loadMask", "showLimitLinesThreshold", "showVerticalLimitLines"],
    initComponent: function() {
        this.lockedViewConfig = this.lockedViewConfig || {};
        this.normalViewConfig = this.normalViewConfig || {};
        this.normalViewConfig.histogram = this;
        this.normalViewConfig.trackOver = false;
        this.lockedGridConfig = this.lockedGridConfig || {};
        Ext.applyIf(this.lockedGridConfig, {
            reserveScrollbar: false,
            width: 300,
            forceFit: true
        });
        this.lockedViewConfig.rowHeight = this.normalViewConfig.rowHeight = this.rowHeight;
        this.lockedViewConfig.preserveScrollOnRefresh = this.normalViewConfig.preserveScrollOnRefresh = this.preserveScrollOnRefresh;
        if (this.scalePoints) {
            this.scalePoints.sort(function(d, c) {
                return d.value > c.value ? 1 : -1
            });
            this.scaleMin = this.scalePoints[0].value;
            this.scaleMax = this.scalePoints[this.scalePoints.length - 1].value;
            this.scaleStep = (this.scaleMax - this.scaleMin) / 10
        }
        if (this.crudManager) {
            this.taskStore = this.taskStore || this.crudManager.getTaskStore();
            this.resourceStore = this.resourceStore || this.crudManager.getResourceStore();
            this.assignmentStore = this.assignmentStore || this.crudManager.getAssignmentStore()
        }
        this.initColumns();
        Ext.Array.forEach(this.normalViewConfigs,
        function(c) {
            if (c in this) {
                this.normalViewConfig[c] = this[c]
            }
        },
        this);
        this.store = this.resourceStore;
        this.taskStore = this.taskStore || this.store.getTaskStore();
        if (this.taskStore) {
            this.mon(this.taskStore, {
                refresh: this.onTaskStoreRefresh,
                load: this.onTaskStoreRefresh,
                update: this.onTaskUpdate,
                nodeappend: this.onTaskUpdate,
                scope: this
            })
        }
        this.calendar = this.calendar || this.taskStore && this.taskStore.getCalendar();
        if (!this.calendar) {
            throw 'Cannot get project calendar instance: please specify either "calendar" or "taskStore" option'
        }
        this.mon(this.calendar, {
            calendarchange: this.onProjectCalendarChange,
            scope: this
        });
        this.bindCalendarListeners();
        this.assignmentStore = this.assignmentStore || this.store.getAssignmentStore() || this.taskStore && this.taskStore.getAssignmentStore();
        if (this.assignmentStore) {
            this.mon(this.assignmentStore, {
                refresh: this.onAssignmentsRefresh,
                remove: this.onAssignmentsChange,
                update: this.onAssignmentsChange,
                add: this.onAssignmentsChange,
                scope: this
            })
        }
        this.plugins = [].concat(this.plugins || []);
        if (this.highlightWeekends) {
            this.initWeekendsHightlight()
        }
        this.callParent(arguments);
        var b = "gnt-resourcehistogram sch-horizontal ";
        if (this.highlightWeekends) {
            b += " gnt-resourcehistogram-highlightweekends "
        }
        this.addCls(b);
        var a = this.getSchedulingView();
        this.registerRenderer(this.columnRenderer, this);
        this.relayEvents(a, ["barclick", "bardblclick", "barcontextmenu"]);
        if (!this.syncRowHeight) {
            this.enableRowHeightInjection(this.lockedGrid.getView(), this.normalGrid.getView())
        }
        this.resetAllocationDataCache();
        this.mon(this.store, {
            update: this.onResourceUpdate,
            refresh: this.onResourceStoreRefresh,
            scope: this,
            priority: 100
        })
    },
    createDefaultColumns: function() {
        var b = [],
        c,
        a;
        c = this.resourceNameCol = new Ext.grid.column.Column({
            flex: 1,
            resizable: false,
            header: this.resourceText,
            dataIndex: this.resourceStore.model.prototype.nameField
        });
        b.push(c);
        a = {
            width: 40,
            resizable: false
        };
        Ext.Array.forEach(this.scaleColumnConfigs,
        function(d) {
            a[d] = this[d]
        },
        this);
        a = this.scaleCol = new Gnt.column.Scale(a);
        this.mon(a, {
            beforerender: function() {
                a.setAvailableHeight(this.getSchedulingView().getAvailableRowHeight());
                if (this.scalePoints) {
                    this.scalePoints = a.scalePoints
                }
            },
            scope: this,
            single: true
        });
        b.push(a);
        return b
    },
    initColumns: function() {
        if (!this.columns) {
            this.columns = this.createDefaultColumns();
            var a = this.scaleCol;
            if (this.scalePoints) {
                this.scaleMin = a.scaleMin;
                this.scaleMax = a.scaleMax;
                this.scaleStep = a.scaleStep
            }
        } else {
            var d = !Ext.isArray(this.columns) ? [this.columns] : this.columns;
            for (var c = 0; c < d.length; c++) {
                var b = d[c];
                if (this.isScaleColumn(b)) {
                    Ext.Array.forEach(this.scaleColumnConfigs,
                    function(e) {
                        if (! (e in b)) {
                            b[e] = this[e]
                        }
                    },
                    this);
                    if (! (b instanceof Gnt.column.Scale)) {
                        b = d[c] = Ext.ComponentManager.create(b, b.xtype)
                    }
                    this.mon(b, {
                        beforerender: function() {
                            b.setAvailableHeight(this.getSchedulingView().getAvailableRowHeight())
                        },
                        scope: this,
                        single: true
                    })
                }
            }
        }
    },
    isScaleColumn: function(a) {
        var b = a.xtype && (Ext.ClassManager.getByAlias(a.xtype));
        b = b && b.prototype;
        return (a instanceof Gnt.column.Scale || (b && b instanceof Gnt.column.Scale))
    },
    initWeekendsHightlight: function() {
        this.workingTimePlugin = new Gnt.feature.WorkingTime({
            calendar: this.calendar
        });
        this.plugins.push(this.workingTimePlugin)
    },
    destroy: function() {
        this.unbindCalendarListeners();
        if (this.assignmentStore) {
            this.mun(this.assignmentStore, {
                refresh: this.onAssignmentsRefresh,
                remove: this.onAssignmentsChange,
                update: this.onAssignmentsChange,
                add: this.onAssignmentsChange,
                scope: this
            })
        }
        if (this.taskStore) {
            this.mun(this.taskStore, {
                refresh: this.onTaskStoreRefresh,
                load: this.onTaskStoreRefresh,
                update: this.onTaskUpdate,
                nodeappend: this.onTaskUpdate,
                scope: this
            })
        }
        this.mun(this.calendar, {
            calendarchange: this.onProjectCalendarChange,
            scope: this
        });
        this.callParent(arguments)
    },
    getEventStore: function() {
        return this.taskStore
    },
    getTimeSpanDefiningStore: function() {
        return this.taskStore
    },
    onTaskStoreRefresh: function() {
        var a = this;
        a.resetAllocationDataCache();
        a.refreshIfRendered()
    },
    onProjectCalendarChange: function() {
        var a = this;
        a.resetAllocationDataCache();
        a.refreshIfRendered()
    },
    unbindResourceCalendarListeners: function(b) {
        var a = this.calendarListenersHash && this.calendarListenersHash[b.getInternalId()];
        if (a) {
            Ext.Array.remove(this.calendarListeners, a);
            Ext.destroy(a)
        }
    },
    bindResourceCalendarListeners: function(d, e) {
        var c = this;
        e = e || d.getOwnCalendar();
        var b = function() {
            c.resetAllocationDataCache(d);
            c.refreshIfRendered(d)
        };
        var a = c.mon(e, {
            load: b,
            calendarchange: b,
            scope: c,
            destroyable: true
        });
        c.calendarListenersHash[d.getInternalId()] = a;
        c.calendarListeners.push(a)
    },
    bindCalendarListeners: function() {
        this.unbindCalendarListeners();
        var a = this;
        this.store.each(function(b) {
            var c = b.getOwnCalendar();
            if (c && c !== a.calendar) {
                a.bindResourceCalendarListeners(b, c)
            }
        })
    },
    unbindCalendarListeners: function() {
        if (this.calendarListeners && this.calendarListeners.length) {
            Ext.destroy.apply(Ext, this.calendarListeners)
        }
        this.calendarListeners = [];
        this.calendarListenersHash = {}
    },
    onTaskUpdate: function(d, c) {
        var g, h, b, e, a, f;
        if (this.assignmentStore && c.getAssignmentStore() != this.assignmentStore) {
            g = c.getInternalId();
            b = [];
            h = this.assignmentStore.getRange();
            for (e = 0, a = h.length; e < a; ++e) {
                f = h[e];
                if (f.getTaskId() == g) {
                    b.push(f)
                }
            }
        } else {
            b = c.getAssignments()
        }
        this.onAssignmentsChange(this.assignmentStore, b)
    },
    onAssignmentsRefresh: function(a) {
        this.onAssignmentsChange(a, a.getRange())
    },
    onAssignmentsChange: function(g, a, d, e, h) {
        var k = this,
        j = k.assignmentStore.model.prototype.resourceIdField,
        c;
        if (d == Ext.data.Model.EDIT && e && Ext.Array.contains(e, j)) {
            var n = a.previous || h,
            m = n[j];
            c = this.resourceStore.getByInternalId(m);
            if (c) {
                k.resetAllocationDataCache(c);
                k.refreshIfRendered(c)
            }
        }
        if (!Ext.isArray(a)) {
            a = [a]
        }
        for (var f = 0,
        b = a.length; f < b; f++) {
            c = this.resourceStore.getByInternalId(a[f].getResourceId());
            if (c) {
                k.resetAllocationDataCache(c);
                k.refreshIfRendered(c)
            }
        }
    },
    enableRowHeightInjection: function(a, c) {
        var b = new Ext.XTemplate("{%", "this.processCellValues(values);", "this.nextTpl.applyOut(values, out, parent);", "%}", {
            priority: 1,
            processCellValues: function(e) {
                if (c.orientation == "horizontal") {
                    var d = c.getAvailableRowHeight();
                    e.style = (e.style || "") + ";height:" + d + "px;"
                }
            }
        });
        a.addCellTpl(b);
        c.addCellTpl(b)
    },
    findEndIndex: function(d, c) {
        c = c || this.getEndDate();
        var a = d.length - 1;
        for (var b = a; b >= 0; b--) {
            if (d[b].endDate >= c) {
                a = b
            }
        }
        return a
    },
    findStartIndex: function(e, b) {
        b = b || this.getStartDate();
        var a = 0;
        for (var d = 0,
        c = e.length; d < c; d++) {
            if (e[d].startDate <= b) {
                a = d
            }
        }
        return a
    },
    resetAllocationDataCache: function(b) {
        var a = this;
        if (!b) {
            a.allocationData = {}
        } else {
            a.allocationData = a.allocationData || {};
            a.allocationData[b.getInternalId()] = null
        }
    },
    updateAllocationDataCache: function(e, a, g) {
        var c = Sch.util.Date,
        i = this,
        h, f, b, d, j;
        a = a || i.getStartDate();
        g = g || i.getEndDate();
        if (!e) {
            i.resourceStore.each(function(k) {
                i.updateAllocationDataCache(k, a, g)
            })
        } else {
            h = i.allocationData[e.getInternalId()] || {};
            f = h.cacheStart;
            b = h.cacheEnd;
            if ((f != a || b != g) && (f && b && c.intersectSpans(f, b, a, g))) {
                if (f > a) {
                    d = i.processAllocationData(e.getAllocationInfo({
                        startDate: a,
                        endDate: f,
                        includeResCalIntervals: true
                    }));
                    d.maxBars.length && (d.maxBars[d.maxBars.length - 1].endDate = f);
                    h.maxBars.length && (h.maxBars[0].startDate = f);
                    h.bars = d.bars.concat(h.bars);
                    h.maxBars = d.maxBars.concat(h.maxBars);
                    h.maxBarsStartIndex = 0;
                    h.barsStartIndex = 0;
                    h.cacheStart = a
                } else {
                    h.maxBarsStartIndex = i.findStartIndex(h.maxBars, a);
                    h.barsStartIndex = i.findStartIndex(h.bars, a)
                }
                if (b < g) {
                    j = i.processAllocationData(e.getAllocationInfo({
                        startDate: b,
                        endDate: g,
                        includeResCalIntervals: true
                    }));
                    j.maxBars.length && (j.maxBars[0].startDate = b);
                    h.maxBars.length && (h.maxBars[h.maxBars.length - 1].endDate = b);
                    h.bars = h.bars.concat(j.bars);
                    h.maxBars = h.maxBars.concat(j.maxBars);
                    h.maxBarsEndIndex = h.maxBars.length - 1;
                    h.barsEndIndex = h.bars.length - 1;
                    h.cacheEnd = g
                } else {
                    h.maxBarsEndIndex = i.findEndIndex(h.maxBars, g);
                    h.barsEndIndex = i.findEndIndex(h.bars, g)
                }
            } else {
                if (f != a || b != g) {
                    h = i.processAllocationData(e.getAllocationInfo({
                        startDate: a,
                        endDate: g,
                        includeResCalIntervals: true
                    }));
                    h.maxBarsStartIndex = 0;
                    h.maxBarsEndIndex = h.maxBars.length - 1;
                    h.barsStartIndex = 0;
                    h.barsEndIndex = h.bars.length - 1;
                    h.cacheStart = a;
                    h.cacheEnd = g
                }
            }
            i.allocationData[e.getInternalId()] = h
        }
    },
    loadAllocationDataCache: function(c) {
        var b = this,
        d = b.getStartDate(),
        a = b.getEndDate();
        if (!c) {
            b.resetAllocationDataCache();
            b.updateAllocationDataCache(null, d, a)
        } else {
            b.resetAllocationDataCache(c);
            b.updateAllocationDataCache(c, d, a)
        }
    },
    processAllocationData: function(B) {
        var y, z, m, w, q, c, b, o, d, C, f, g, t = [],
        k = [],
        a = false,
        A = this;
        var r = function() {
            if (!z.assignments || !y.inResourceCalendar || !y.totalAllocation || !y.inTasksCalendar) {
                return false
            }
            for (var D = 0,
            j = z.assignments.length; D < j; D++) {
                if (y.assignmentsHash[z.assignments[D].getTaskId()]) {
                    return false
                }
            }
            return true
        };
        var p = function(i) {
            z = {
                startDate: i,
                totalAllocation: y.totalAllocation,
                allocationMS: b,
                assignments: y.assignments,
                totalOverAllocationMS: f
            };
            a = true
        };
        var h = function(i) {
            if (!a) {
                return false
            }
            if (i) {
                z.endDate = i
            }
            t.push(z);
            a = false
        };
        var n = function(j, i) {
            if (!j) {
                return false
            }
            var D = Sch.util.Date.getDurationInDays(j, i);
            if (D < 2) {
                return false
            }
            var l = true;
            if (m) {
                if (!m.allocationMS) {
                    l = false
                } else {
                    m.endDate = Sch.util.Date.getStartOfNextDay(j, true);
                    k.push(m)
                }
            }
            if (l) {
                m = {
                    startDate: m && m.endDate || A.getStart(),
                    allocationMS: 0
                }
            }
            d = 0;
            return true
        };
        var s;
        for (var x = 0,
        u = B.length; x < u; x++) {
            y = B[x];
            s = Ext.Date.clearTime(y.startDate, true);
            if (s - w !== 0) {
                this.showLimitLines && n(w, s);
                w = s;
                o = b;
                g = f;
                C = d;
                b = 0;
                f = 0;
                d = 0;
                var v = x;
                while (B[v] && Ext.Date.clearTime(B[v].startDate, true) - s === 0) {
                    if (B[v].inResourceCalendar) {
                        d += B[v].endDate - B[v].startDate;
                        if (B[v].totalAllocation && B[v].inTasksCalendar) {
                            b += B[v].totalAllocationMS || (B[v].endDate - B[v].startDate) * B[v].totalAllocation / 100;
                            f += B[v].totalOverAllocationMS || 0
                        }
                    }
                    v++
                }
            } else {
                s = false
            }
            if (this.showLimitLines) {
                if (s && d != C) {
                    if (m) {
                        m.endDate = s;
                        k.push(m)
                    }
                    m = {
                        startDate: s,
                        allocationMS: d
                    }
                }
                m.endDate = y.endDate
            }
            if (!a) {
                if (y.inTask) {
                    p(new Date(y.startDate))
                }
            } else {
                if (!y.inTask) {
                    h()
                } else {
                    var e = false;
                    if (s && z.endDate <= Sch.util.Date.add(s, Sch.util.Date.DAY, -1)) {
                        q = Ext.Date.clearTime(z.endDate, true);
                        if (q < z.endDate) {
                            q = Sch.util.Date.add(q, Sch.util.Date.DAY, 1)
                        }
                        c = Ext.Date.clearTime(y.startDate, true);
                        e = true
                    } else {
                        if (s && b !== o && y.totalAllocation && y.totalAllocation == z.totalAllocation) {
                            q = c = y.startDate;
                            e = true
                        } else {
                            if (y.totalAllocation && r()) {
                                q = z.endDate;
                                c = new Date(y.startDate);
                                e = true
                            } else {
                                if (y.totalAllocation && y.totalAllocation != z.totalAllocation) {
                                    q = c = y.totalAllocation > z.totalAllocation ? new Date(y.startDate) : z.endDate;
                                    e = true
                                }
                            }
                        }
                    }
                    if (e) {
                        h(q);
                        p(c)
                    }
                }
            }
            if (a) {
                z.endDate = y.endDate
            }
        }
        h();
        if (this.showLimitLines) {
            n(w || this.getStart(), this.getEnd());
            if (m) {
                k.push(m)
            }
            if (k.length) {
                k[0].startDate = null;
                k[k.length - 1].endDate = null
            }
        }
        return {
            bars: t,
            maxBars: k
        }
    },
    onResourceUpdate: function(b, e, a, c) {
        var d = b.model;
        if (Ext.Array.indexOf(d.prototype.calendarIdField, c) > -1) {
            this.resetAllocationDataCache(e);
            this.unbindResourceCalendarListeners(e);
            var f = e.getOwnCalendar();
            if (f && f !== this.calendar) {
                this.bindResourceCalendarListeners(e, f)
            }
        }
    },
    onResourceStoreRefresh: function() {
        var a = this;
        a.resetAllocationDataCache();
        a.refreshIfRendered();
        a.bindCalendarListeners()
    },
    refreshIfRendered: function(b) {
        var a = this;
        if (a.rendered && a.resourceStore && b) {
            a.getView().refreshNode(a.resourceStore.indexOf(b))
        } else {
            if (a.rendered) {
                a.getView().refresh()
            }
        }
    },
    columnRenderer: function(a, k, b, g, j) {
        var f = this,
        d = b.getInternalId(),
        h = this.normalGrid.getView(),
        c,
        i,
        e;
        f.updateAllocationDataCache(b);
        c = this.allocationData[d];
        i = c && c.bars;
        e = c && c.maxBars;
        if (i && (c.barsStartIndex > 0 || c.barsEndIndex < i.length - 1)) {
            i = Ext.Array.slice(i, c.barsStartIndex, c.barsEndIndex + 1)
        }
        if (e && (c.maxBarsStartIndex > 0 || c.maxBarsEndIndex < e.length - 1)) {
            e = Ext.Array.slice(e, c.maxBarsStartIndex, c.maxBarsEndIndex + 1)
        }
        return (this.showScaleLines ? h.renderLines(this) : "") + h.renderBars(this, i, d) + (this.showLimitLines ? h.renderLimitLines(this, e) : "")
    }
});
//if (!window.location.href.match("bryntum.com|ext-scheduler.com")) {
//    var log = function(a) {
//        if (window.console) {
//            console.log(a)
//        }
//    };
//    log("BRYNTUM TRIAL LICENSE, for purchasing and licensing options please visit: www.bryntum.com/store (btw, we're hiring: www.bryntum.com/company/careers )");
//    function newRefresh() {
//        this.callOverridden(arguments);
//        if (this.__injected || !this.rendered) {
//            return
//        }
//        this.__injected = true;
//        Ext.Function.defer(function() {
//            this.el && this.el.select(this.eventSelector).setOpacity(0.15);
//            log("TRIAL VERSION: PRODUCT DEACTIVATED")
//        },
//        10 * 60 * 1000, this);
////        var a = this.el.parent().createChild({
////            tag: "a",
////            cls: "bryntum-trial",
////            href: "http://www.bryntum.com/store",
////            title: "Click here to purchase a license",
////            style: "display:block;height:54px;width:230px;background: #fff url(http://www.bryntum.com/site-images/bryntum-trial.png) no-repeat;z-index:10000;border:1px solid #ddd;-webkit-box-shadow: 2px 2px 2px rgba(100, 100, 100, 0.5);-moz-box-shadow: 2px 2px 2px rgba(100, 100, 100, 0.5);-moz-border-radius:5px;-webkit-border-radius:5px;position:absolute;bottom:10px;right:15px;"
////        });
//        try {
//            if (!Ext.util.Cookies.get("bmeval")) {
//                Ext.util.Cookies.set("bmeval", new Date().getTime(), Ext.Date.add(new Date(), Ext.Date.YEAR, 2))
//            } else {
//                var d = Ext.util.Cookies.get("bmeval"),
//                b = new Date(parseInt(d, 10));
//                if (Ext.Date.add(b, Ext.Date.DAY, 45) < new Date()) {
//                    this.el.select(this.eventSelector).hide();
//                    this.el.mask("Trial Period Expired!").setStyle("z-index", 10000);
//                    log("TRIAL PERIOD EXPIRED, PURCHASE A LICENSE HERE http://bryntum.com/");
//                    this.refresh = Ext.emptyFn
//                }
//            }
//        } catch(c) {}
//    }
//    if (Sch && Sch.view && Sch.view.TimelineGridView) {
//        Sch.view.TimelineGridView.override({
//            refresh: Ext.Function.clone(newRefresh)
//        })
//    }
//    if (Sch && Sch.view && Sch.view.TimelineTreeView) {
//        Sch.view.TimelineTreeView.override({
//            refresh: Ext.Function.clone(newRefresh)
//        })
//    }
//}
Ext.data.Connection.override({
    parseStatus: function(b) {
        var a = this.callOverridden(arguments);
        if (b === 0) {
            a.success = true
        }
        return a
    }
});